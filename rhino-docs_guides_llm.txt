MCNEEL RHINO GUIDES DOCUMENTATION
============================================================
OVERVIEW
------------------------------------------------------------
Comprehensive documentation for Rhino guides covering development, APIs, workflows, and examples.
CORE CONCEPTS
------------------------------------------------------------
Rhino is a 3D modeling application with extensive developer APIs.
Documentation covers multiple SDKs: RhinoCommon (.NET), RhinoPython, RhinoScript (VBScript), C/C++, openNURBS, and Grasshopper.


GUIDES / COMPUTE / COMPUTE-FAQ
------------------------------------------------------------

Index
Source: guides\compute\compute-faq\index.md
General

What is Rhino.Compute?

In its simplest definition, Rhino.Compute is a web server that can perform geometry calculations using Rhino's geometry library (i.e. Rhino.Inside). It works by receiving requests over the web (using HTTP or HTTPS), processing them with Rhino’s geometry engine, and then sending back the results. Any application that can send web requests can interact with Rhino.Compute, making it easy to integrate into different workflows.

Why would I want to use it?

Rhino.Compute lets you use Rhino’s powerful tools and features outside of the regular Rhino or Grasshopper interface. It’s great for teams, because you can run Grasshopper definitions or Rhino functions from one central place, making collaboration easier. It can also handle multiple tasks at the same time (in parallel), helping speed up large projects. And for longer calculations, it runs in the background (asynchronously) — so it won’t freeze or slow down your main interface.

Will it work on macOS?

No. Rhino.Compute is dependent on Rhino.Inside which allows Rhino and Grasshopper to run inside other 64-bit applications. Currently, Rhino.Inside is only compatible with the Windows operating system.

Does it cost money?

The short answer is: it depends on where you run Rhino.Compute. If you're using it on a regular Windows computer, like your personal PC, there’s no extra cost. Rhino.Compute will check for your standard Rhino licence on startup ( But if you're running it on a Windows Server (such as a virtual machine in the cloud), you’ll be charged based on our Core-Hour Billing model.

How is it different from Hops?

Hops is a Grasshopper plugin (available from the package manager) that makes it easy to solve Grasshopper definitions using Rhino.Compute. When you install Hops, it automatically starts an instance of Rhino.Compute in the background whenever you open Grasshopper. You can then use the Hops component to send your Grasshop... [truncated]

Essential Code:
Application startup exception
System.Runtime.InteropServices.COMException (0x80004005): Error HRESULT E_FAIL has been returned from a call to a COM component.
   at Rhino.Runtime.InProcess.RhinoCore.InternalStartup(Int32 argc, String[] argv, StartupInfo& info, IntPtr hostWnd)


GUIDES / COMPUTE / COMPUTE-JAVASCRIPT-GETTING-STARTED
------------------------------------------------------------

Next Steps
Source: guides\compute\compute-javascript-getting-started\index.md
By the end of this guide, you should have all the tools installed necessary for using the Rhino Compute through JavaScript.

The libraries will run on on all major browsers as well as node.js.

Setting up a Compute Project using JavaScript

There are a few client side tools which need to be referenced that are essential to communicate with the Compute server. These include:
rhino3dm.js - Is part of the Rhino3dm project. It is a Javascript wrapper and web assembly (WASM) for openNURBS which contains the functions to read and write Rhino Geometry Objects. 
compute-rhino3d.js - This is a work in progress package which is meant to add classes available in RhinoCommon, but not available through rhino3dm.js. Compute-rhino3d makes calls into the McNeel Cloud Compute server for these functions. It handles all the transaction authorizations and JSON data conversion.

In a browser based application index.html would look like this:

 

 {
 "imports": {
 "rhino3dm":"https://unpkg.com/rhino3dm@8.4.0/rhino3dm.module.min.js",
 "rhinocompute": "https://www.unpkg.com/compute-rhino3d@0.13.0-beta/compute.rhino3d.module.js"
 }
 }

 

 In the script.js, import the libraries:
 
 // Import libraries

import rhino3dm from 'rhino3dm'
import { RhinoCompute } from 'rhinocompute'

// Load rhino3dm
const rhino = await rhino3dm()
console.log('Loaded rhino3dm.')

// Your code ...

 

 For a node.js application, first install the libraries with npm:

 npm i rhino3dm compute-rhino3d

 Then reference them in your script:

 
 // Import libraries

 import rhino3dm from 'rhino3dm'
 import RhinoCompute from 'compute-rhino3d'

 // Load rhino3dm
 const rhino = await rhino3dm()
 console.log('Loaded rhino3dm.')



The first use of Compute

Examples of using JavaScript to access compute can be found in the Javascript Sample repo 

Next Steps

Congratulations! You have the tools to use Rhino Compute server. Now what?
To see the transactional nature of Compute, read through compute.rhino3d.js
See a lis... [truncated]

GUIDES / COMPUTE / COMPUTE-NET-GETTING-STARTED
------------------------------------------------------------

Index
Source: guides\compute\compute-net-getting-started\index.md
In this guide, we will detail how you can leverage Rhino Compute&trade; from your .NET development environment in Windows to perform geometric operations in your application.

To be able to make HTTP requests, it is necessary to have Rhino.Compute running on a server, either locally or remotely. If you don't have it set up yet, please visit one of the following guides:
Running Rhino.Compute locally
Deployment to production servers

Prerequisites

Before continuing, please ensure you have the right tools. This guide presumes you have an:
Windows Operating System. Rhino.Compute only runs in Windows 7 or later.
Development Environment. You will need one of the IDEs from Microsoft Visual Studio
Visual Studio 2022. The most comprehensive IDE for .NET developers on Windows.
Visual Studio Code. A standalone cross-platform IDE. It is free and open source.

{{}}
It is recommended that you install the typical installation.
{{}}

Setting up a Compute Project in Visual Studio

Once you have your Rhino.Compute server up and running (either local or remote), there are a few tools which are essential to communicate with it. Here are the detailed descriptions of these tools:
Rhino3dm - The Dotnet wrapper for OpenNurbs which contains the functions to read and write Rhino Geometry Objects. As it is available as a NuGet package, you can download directly using the NuGet Package Manager.
NewtonSoft.JSON - The very popular JSON library. This package is called directly by RhinoCompute.cs as the information is defined in JSON format embedded in the body of a REST POST. As rhino3dm, it is also available as a NuGet Package.
RhinoCompute.cs - This is a work in progress package which is meant to add classes available in RhinoCommon, but not available through Rhino3dm. RhinoCompute makes calls into Rhino for these functions.

Here are step by step instructions to setting up a basic project to use Rhino.Compute:

File New
If you have not done so already, launch Visual Studio. For the purposes o... [truncated]

Essential Code:
{{< /div >}}

The example above first creates a sphere using *Rhino3dm*. Then, we make a call to Rhino.Compute to create a mesh from that Brep object. Rhino.Compute then returns the mesh.  Finally, we use *Rhino3dm* to walk through the mesh and count the number of vertices.

<table class="multiline">
<tr>
<th>Line</th>
<th>Description</th>
</tr>
<tr>
<td>5</td>
<td>Include the Rhino.Compute Assembly from the RhinoCompute.cs Package.</td>
</tr>
<tr>
<td>19</td>
<td>Here the OpenNurbs Brep sphere is sent to Compute to convert to a mesh.  The Mesh is returned as a OpenNurbs Mesh.</td>
</tr>
</table>

Seeing the results of Compute
...

GUIDES / COMPUTE / COMPUTE-PYTHON-GETTING-STARTED
------------------------------------------------------------

Next Steps
Source: guides\compute\compute-python-getting-started\index.md
By the end of this guide, you should have all the tools installed necessary for using the Rhino Compute through Python.

For an getting started video tutorial from Junichiro Horikawa with Python

This guide presumes you have Python installed on the platform:
Python 2.7 - Windows (32 and 64 bit)
Python 3.7 - Windows (32 and 64 bit)
Python 2.7 - OSX (installed through homebrew)
Python 3.7 - OSX (installed through homebrew)
Linux and other python versions are supported through source distributions on PyPi

Setting up a Compute Project in Python

There are a few client side tools which need to be installed in Python that are essential to communicate with the Compute server. These include:
rhino3dm.py - This is the part of the Rhino3dm libraries. It is a Python wrapper for OpenNurbs which contains the functions to read and write Rhino Geometry Objects. This is available as a Pip package.

 pip install rhino3dm
compute-rhino3d.py - This is a work in progress package which is meant to add classes available in RhinoCommon, but not available through rhino3dm.py. Compute-rhino3d makes calls into the McNeel Cloud Compute server for these functions. It handles all the transaction authorizations and JSON data conversion.

 pip install compute-rhino3d

The first use of Compute

An example of using Python to access compute can be found in the makemesh.py example.

py package using a (underbar) and not a - (dash).

Next Steps

Congratulations! You have the tools to use Rhino Compute server. Now what?
To see the transactional nature of Compute, read through compute.rhino3d.py
See a list of the 2400+ API calls available for compute.rhino3d.com.
Download the Compute Samples repo from GitHub.
The libraries are still very new and changing rapidly. Give them a try or get involved. Ask any questions or share what you are working on the Compute Discussion Forum

GUIDES / COMPUTE / CONFIGURE-COMPUTE-FOR-HTTPS
------------------------------------------------------------

Index
Source: guides\compute\configure-compute-for-https\index.md
Overview

In this guide, we will walk through the process of creating a valid SSL certificate so that Rhino.Compute can communicate with clients using the HTTPS protocol.

Prerequisites

The following must be completed:
You must have an active virtual machine (VM) instance. Use the following guides to walk through setting up a VM.

 Create a Virtual Machine on Azure.
 Create a Virtual Machine on AWS.
The VM must be accessible to the web (open port 80, and 443).
A static public IPv4 address must be associated with your virtual machine. To  about configuring static IP address, use the following links:
 Configure IP addresses for an Azure network interface
 Associate an elastic IP address with an EC2 instance
You must have an existing domain and have access to its DNS settings. An A record in your DNS settings must point to the public IPv4 address of your virtual machine.

{{}}
For this guide, I have assoicated an elastic IP address with my virtual machine instance. I have also setup an A record in my DNS settings to point rhino.compute.rhino3d.com at the IP address of my virtual machine.
{{}}

Modify the Host Name

Before we step through the process of generating an SSL certificate, we need to make one modification to our existing IIS configuration for Rhino.Compute.
If you have not already done so, log into your VM (via RDP). See the section Connect via RDP for more details.
On the Start menu, click in the search area and type Internet Information Services (IIS) Manager. Click to launch the app.
In the IIS Manager, click on the web server node in the Connections panel on the left to expand the menu tree. Then click on the Sites node to expand the sub-menu. Lastly, select the Rhino.Compute node from the menu tree to adjust its settings.
In the Actions pane on the right, click Bindings. {{}}
In the Site Bindings pane, select the Add button. {{}}
In the Host name text field, type in the subdomain name that you created when setting up the A-Record. Click OK when done.
{{... [truncated]

GUIDES / COMPUTE / CORE-HOUR-BILLING
------------------------------------------------------------

Index
Source: guides\compute\core-hour-billing\index.md
About Core-Hour Billing

When Rhino is logged in to a service account and is running on a Windows Server-based operating system, you will be billed $0.10 per core per hour that Rhino is running (pro-rated per minute).

Example 1: Rhino running on a 32-core server for one hour:

 1 computer 32-cores 1 hour $0.10/core-hour = $3.20

Example 2: Rhino running on 200 4-core servers for 6 minutes:

 200 computers 4 cores 0.1 hour $0.10/core-hour = $8.00

Example 3: 1 Rhino instance running on a 2-core server 8 hours a day for 30 days:
 1 computer 2 cores 8 hours/day 30 days/month $0.10/core-hour = $48/month

Example 4: 10 Rhino instances running on a 2-core server 8 hours a day for 30 days:
 1 computer 2 cores 8 hours/day 30 days/month $0.10/core-hour = $48/month
 (Notice that the number of instances of Rhino does not affect your bill)

Billing is based on uptime, not on usage - we don’t track the activity of each core, just that you have one running with Rhino. You can scale your workloads up and down to optimize performance and cost to you.

Multiple instances are allowed - you may run as many instances of Rhino on the same machine as you want, and the cost will be the same as running one instance.

Setting Up Core-Hour Billing

Core-hour billing is required when running Rhino on a Windows Server-based operating system.
Go to the Licenses Portal (login to your Rhino account if prompted).
Click Create New Team and create a team to use for your compute project. {{}}
Creating a new team is not strictly required, but core-hour billing is not compatible* with existing licenses in the team. So if your team has licenses in it, core-hour billing will not be allowed.
{{}}
Click Manage Team -> Manage Core-Hour Billing.
Check the checkbox next to the products you want to enable. \
Note, if you've had a team running for years, you may need to enable newer versions of Rhino.
Click Save, and enter payment information when prompted for your new team.

Using Core-Hour Billing
Go to the ... [truncated]

GUIDES / COMPUTE / CREATING-AN-AZURE-VM
------------------------------------------------------------

Index
Source: guides\compute\creating-an-Azure-VM\index.md
Creating the Virtual Machine

In this guide, we will walk through the process of setting up a virtual machine using Azure services. 

To start, please confirm that you have a valid Azure subscription and that you have already setup a resource group to hold the various resources for this instance. To  about setting up a resource group on Azure, visit this page.
Sign in to the Azure portal.
Type virutal machines in the search bar.
Under Services, select Virtual machines.
In the Virtual machines page, select Create then Virtual Machine
In the Basics tab, under Project details, make sure the correct Subscription and Resource group are selected.
Under Instance details, create a unique name for the virutal machine. We'll use Rhino-Compute-VM for our VM name. Select a region close to you, and then select Windows Server 2022 Datacenter - Azure Edition Gen2 for the Image. Feel free to select any Size VM that fits your needs. We'll use Standard DS2_v2 for this example. Leave the other defaults.
{{}}
Under Administrator account, provide a username and a password. Take note of these credentials as we will use these when we log into the remote machine.
Under Inbound port rules, choose Allow selected ports then select RDP (3389), HTTPS (443), and HTTP (80).
{{}}
Select Next : Disk >.
Select Next : Networking >.
Under the Network interface section, click on the Create new button under the Public IP subsection.
When the pop-out blade opens up, select Static under the Assignment tab. Click OK to save this setting.
{{}}
Leave all other defaults. Select Review + create.
Once your configuration passes the validation check, select Create to deploy your virtual machine.
After deployment is complete, select Go to resource.

Add an inbound port rule

Once your virtual machine has been deployed you should be able to go to the resource home page. Here, you can change various settings and configurations. We are going to add an inbound port rule so that we can send API requests on a dedicated ... [truncated]

GUIDES / COMPUTE / CREATING-AN-AWS-VM
------------------------------------------------------------

Index
Source: guides\compute\creating-an-aws-vm\index.md
Overview

In this guide, we will walk through the process of setting up a virtual machine using Amazon Elastic Compute Cloud (Amazon EC2). 

To start, you will need to confirm your AWS subscription. If you are new to AWS, you can get started with Amazon EC2 using the AWS Free Tier. 

{{}}
If you created your AWS account less than 12 months ago, and have not already exceeded the free tier benefits for Amazon EC2, it will not cost you anything to complete this tutorial. Otherwise, you'll incur the standard Amazon EC2 usage fees from the time that you launch the instance until you terminate the instance, even if it remains idle.
{{}}

Prerequisites
Create an account for AWS
Create a key pair. pem format with RSA encryption.
Create a security group. Note, we recommend adding a rule for HTTP, HTTPS, RDP, and All ICMP - IPv4.

Launch the instance

To create a new virtual machine instance on AWS, follow these steps:
Open the Amazon EC2 console.
From the EC2 console dashboard, select Launch Instance.
Provide a name for the VM instance. For this tutorial, we'll use the name "RhinoComputeVM".
Under the section titled Application and OS Images, click on the Windows button under the Quick Start tab. Under the Amazon Machine Image (AMI) section there should be a drop-down menu listing all of the available machine images. Select the AMI for Microsoft Windows Server 2022 Base.
{{}}
In the Instance Type section, select the t2.micro instance type (default) or a larger instance type if needed. micro instance type is elegible for the free tier. In regions where t2.micro is unavailable, you can use a t3.micro instance under the free tier.
{{}}
In the Key Pair (login) section, select the key pair... [compressed]GUIDES / COMPUTE / DEVELOPMENT
------------------------------------------------------------

Index
Source: guides\compute\development\index.md
Rhino.Compute allows you to bring the Rhino's geometric computation capabilities to the cloud. Before deploying your application to a production environment, you should ensure that everything works perfectly in a controlled environment.

This guide is intended for developers who are familiar with Windows and have basic knowledge of Visual Studio and Git. Whether you are a seasoned Rhino user or new to Rhino.Compute, this documentation will provide you with the necessary steps to set up your development environment and start debugging effectively.

Prerequisites

Before diving into the setup of Rhino.Compute on your local machine, you need to ensure that you have the right tools. Here’s what you'll need:
Windows Operating System. Rhino.Compute only runs in Windows.
Development Environment. You will need Visual Studio 2022 to compile the code.
Version control. Git is necessary for cloning the compute.rhino3d repository and managing branches according to your Rhino version.
Rhino. Visit our downloads page to get the latest Rhino 8 or Rhino 7 builds. After downloading and installing it, please start Rhino and follow the instructions at startup to validate your license on your machine or through the Cloud Zoo.

{{}}
You will need to run the specific version of Rhino.Compute according to the Rhino version you installed. In the next section, you will clone the source code from the compute.rhino3d repository. If you have installed Rhino 8 on your machine, you will need to make sure you clone the 8.x branch. Alternatively, if you installed Rhino 7, make sure to clone the 7... [compressed]GUIDES / COMPUTE / FEATURES
------------------------------------------------------------

Index
Source: guides\compute\features\index.md
Compute can:
 Calculate Grasshopper definitions online in a serial or parallel solutions.
 Manipulate Rhino (3DM) and other file types anywhere on the net.
 Call to over 2400+ geometric operations on custom objects from within existing processes online. Including points, curves, surfaces, meshes and solids.

Compute Features
 Do geometry calculations through a cloud based stateless REST API.
 Access 2400+ RhinoCommon API calls from outside Rhino.
 Access to additional RhinoCommon functions not available in openNURBS, including:
 Closest point calculations
 Intersection calculations
 Surface tessellation (meshing)
 Interpolation
 Booleans
 Area and mass property calculations
 Other miscellaneous geometry calculations
 Extendable REST method calls through a common declaration.
 Access existing Rhino/Grasshopper plugins through the online interface.
 Serialize operations in one request through grasshopper or python scripts.
Client side libraries available for use with standalone C#(.NET), Python and JavaScript.

Open Source:
Based on Rhino Inside™ technology, compute is an open source project.

GUIDES / COMPUTE / HOPS-COMPONENT
------------------------------------------------------------

Index
Source: guides\compute\hops-component\index.md
Overview 

{{}}

Hops is a component for Grasshopper in Rhino 7 and Rhino 8 for Windows. Hops adds external functions to Grasshopper. Like other programming languages, functions let you:

 Simplify complex algorithms by using the same function multiple times.
 Eliminate duplicate component combinations by placing common combinations in a function.
 Share Grasshopper documents with other team members.
 Reference Grasshopper documents across multiple projects.
 Solve external documents in parallel, potentially speeding up large projects.
 Run asynchronously on long running calculations without blocking Rhino and Grasshopper interactions.

Hops functions are stored as separate Grasshopper documents. The Hops component will adapt its inputs and outputs to match the function specified. During calculation Hops solves the definition in a separate process, then returns the outputs to the current document.

How to use Hops 

{{}}

Installing Hops:

There are a few ways to install hops on your machine.
Install Hops (This will launch Rhino)
Or, type PackageManager on the Rhino command line.
Then, search for “Hops”
Select Hops and then Install

{{}}

Create a Hops Function

Hops functions are Grasshopper documents with special inputs and outputs.

{{}}

Defining Inputs

Hops inputs are created using the Get Components. The available Get components in Grasshopper are found under Params Tab > Util Group:

{{}}

The name of the component is used for the name of the Hops input parameter. So, in the example above, we have three Get Number components with names A, B, and C. Each of these Get components become input parameters when Hops compiles the definition.

{{}}

Each Get component has a context menu (right-click) with various settings.

{{}}

 Component Name - This is the name that will be assigned to the input of the Hops component.
 Prompt - This input will be the tooltip that is displayed when you hover over this parameter on the Hops component.
 Enable/Disable - Enable or di... [truncated]

GUIDES / COMPUTE / HOW-HOPS-WORKS
------------------------------------------------------------

Index
Source: guides\compute\how-hops-works\index.md
The communication process between Hops and a Hops compliant server is a little more nuanced than simply sending and receiving a single http request and response. The first step in the process occurs when Hops bundles up the referenced Grasshopper definition and sends a http request to an endpoint on the server. 

An endpoint is a URL address where the server can be reached to perform a certain function. In this request, the server opens the Grasshopper definition sent from Hops and determines what information will be needed to populate the inputs and outputs for the Hops component. So, the endpoint will be called /io (short for Input Output).

{{}}

The Hops component should now have enough information to create the necessary inputs and output nodes for itself. 

{{}}

When all of the Hops inputs have been connected to source parameters, it will then send another http request to the server - only this time it will it will send the request to the /solve endpoint. The Grasshopper definition does not need to be resent since it was stored on the server during the /io process. Instead, the data sent in the /solve request only contains a pointer ID which tells the server where to find the correct file and all of the input data. 

The http response from the server contains all data which would be returned from running the Grasshopper file in the traditional manner.

{{}}

To have a better understanding of how each step above works, you can export the last http request and response for both the /io and /solve endpoints directly from the Hops component.

{{}}

Quick Links
What is Hops
The Hops Component
Setting up a Production Environment

GUIDES / COMPUTE / WHAT-IS-HOPS
------------------------------------------------------------

Index
Source: guides\compute\what-is-hops\index.md
Hops lets you simplify large complex definitions. Grasshopper definitions can be big, complicated, and repetitive. This state of disorganization is sometimes called Spaghetti Code. Many factors contribute to spaghetti code including: time constraints, programmer skill level, project complexity, and limitations in the programming language. After trying to decipher a big ball of Grasshopper spaghetti, there is one universal truth - spaghetti code is hard to read and understand. Now, you can use Hops to simplify hard to read spaghetti code.

{{}}

Calling Functions in Grasshopper

In programming, a function is a "self-contained" module of code that processes inputs and returns a result. Grasshopper definitions also process inputs and returns results. However, Grasshopper wasn’t written with functions in mind. Clusters sort of work, but don’t make it easy to reuse simple definitions in complex projects.

To fix this, the Hops component was added. Hops lets you use separate grasshopper definitions as functions. The key is learning to break a problem into smaller sub-definitions which we will use as functions.

Imagine that you needed to run a shadow analysis for a parametric tower you were designing for New York City. This problem could be broken down into four smaller tasks:
Create the building lot outline
Create the building envelope
Create the floor plates
Run the shadow analysis from the building enevlope and surrounding buildings

Once the tasks have been clearly defined, you can determine what information will be needed to perform each task (i.e., the inputs) and what data will be returned at the end (i.e., the outputs). For step 1, the inputs needed to generate the building lot outline would include site setbacks and other regulatory parameters from the building and zoning codes. The output for this function would likely include a polyline outlining the maximum building area at the ground floor. 

To define the parameters which will be used in a Grasshopper functi... [truncated]

GUIDES / CPP / ADDING-A-CUSTOM-MENU
------------------------------------------------------------

Index
Source: guides\cpp\adding-a-custom-menu\index.md
Problem

Imagine you would like to add a submenu to Rhino's File menu. You might start fiddling around with the Insert­Plug­In­Menu­To­Rhino­Menu() and ­Insert­Plug­In­Item­To­Rhino­Menu() functions but not seem to be getting anywhere. Insert­Plug­In­Menu­To­Rhino­Menu() adds a menu into the Rhino's main menu bar. Insert­Plug­In­Item­To­RhinoMenu() adds a menu item anywhere in the Rhino menu. To solve this problem, you want a little of both...

Solution

To insert a menu item, or a submenu, into Rhino's menu, do the following:
Use CRhinoApp::FindMenuItem to search through Rhino's menu structure for an existing menu item that's where you want to insert your menu item.
Use CRhinoPlugIn::InsertPlugInItemToRhinoMenu to insert your menu into Rhino's menu.

Sample

The following example command demonstrates how to add and remove a custom menu from Rhino's menu:


////////////////////////////////////////////////////////////////
// cmdMyMenu.cpp

#include "StdAfx.h"
#include "MyTestPlugIn.h"
#include "Resource.h"

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// BEGIN MyMenu command
//

class CCommandMyMenu : public CRhinoCommand
{
public:
 CCommandMyMenu() {}
 ~CCommandMyMenu() {}
 UUID CommandUUID()
 {
 static const GUID MyMenuCommandUUID =
 { };
 return MyMenuCommandUUID;
 }
 const wchart EnglishCommandName() { return L"MyMenu"; }
 const wchart LocalCommandName() { return L"MyMenu"; }
 CRhinoCommand::result RunCommand( const CRhinoCommandContext& );

 BOOL LoadMyMenu();
 BOOL UnloadMyMenu();

private:
 CMenu mmenu;
};

// The one and only CCommandMyMenu object
static class CCommandMyMenu theMyMenuCommand;

CRhinoCommand::result CCommandMyMenu::RunCommand( const CRhinoCommandContext& context )
{
 bool bVisible = ( mmenu.GetSafeHmenu() ) ? true : false;

 ONwString prompt;
 prompt.Format( L"%s is %s. New value",
 EnglishCommandName(),
 bVisible ? L"visible" : L"hidden"
 );

 CRhinoG... [truncated]

Essential Code:
////////////////////////////////////////////////////////////////
// cmdMyMenu.cpp

#include "StdAfx.h"
#include "MyTestPlugIn.h"
#include "Resource.h"

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// BEGIN MyMenu command
//

class CCommandMyMenu : public CRhinoCommand
{
public:
  CCommandMyMenu() {}
  ~CCommandMyMenu() {}
  UUID CommandUUID()
  {
...

GUIDES / CPP / ADDING-COMMAND-LINE-OPTIONS
------------------------------------------------------------

Index
Source: guides\cpp\adding-command-line-options\index.md
Overview

The Rhino C/C++ SDK has a number of CRhinoGet derived classes that you can use to interactively get information from the user. Some of these classes include:
CRhinoGetObject: SDK user interface tool used to get objects.
CRhinoGetPoint: SDK user interface tool used to get points.
CRhinoGetString: SDK user interface tool used to get strings.
CRhinoGetNumber: SDK user interface tool used to get floating point values.
CRhinoGetInteger: SDK user interface tool used to get integer values.
CRhinoGetAngle: SDK user interface tool used to get angles.
CRhinoGetDistance: SDK user interface tool used to get distances.
CRhinoGetOption: SDK user interface tool used to get command line options.

Each CRhinoGet derived classes can, in addition to its primary function, prompt the user for additional options. These options display on the command following the developer specified prompt, and appear as clickable hyperlinks.

Sample

The following example code demonstrates how to add command line options to some user interaction. In this example, we use the CRhinoGetOption class, which is only capable of displaying command line options. But, we could have used any of the above CRhinoGet derived classes.


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 int nVal = 2;
 double dVal = 30.0;
 bool bVal = false;
 int listindex = 3;

 CRhinoCommandOptionValue listitems[5];
 listitems[0] = RHCMDOPTVALUE(L"Item0");
 listitems[1] = RHCMDOPTVALUE(L"Item1");
 listitems[2] = RHCMDOPTVALUE(L"Item2");
 listitems[3] = RHCMDOPTVALUE(L"Item3");
 listitems[4] = RHCMDOPTVALUE(L"Item4");

 CRhinoGetOption go;
 go.SetCommandPrompt(L"Command options");
 go.AcceptNothing();

 for (;;)
 {
 go.ClearCommandOptions();

 int nvaloptionindex = go.AddCommandOptionInteger(
 RHCMDOPTNAME(L"Integer"), &nVal, L"integer value", 1, 99
 );
 int dvaloptionindex = go.AddCommandOptionNumber(
 RHCMDOPTNAME(L"Double"), &dVal, L"double value", FALSE, 0.1, 99.9
 );
 int bvalopt... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  int nVal = 2;
  double dVal = 30.0;
  bool bVal = false;
  int list_index = 3;

  CRhinoCommandOptionValue list_items[5];
  list_items[0] = RHCMDOPTVALUE(L"Item0");
  list_items[1] = RHCMDOPTVALUE(L"Item1");
  list_items[2] = RHCMDOPTVALUE(L"Item2");
  list_items[3] = RHCMDOPTVALUE(L"Item3");
  list_items[4] = RHCMDOPTVALUE(L"Item4");

  CRhinoGetOption go;
  go.SetCommandPrompt(L"Command options");
  go.AcceptNothing();

  for (;;)
  {
...

GUIDES / CPP / ADDING-CURVE-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\adding-curve-objects\index.md
Overview

Curve objects can be added to Rhino by using the following functions found on CRhinoDoc:
CRhinoDoc::AddCurveObject
CRhinoDoc::AddObject

For CRhinoDoc::AddCurveObject, there are six overridden versions that will make curve objects from a variety of inputs, including:
ONLine: line definition objects
ONPolyline: polyline definition objects
ONArc: arc definition objects
ONCircle: circle definition objects
ONBezierCurve: bezier curve objects
ONCurve: ONCurve-derived curve objects

Examples

The following code samples will demonstrate three different ways of adding curves to Rhino. In these examples, we will create circle curves; but, there is no reason that we could create lines, polylines, arcs or any other type of curve.

Example 1

In this example, we define a circle, using ONCircle, and pass the definition off to CRhinoDoc::AddCurveObject.


ON3dPoint center(0.0, 0.0, 0.0);
double radius = 10.0;

ONCircle circle( center, radius );

CRhinoCurveObject curveobject = context.mdoc.AddCurveObject( circle );
context.mdoc.Redraw();


Example 2

In this example, we first define a circle. Then we create an ONArcCurve object from the circle definition. ONArcCurve is one of the many curve classes this is derived from ONCurve. We then pass the ONArcCurve object off to CRhinoDoc::AddCurveObject.


ON3dPoint center(0, 0, 0);
double radius = 10.0;

ONCircle circle( center, radius );

ONArcCurve arccurve( circle );

CRhinoCurveObject curveobject = context.mdoc.AddCurveObject( arccurve );
context.mdoc.Redraw();


Example 3

In this example, we will add a circle curve the brute force way. We first define a circle. Then we allocate a new ONArcCurve and pass the circle definition to its constructor. We then allocate a new CRhinoCurveObject and assign our ONArcCurve object pointer to it. Finally, we pass the pointer to the CRhinoCurveObject to CRhinoDoc::AddObject.


ON3dPoint center(0.0, 0.0, 0.0);
double radius = 10.0;

ONCircle circle( center, radius );

ONArc... [truncated]

GUIDES / CPP / ADDING-MESH-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\adding-mesh-objects\index.md
Overview

To create an ONMesh:
Create the ONMesh object. The constructor requires the number of faces and vertices, and whether or not you have vertex normals or texture coordinates.
Fill in the mesh vertex array, ONMesh::mV. You can also use ONMesh::SetVertex.
Fill in the mesh faces array, ONMesh::mF. You can also use ONMesh::SetTriangle and ONMesh::SetQuad.
If you have vertex normals, fill in the normals array, ONMesh::mN. You can also use ONMesh::SetVertexNormal.
If you have texture coordinates, fill in the texture coordinate array, ONMesh::mT. You can also use ONMesh::SetTextureCoordinate.
If you did not specify vertex normals, have Rhino compute them for you using ONMesh::ComputeVertexNormals().
Clean up everything using ONMesh::Compact.

You are now ready to add this mesh object to the document. The opennurbsmesh.h header file is well documented. It's worth reading through at least once.

Example


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Example demonstrates how to create a mesh and add it to Rhino

 // Create a mesh to write.
 // The mesh is a pyramid with 4 triangular sides and a quadranglar
 // base. The mesh has 5 vertices and 5 faces. 
 // The side faces share normals at their common vertices. The
 // quadrangular base has normals different from the side normal.
 // Coincident vertices that have distinct normals must be
 // duplicated in the vertex list.
 //
 // The apex will be at (1,1.5,4) with normal (0,0,1).
 // The base corners will be at (0,0,0), (0,2,0), (2,3,0), (0,3,0).

 bool bHasVertexNormals = true; // we will specify vertex normals
 bool bHasTexCoords = false; // we will not specify texture coordinates
 const int vertexcount = 5+4; // 4 duplicates for different base normals
 const int facecount = 5; // 4 triangle sides and a quad base
 ONMesh mesh( facecount, vertexcount, bHasVertexNormals, bHasTexCoords );

 // The SetVertex(), SetNormal(), SetTCoord() and SetFace() functions
 // retur... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Example demonstrates how to create a mesh and add it to Rhino

  // Create a mesh to write.
  // The mesh is a pyramid with 4 triangular sides and a quadranglar
  // base.  The mesh has 5 vertices and 5 faces.  
  // The side faces share normals at their common vertices.  The
  // quadrangular base has normals different from the side normal.
  // Coincident vertices that have distinct normals must be
  // duplicated in the vertex list.
  //
  // The apex will be at (1,1.5,4) with normal (0,0,1).
  // The base corners will be at (0,0,0), (0,2,0), (2,3,0), (0,3,0).

  bool bHasVertexNormals = true; // we will specify vertex normals
  bool bHasTexCoords = false;    // we will not specify texture coordinates
  const int vertex_count = 5+4;  // 4 duplicates for different base normals
  const int face_count = 5;      // 4 triangle sides and a quad base
  ON_Mesh mesh( face_count, vertex_count, bHasVertexNormals, bHasTexCoords );
...
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  int face_count = 6;
  int vertex_count = 12;
  BOOL bVertexNormals = FALSE;
  BOOL bTextureCoordinates = FALSE;

  ON_Mesh mesh( face_count, vertex_count, bVertexNormals, bTextureCoordinates );
  mesh.SetVertex(  0, ON_3fPoint(0.0f, 0.0f, 1.0f) );
  mesh.SetVertex(  1, ON_3fPoint(1.0f, 0.0f, 1.0f) );
  mesh.SetVertex(  2, ON_3fPoint(2.0f, 0.0f, 1.0f) );
  mesh.SetVertex(  3, ON_3fPoint(3.0f, 0.0f, 0.0f) );
  mesh.SetVertex(  4, ON_3fPoint(0.0f, 1.0f, 1.0f) );
  mesh.SetVertex(  5, ON_3fPoint(1.0f, 1.0f, 2.0f) );
  mesh.SetVertex(  6, ON_3fPoint(2.0f, 1.0f, 1.0f) );
  mesh.SetVertex(  7, ON_3fPoint(3.0f, 1.0f, 0.0f) );
  mesh.SetVertex(  8, ON_3fPoint(0.0f, 2.0f, 1.0f) );
  mesh.SetVertex(  9, ON_3fPoint(1.0f, 2.0f, 1.0f) );
  mesh.SetVertex( 10, ON_3fPoint(2.0f, 2.0f, 1.0f) );
  mesh.SetVertex( 11, ON_3fPoint(3.0f, 2.0f, 1.0f) );
...

GUIDES / CPP / ADDING-NURBS-CURVE-FROM-CONTROL-POINTS
------------------------------------------------------------

Index
Source: guides\cpp\adding-nurbs-curve-from-control-points\index.md
Overview

Imagine you would like to create a NURBS curve from a set of control points, such that it looks like this:

!NURBS Curve Control Points

There are two methods to achieve this...

Method 1


CRhinoCommand::result CCommandTest::RunCommand(
 const CRhinoCommandContext& context )
{
 ON3dPointArray points;
 points.Append( ON3dPoint(0, 0, 0) );
 points.Append( ON3dPoint(0, 2, 0) );
 points.Append( ON3dPoint(2, 4, 0) );
 points.Append( ON3dPoint(4, 2, 0) );
 points.Append( ON3dPoint(4, 0, 0) );

 CRhinoCommand::result res;
 ONNurbsCurve nc;
 if ( nc.CreateClampedUniformNurbs( 3, 4, points.Count(), points)
 && nc.IsValid())
 {
 context.mdoc.AddCurveObject( nc );
 res = CRhinoCommand::success;
 }
 else
 res = CRhinoCommand::failure;

 context.mdoc.Redraw();
 return res;
}


Method 2


CRhinoCommand::result CCommandTest::RunCommand(
 const CRhinoCommandContext& context )
{
 ON3dPointArray points;
 points.Append( ON3dPoint(0, 0, 0) );
 points.Append( ON3dPoint(0, 2, 0) );
 points.Append( ON3dPoint(2, 4, 0) );
 points.Append( ON3dPoint(4, 2, 0) );
 points.Append( ON3dPoint(4, 0, 0) );

 int dimension = 3;
 bool bIsRat = false;
 int order = 4;
 int cvcount = points.Count();

 ONNurbsCurve nc(dimension, bIsRat, order, cvcount);
 if( !nc.IsValid() )
 {
 return CRhinoCommand::failure;
 }

 //Set CV points
 nc.ReserveCVCapacity( cvcount );
 for( int i = 0; i < cvcount; i++ )
 {
 nc.SetCV(i, points[i] );
 }

 //Set Knots
 nc.ReserveKnotCapacity( order+cvcount-2 );
 ONMakeClampedUniformKnotVector( order, cvcount, nc.mknot );

 CRhinoCommand::result res;

 if( nc.IsValid() )
 {
 context.mdoc.AddCurveObject( nc );
 res = CRhinoCommand::success;
 }
 else
 res = CRhinoCommand::failure;

 context.mdoc.Redraw();
 return res;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(
        const CRhinoCommandContext& context )
{
  ON_3dPointArray points;
  points.Append( ON_3dPoint(0, 0, 0) );
  points.Append( ON_3dPoint(0, 2, 0) );
  points.Append( ON_3dPoint(2, 4, 0) );
  points.Append( ON_3dPoint(4, 2, 0) );
  points.Append( ON_3dPoint(4, 0, 0) );
 
  CRhinoCommand::result res;
  ON_NurbsCurve nc;
  if ( nc.CreateClampedUniformNurbs( 3, 4, points.Count(), points)
    && nc.IsValid())
  {
    context.m_doc.AddCurveObject( nc );
    res = CRhinoCommand::success;
  }
  else
    res = CRhinoCommand::failure;
...
CRhinoCommand::result CCommandTest::RunCommand(
        const CRhinoCommandContext& context )
{
  ON_3dPointArray points;
  points.Append( ON_3dPoint(0, 0, 0) );
  points.Append( ON_3dPoint(0, 2, 0) );
  points.Append( ON_3dPoint(2, 4, 0) );
  points.Append( ON_3dPoint(4, 2, 0) );
  points.Append( ON_3dPoint(4, 0, 0) );

  int dimension = 3;
  bool bIsRat = false;
  int order = 4;
  int cv_count = points.Count();

  ON_NurbsCurve nc(dimension, bIsRat, order, cv_count);
  if( !nc.IsValid() )
  {
    return CRhinoCommand::failure;
  }
...

GUIDES / CPP / ADDING-ONLINE-HELP-TO-YOUR-PLUGIN
------------------------------------------------------------

Index
Source: guides\cpp\adding-online-help-to-your-plugin\index.md
Overview

Once you have your Rhino plugin completed, you may want to add online help support to help your customers use your plugin efficiently and properly. Most Windows applications provide online help in the form of an HTML help file.

Authoring Tools

HTML help files are made with help authoring tools.

Microsoft provides a free utility called the HTML Help Workshop that can compile existing HTML files into an HTML help file (.chm). This is a fairly low-level utility in that it will only build HTML help files - it will not create or edit content. Thus, most who are looking to produce online help are looking for something a bit more full featured.

MadCap make a popular help authoring tool called MadCap Flare that will help you create, edit, and publish professional quality topic based technical content. This is the tool used to create the help files for Rhino.

There are several other tools available on the market. Google "Create HTML Help File" to see the list.

Plugin Support

You can add your plugin to Rhino's Help > Plug-ins menu by overriding the following two virtual functions:
CRhinoPlugIn::AddToPlugInHelpMenu: Called by Rhino to determine if the plugin name should be added to the Rhino Help > Plug-ins menu.
CRhinoPlugIn::OnDisplayPlugInHelp: Called by Rhino if CRhinoPlugIn::AddToPlugInHelpMenu returns true and the menu item associated with this plugin is selected.

Details on both of these virtual function can be found in rhinoSdkPlugIn.h.

Command Support

While running a Rhino command, you can press F1 to bring up online help for that command. Your plugin commands can do the same. Simply override the CRhinoCommand::DoHelp virtual function. If your command is running when the user presses F1, this member will be called.

Also, if your want your command's help to appear in Rhino's command help dockable window (Help > Command Help), then override the CRhinoCommand::ContextHelpURL virtual function.

Details on both of these virtual function can be found in... [truncated]

GUIDES / CPP / ADDING-RHINOSCRIPT-SUPPORT
------------------------------------------------------------

Index
Source: guides\cpp\adding-rhinoscript-support\index.md
Overview

With the Rhino C/C++ SDK, it is possible to write plugins that extend the RhinoScript scripting tool. In order to do this, a plugin must do the following:
Create a COM object that implements the IDispatch interface.
Override the CRhinoPlugIn::GetPlugInObjectInterface() to give plugins, such as RhinoScript, access to this object.

Step-by-Step

Let's create a new plugin named TestScript that supports RhinoScript scripting.

IDL file work or what Variants are. There is plenty of information in MSDN and on the Internet that explain these areas.

Create a plugin that supports Automation
Launch Visual Studio C/C++ and create a new Rhino Plugin project named TestScript.
On the Plug-in Settings page of the Rhino Plug-in Appwizard dialog box, make sure to check the Automation check box...

!AppWizard Automation
Once the Appwizard has completed creating the skeleton project, build the project.

Create a COM object that supports IDispatch
Create a new MFC class by running the MFC Class Wizard. 
Name the class CTestScriptObject. This class should be derived from CCmdTarget. Also, under Automation, select the Automation radio button. 

!MFC Wizard

Add methods to your object

An object is not useful unless you expose methods or properties. In this example, we will create a new method that allows the scripter to add point objects to Rhino. 

!Add methods

Within Class View, select your new object's interface and add a new method using the Add Method Wizard. Give the new method the name of AddPoint. It should have a single VARIANT argument and return a VARIANT.

!Add methods 2

Implement your methods

The Add Method Wizard will create a placeholder for our AddPoint method in TestScriptObject.cpp. Add the following code to your new method:


VARIANT CTestScriptObject::AddPoint... [truncated]

Essential Code:
VARIANT CTestScriptObject::AddPoint(VARIANT* vaPoint)
{
  VARIANT vaResult;
  VariantInit(&vaResult);
  V_VT(&vaResult) = VT_NULL;

  if( vaPoint )
  {
    ON_3dPoint pt;
    if( VariantToPoint(*vaPoint, pt) )
    {
      CRhinoDoc* doc = RhinoApp().ActiveDoc();
      if( doc )
      {
        CRhinoPointObject* obj = doc->AddPointObject( pt );
        if( obj )
        {
          doc->Redraw();
          ON_wString wstr;
          ON_UuidToString( obj->Attributes().m_uuid, wstr );
...
class CTestScriptPlugIn : public CRhinoUtilityPlugIn
{
public:
  CTestScriptPlugIn();
  ~CTestScriptPlugIn();

  // Required overrides
  const wchar_t* PlugInName() const;
  const wchar_t* PlugInVersion() const;
  GUID PlugInID() const;
  BOOL OnLoadPlugIn();
  void OnUnloadPlugIn();

  // Optional overrides
  LPUNKNOWN GetPlugInObjectInterface( const ON_UUID& iid );

private:
  ON_wString m_plugin_version;
  CTestScriptObject m_object;
};
...

GUIDES / CPP / ADDING-TO-RHINOS-FILE-SEARCH-PATH
------------------------------------------------------------

Index
Source: guides\cpp\adding-to-rhinos-file-search-path\index.md
Problem

You would like to add a file path to Rhino's file search path without having to script the Options command.

Solution

Rhino's file search path is held by Rhino's CRhinoDirectoryManager object. You can get the one and only CRhinoDirectoryManager singleton as follows:


CRhinoDirectoryManager& dm = RhinoApp().RhinoDirectoryManager();


Example

The following utility function demonstrates how to add (insert append or insert) to Rhino's file search path:


int RhAddSearchPath( const wchart* pszFolder, int index = -1 )
{
 int rc = -1;
 if( 0 == pszFolder 0 == pszFolder[0] )
 return -1;

 int rc = -1;
 if( CRhinoFileUtilities::DirExists(pszFolder) )
 {
 CRhinoDirectoryManager& dm = RhinoApp().RhinoDirectoryManager();
 const int pathcount = dm.SearchPathCount();
 for( int i = 0; i < pathcount; i++ )
 {
 if( 0 == onwcsicmp(pszFolder, dm.SearchPath(i)) )
 {
 rc = i;
 break;
 }
 }

 if( rc == -1 )
 {
 index = RHINOCLAMP( index, -1, pathcount );
 if( index == -1 )
 rc = dm.AppendSearchPath( pszFolder );
 else if( dm.InsertSearchPath(index, pszFolder) )
 rc = index;
 }
 }
 return rc;
}


Essential Code:
int RhAddSearchPath( const wchar_t* pszFolder, int index = -1 )
{
  int rc = -1;
  if( 0 == pszFolder || 0 == pszFolder[0] )
    return -1;

  int rc = -1;
  if( CRhinoFileUtilities::DirExists(pszFolder) )
  {
    CRhinoDirectoryManager& dm = RhinoApp().RhinoDirectoryManager();
    const int path_count = dm.SearchPathCount();
    for( int i = 0; i < path_count; i++ )
    {
      if( 0 == on_wcsicmp(pszFolder, dm.SearchPath(i)) )
      {
        rc = i;
        break;
      }
    }

...

GUIDES / CPP / ADDING-USER-STRINGS-TO-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\adding-user-strings-to-objects\index.md
Overview

User Data is a powerful set of APIs that allow plugin developers to attach custom data of any kind to any object derived from ONObject. In order to take advantage of User Data, you are required to implement your own user data object by deriving a class from ONUserData and overriding the required virtual functions.

In Rhino, the SDK adds a new standardized approach for adding User Data to objects called User Strings. The Rhino C/C++ SDK allows you to quickly attaches User Data in the form of a key-value string pair to any object derived from ONObject. This feature is exposed to the C/C++ SDK as member functions on ONObject:
ONObject::SetUserString: attaches a user string to an object. This information will persist through copy construction, operator=, and file IO.
ONObject::GetUserString: gets a user string from an object.
ONObject::GetUserStringKeys: retrieves a list of all user string keys on an object.
ONObject::GetUserStrings: retrieves a list of all user strings on an object.

There are a number of advantages to User Strings:
The mechanism is very simple - you do not have to derive any new classes.
Rhino is responsible for all of the file IO.
User Strings can hold text of any length and format, including XML.
Since the mechanism is standard, user strings can shared between Rhino and other plugins. For example, you can use Rhino's GetUserText and SetUserText commands to get and set user strings.

Example

The following example demonstrates how to add User Strings to a selected object...


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 bool bAttribute = true;

 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select object to attach user text" );
 go.AddCommandOptionToggle(
 RHCMDOPTNAME(L"Location"),
 RHCMDOPTVALUE(L"Object"),
 RHCMDOPTVALUE(L"Attribute"),
 bAttribute,
 &bAttribute
 );

 for(;;)
 {
 CRhinoGet::result res = go.GetObjects( 1, 1 );
 if( res == CRhinoGet::option )
 continue;
 if( res != CRhinoGet::... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  bool bAttribute = true;

  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select object to attach user text" );
  go.AddCommandOptionToggle(
        RHCMDOPTNAME(L"Location"),
        RHCMDOPTVALUE(L"Object"),
        RHCMDOPTVALUE(L"Attribute"),
        bAttribute,
        &bAttribute
        );

  for(;;)
  {
    CRhinoGet::result res = go.GetObjects( 1, 1 );
    if( res == CRhinoGet::option )
      continue;
    if( res != CRhinoGet::object )
...

GUIDES / CPP / ADJUSTING-CLIPPING-PLANES-FROM-CONDUITS
------------------------------------------------------------

Index
Source: guides\cpp\adjusting-clipping-planes-from-conduits\index.md
Overview

You may reason that it is necessary to change Rhino's Z-Buffer range because when you draw using the CRhinoDisplayConduit class, as objects that are far from Rhino's objects are being clipped. However, the Z-Buffer range has nothing to do with whether or not objects get culled, or clipped, from the viewing frustum. This behavior has to do with Rhino's near and far clipping planes. Rhino's clipping planes are adjusted dynamically in order to maximize the precision within the Z-Buffer. Additionally, Rhino does this by placing the near plane as close to the closest visible object in the frustum, and the far plane as far as the furthest visible object in the frustum.

If you are adding or drawing objects that Rhino does not know about - that are not in the drawing database - then they will not be included in those calculations. Thus, you must also implement the SCCALCBOUNDINGBOX channel inside your conduit and add to the overall scene bounding box. This will make Rhino adjust its clipping planes to include your objects. For example...

Example


class CTestDisplayConduit : public CRhinoDisplayConduit
{
public:
 CTestDisplayConduit();

 bool ExecConduit(
 CRhinoDisplayPipeline& dp,
 UINT nChannel,
 bool& bTerminate
 );

 // TODO: add other methods and members here
};

CTestDisplayConduit::CTestDisplayConduit()
: CRhinoDisplayConduit(CSupportChannels::SCPREDRAWOBJECTS CSupportChannels::SCCALCBOUNDINGBOX)
{
 // TODO: initialize members here
}

bool CTestDisplayConduit::ExecConduit(
 CRhinoDisplayPipeline& dp,
 UINT nChannel,
 bool& bTerminate
 )
{
 switch( nChannel )
 {
 case CSupportChannels::SCCALCBOUNDINGBOX:
 {
 mpChannelAttrs->mBoundingBox.Union( /YOUROBJECTSBOUNDINGBOXES/ );
 break;
 }
 case CSupportChannels::SCPREDRAWOBJECTS:
 {
 // TODO: add drawing code here
 break;
 }
 }
 return true;
}


Essential Code:
class CTestDisplayConduit : public CRhinoDisplayConduit
{
public:
  CTestDisplayConduit();

  bool ExecConduit(
    CRhinoDisplayPipeline& dp,
    UINT nChannel,
    bool& bTerminate
    );

  // TODO: add other methods and members here
};

CTestDisplayConduit::CTestDisplayConduit()
: CRhinoDisplayConduit(CSupportChannels::SC_PREDRAWOBJECTS|CSupportChannels::SC_CALCBOUNDINGBOX)
{
  // TODO: initialize members here
}

...

GUIDES / CPP / ADJUSTING-ISOCURVE-DENSITY
------------------------------------------------------------

Index
Source: guides\cpp\adjusting-isocurve-density\index.md
Problem

When creating a new surface from a selected curve, it is always a single isocurve crossing the surface. One has to adjust isocurve density after the fact from Rhino's Properties window. It is possible to do this automatically from a plugin?

Solution

The isocurve density for surface object is stored on the object's attributes. For C/C++ plugins, this would be the CRhinoObjectAttributes and ON3dmObjectAttributes classes. Just set the mwiredensity property. 

Example


CRhinoCommand::result CCommandFooBar::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetGeometryFilter( CRhinoGetObject::surfaceobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() == CRhinoCommand::success )
 {
 const CRhinoObjRef& objref = go.Object(0);
 const CRhinoBrepObject* brepobj = CRhinoBrepObject::Cast( objref.Object() );
 if( brepobj )
 {
 CRhinoObjectAttributes atts = brepobj->Attributes();
 atts.mwiredensity = 3; // for example
 context.mdoc.ModifyObjectAttributes( objref, atts );
 context.m_doc.Redraw();
 }
 }

 return go.CommandResult();
}


Essential Code:
CRhinoCommand::result CCommandFooBar::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetGeometryFilter( CRhinoGetObject::surface_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() == CRhinoCommand::success )
  {
    const CRhinoObjRef& objref = go.Object(0);
    const CRhinoBrepObject* brep_obj = CRhinoBrepObject::Cast( objref.Object() );
    if( brep_obj )
    {
      CRhinoObjectAttributes atts = brep_obj->Attributes();
      atts.m_wire_density = 3; // for example
      context.m_doc.ModifyObjectAttributes( objref, atts );
      context.m_doc.Redraw();
    }
  }

  return go.CommandResult();
}
...

GUIDES / CPP / ANNOTATION-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\annotation-objects\index.md
Overview

There are two virtual and seven concrete annotation objects. The seven concrete classes are:
Text: Created by the Rhino Text command.
Leader: Created by the Rhino Leader command.
Linear dimension: Created by the Rhino Dim, DimAligned, and DimRotated commands.
Angular dimension: Created by the Rhino DimAngle command.
Radial dimension: Created by the Rhino DimRadius and DimDiameter commands.
Ordinate dimension: Created by the Rhino DimOrdinate command.
Centermark: Created by the Rhino Centermark command.

The two virtual classes are:
Annotation : Contains text content, plane, and dimension style information. This is the base class for all annotation objects.
Dimension: Contains information common to the linear, angular, radial, ordinate, and centermark dimensions, primarily associated with the measured value (distance, angle).

The annotation geometry class hierarchy in openNURBS is:
ONAnnotation: Pure virtual class derived from ONGeometry.
ONText: Text geometry.
ONLeader: Leader geometry.
ONDimension: Pure virtual class derived from ONAnnotation.
ONDimLinear: Linear dimension geometry.
ONDimAngular: Angular dimension geometry.
ONDimRadial: Radial dimension geometry.
ONDimOrdinate: Ordinate dimension geometry.
ONCentermark: Centermark geometry.

Other openNURBS classes and useful member functions:
ONTextContent: Class that manages the RTF text and related text information and is a member of ONAnnotation.
ONAnnotation.Text(): Rreturns a pointer to the object's text content.
ONAnnotation.RichText(): Returns the "raw" rich text string.
ONAnnotation.PlainText(): Returns the "string" part formatting instructions are removed.

The Rhino annotation object class hierarchy, including their geometry class member, in the Rhino SDK is:
CRhinoAnnotation, ONAnnotation: Pure virtual class derived from CRhinoObject.
CRhinoText, ONText: Text object.
CRhinoLeader, ONLeader: Leader object.
CRhinoDimension, ONDimension: Pure virtual class derived from CRhinoAnnotation.
CRhinoDi... [truncated]

Essential Code:
CArgsRhinoGetArc args;
ON_Arc arc;
cmdrc = RhinoGetArc(args, arc, nullptr);
if (CRhinoCommand::success != cmdrc)
  return cmdrc;
double offset = arc.Radius() / 10.0;
doc.AddDimAngularObject(arc, offset);


GUIDES / CPP / APPLYING-NON-UNIFORM-TRANSFORMS-TO-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\applying-non-uniform-transforms-to-objects\index.md
Discussion

Imagine you are trying to apply a non-uniform scale to a cylinder. If the same scale operation is applied to another object type, it works as expected; but not a cylinder. Why?

Not all ONGeometry derived classes can be can be accurately modified with "squishy" transformations like projections, shears, an non-uniform scaling. For example, if you were to apply a non-uniform scale to a circle, which is represented by an ONArcCurve curve, the resulting geometry is no longer a circle.

Before transforming your object, you will want to first test to see if the the transformation is a similarity transformation. This can be done by using ONXForm::IsSimilarity(). See opennurbsxform.h 

If the transformation is not a similarity, then you should convert the geometry into a form that can be accurately modified. This can be done by using the ON_Geometry::MakeDeformable() override on the geometric object.

GUIDES / CPP / ARCHIVING-CURVES-TO-A-FILE
------------------------------------------------------------

Index
Source: guides\cpp\archiving-curves-to-a-file\index.md
Problem

Writing curves to a file has some special considerations. Curves come in many variations: the curve could be a circle, simple curve, or a polycurve. You cannot know in advance what the user will be selecting. As such, the class containing my data declares it as an ONCurve.

Writing the data is not an issue. You simply call ONCurve::Write. However, things don't go so well when you try to read the data. You need a way to simply read curve data without going to a non-abstract class. What is needed is a way to read/write curve data that represents any kind of curve possible.

Solution

It is probably best not to call ONCurve::Write for this very reason. When serializing anything derived from ONObject, just use ONBinaryArchive::WriteObject and ONBinaryArchive::ReadObject...

Write

static bool WriteCurveFile(FILE fp, const ONCurve curve)
{
 if (nullptr == fp nullptr == curve)
 return false;

 ONBinaryFile archive(ON::archivemode::write3dm, fp);

 int majorversion = 1;
 int minorversion = 0;
 bool rc = archive.BeginWrite3dmChunk(TCODEANONYMOUSCHUNK, majorversion, minorversion);
 if (!rc)
 return false;

 for (;;)
 {
 // version 1.0 fields
 rc = (archive.WriteObject(curve) ? true : false);
 if (!rc) break;

 // todo...

 break;
 }

 if (!archive.EndWrite3dmChunk())
 rc = false;

 return rc;
}


Read


static bool ReadCurveFile(FILE fp, ONCurve& curve)
{
 if (nullptr == fp)
 return false;

 ONBinaryFile archive(ON::archivemode::read3dm, fp);

 int majorversion = 0;
 int minorversion = 0;
 bool rc = archive.BeginRead3dmChunk(TCODEANONYMOUSCHUNK, &majorversion, &minorversion);
 if (!rc)
 return false;

 for (;;)
 {
 rc = (1 == majorversion);
 if (!rc) break;

 // version 1.0 fields
 ONObject object = 0;
 rc = (archive.ReadObject(&object) ? true : false);
 if (!rc) break;

 curve = ONCurve::Cast(object);

 // todo...

 break;
 }

 if (!archive.EndRead3dmChunk())
 rc = false;

 return (rc && curve);
}


Sample

To use the above functions, you could do the fo... [truncated]

Essential Code:
static bool WriteCurveFile(FILE* fp, const ON_Curve* curve)
{
  if (nullptr == fp || nullptr == curve)
    return false;

  ON_BinaryFile archive(ON::archive_mode::write3dm, fp);

  int major_version = 1;
  int minor_version = 0;
  bool rc = archive.BeginWrite3dmChunk(TCODE_ANONYMOUS_CHUNK, major_version, minor_version);
  if (!rc)
    return false;

  for (;;)
  {
    // version 1.0 fields
    rc = (archive.WriteObject(curve) ? true : false);
    if (!rc) break;

    // todo...
...
static bool ReadCurveFile(FILE* fp, ON_Curve*& curve)
{
  if (nullptr == fp)
    return false;

  ON_BinaryFile archive(ON::archive_mode::read3dm, fp);

  int major_version = 0;
  int minor_version = 0;
  bool rc = archive.BeginRead3dmChunk(TCODE_ANONYMOUS_CHUNK, &major_version, &minor_version);
  if (!rc)
    return false;

  for (;;)
  {
    rc = (1 == major_version);
    if (!rc) break;

    // version 1.0 fields
    ON_Object* object = 0;
...

GUIDES / CPP / AVOIDING-BUFFER-OVERRUNS-IN-STRING-FUNCTIONS
------------------------------------------------------------

Index
Source: guides\cpp\avoiding-buffer-overruns-in-string-functions\index.md
Overview

Buffer overruns can be caused by passing buffers to functions without also passing the buffer's size.

Consider the following function:


int GetName( wchart pInput )
{
 wchart pBuffer = (wchart)malloc(100);
 wcscpy( pBuffer, pInput ); // might overrun buffer!
 wcscat( pBuffer, L".txt"); // also might overrun buffer!

}


A Safer Method

Use the following techniques to write safer functions...

Add a sizet argument for buffer size...


// Pass pointer to buffer and buffer size
int GetName( wchart buffer, sizet buffersize );

// Ex:
wchart buffer[100];
int rc = GetName( buffer, countof(buffer) );

// Ex:
const sizet kBufLen = 100;
wchart pBuffer = new wchart[kBufLen];
GetName( pBuffer, kBufLen );

delete pBuffer;

// Ex:
const sizet kBufLen = 100;
ONwString strBuffer;
strBuffer.ReserveArray( kBufLen );
GetName( strBuffer.Array(), kBufLen );

// Ex:
const sizet kBufLen = 100;
CString strBuffer;
GetName( strBuffer.GetBuffer(kBufLen), kBufLen );
strBuffer.ReleaseBuffer();


Change buffer argument to use a string object reference...


// Pass a reference to a ONwString object
int GetName( ONwString& str );
// Pass a reference to a CString object
int GetName( CString& str );

// Ex:
ONwString str;
int rc = GetName( str );

// Ex:
CString str;
int rc = GetName( str );


...change buffer argument to a fixed size array reference...


// Pass a reference to a fixed size array
int GetName( wchart(&buffer)[100] );

// Ex:
wchart buffer[100];
int rc = GetName( buffer );


Change buffer point argument to reference to a pointer...


// Pass a reference to a pointer
// API allocates buffer, caller required to free it
int GetName( wchart& pBuffer );

// Ex:
wchart* pBuffer = 0;
int rc = GetName( pBuffer );

delete pBuffer;


GUIDES / CPP / BREP-DATA-STRUCTURE
------------------------------------------------------------

Index
Source: guides\cpp\brep-data-structure\index.md
Conceptual diagram

!BRep Data Structure

Sample


//Given a brep and a face index
const ONBrep brep;
const int faceindex = 0;
ONSimpleArray facetilist; //trims indeces list
ONSimpleArray faceeilist; //edges indeces list

//Get the BrepFace of the given index
const ONBrepFace face = brep->Face(faceindex);
if( 0 == face )
 return false;

//Get the loop of the face
for( int fli = 0; fli LoopCount(); fli++ )
{
 const ONBrepLoop loop = face->Loop( fli );
 if( 0 == loop )
 continue;

 for( int lti = 0; lti TrimCount(); lti++ )
 {
 //Find the trim
 const ONBrepTrim trim = loop->Trim( lti );
 if( 0 == trim )
 continue;
 facetilist.Append( trim->mtrimindex );

 //Find the edge of that trim
 //Each trim has exactly one edge attached to it
 const ONBrepEdge* edge = trim->Edge();
 if( 0 == edge )
 continue;
 faceeilist.Append( edge->medge_index );
 }
}


Essential Code:
//Given a brep and a face index
const ON_Brep* brep;
const int face_index = 0;
ON_SimpleArray<int> face_ti_list; //trims indeces list
ON_SimpleArray<int> face_ei_list; //edges indeces list

//Get the BrepFace of the given index
const ON_BrepFace* face = brep->Face(face_index);
if( 0 == face )
  return false;

//Get the loop of the face
for( int fli = 0; fli < face->LoopCount(); fli++ )
{
  const ON_BrepLoop* loop = face->Loop( fli );
  if( 0 == loop )
    continue;

  for( int lti = 0; lti < loop->TrimCount(); lti++ )
  {
...

GUIDES / CPP / CALCULATING-ANGLE-BETWEEN-TWO-POINTS
------------------------------------------------------------

Index
Source: guides\cpp\calculating-angle-between-two-points\index.md
Problem

For two sets of 3D vectors, you can use the method demonstrated in Calculate the Angle Between Two Vectors to calculate the angle between them. The results for both are always the same - 45 degree in this case. For example:

!Angle between vectors

But what if you need a result in which one is 45 degrees the other is 315 degrees?

Solution

The following example code demonstrates how to calculate the angle between two 3D points, given a common base point.


/
Description:
 Calculates the angle between two points that lie on a
 given plane.
Parameters:
 plane - [in] The plane on which the points lie
 basept - [in] The base point
 refpt1 - [in] The first reference point
 refpt2 - [in] The second reference point
 radians - [out] The angle in radians
Returns:
 TRUE if successful, FALSE otherwise.
/
static bool CalculatePlaneAngle(
 const ONPlane& plane,
 const ON3dPoint& basept,
 const ON3dPoint& refpt1,
 const ON3dPoint& refpt2,
 double& radians
 )
{
 // Make sure the points are on the plane
 double tolerance = 0.000001;
 double dist = 0.0;

 dist = plane.planeequation.ValueAt( basept ); 
 if( fabs(dist) > tolerance )
 return false;

 dist = plane.planeequation.ValueAt( refpt1 );
 if( fabs(dist) > tolerance )
 return false;

 dist = plane.planeequation.ValueAt( refpt2 );
 if( fabs(dist) > tolerance )
 return false;

 // Make sure base and reference points are not equal

 if( basept == refpt1 basept == refpt2 )
 return false;

 // Calculate angle between vectors

 ON3dVector v = refpt2 - basept;
 v.Unitize();

 ON3dVector zerov = refpt1 - basept;
 zerov.Unitize(); 

 double dot = ONDotProduct( zerov, v );
 dot = RHINOCLAMP( dot, -1.0, 1.0 );
 double angle = acos( dot );

 // Calculate a new y-axis based on the plane's
 // zaxis and our zero vector
 v = ONCrossProduct( plane.zaxis, zerov );
 v.Unitize();

 // Create a plane using our y-axis a the normal
 ONPlane yplane;
 yplane.CreateFromNormal( basept, v );

 // Figure out which side of this plane that ref... [truncated]

Essential Code:
/*
Description:
  Calculates the angle between two points that lie on a
  given plane.
Parameters:
  plane   - [in]  The plane on which the points lie
  basept  - [in]  The base point
  refpt1  - [in]  The first reference point
  refpt2  - [in]  The second reference point
  radians - [out] The angle in radians
Returns:
  TRUE if successful, FALSE otherwise.
*/
static bool CalculatePlaneAngle(
        const ON_Plane& plane,
        const ON_3dPoint& basept,
        const ON_3dPoint& refpt1,
        const ON_3dPoint& refpt2,
        double& radians
        )
...
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoView* view = RhinoApp().ActiveView();
  if( 0 == view )
    return failure;

  ON_Plane plane = view->ActiveViewport().ConstructionPlane().m_plane;
  ON_3dPoint basept, refpt1, refpt2;

  CRhinoGetPoint gp;
  gp.SetCommandPrompt( L"Base point" );
  gp.Constrain( plane );
  gp.GetPoint();
  if( gp.CommandResult() != success )
    return gp.CommandResult();

  basept = gp.Point();

  gp.SetCommandPrompt( L"First angle point" );
  gp.SetBasePoint( basept );
...

GUIDES / CPP / CALCULATING-LENGTHS-OF-NURBS-CURVES
------------------------------------------------------------

Index
Source: guides\cpp\calculating-lengths-of-nurbs-curves\index.md
Problem

You may run into problems determining the length of an ONNurbsCurve created by calling ONCurve::GetNurbForm. The following block of code only gets the length of the ONCurve object, not the ONNurbsCurve object.


CRhinoCommand::result CCommandFooBar::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 const ONCurve curve = go.Object(0).Curve();
 if( 0 == curve )
 return failure;

 double curvelength = 0.0;
 if( curve->GetLength(&curvelength) )
 RhinoApp().Print( L"ONCurve::GetLength() = %g\n", curvelength );

 ONNurbsCurve nurbscurve;
 if( curve->GetNurbForm(nurbscurve) )
 {
 double nurbscurvelength = 0.0;
 if( nurbscurve.GetLength(&nurbscurvelength) )
 RhinoApp().Print( L"ONNurbsCurve::GetLength() = %g\n", nurbscurvelength );
 }

 return success;
}


What is going wrong?

Solution

There is nothing wrong with the code above. Rather, this exposes a flaw in Microsoft Visual C++ and the way it deals with stack variables with modified vtables. The problem might sound complicated, but the solution is rather easy. Just make a simple function that you can pass your ONNurbsCurve object to that will calculate the curve length for you. For example, the function below should work for most developers:


BOOL ONNurbsCurveGetLength(
 const ONNurbsCurve& curve,
 double length,
 double fractionaltolerance = 1.0e-8,
 const ONInterval subdomain = NULL
 )
{
 return curve.GetLength( length, fractionaltolerance, subdomain );
}


Then, your code would look like this:


CRhinoCommand::result CCommandFooBar::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != success )
 return go.CommandResult();
... [truncated]

Essential Code:
CRhinoCommand::result CCommandFooBar::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  const ON_Curve* curve = go.Object(0).Curve();
  if( 0 == curve )
    return failure;

  double curve_length = 0.0;
  if( curve->GetLength(&curve_length) )
    RhinoApp().Print( L"ON_Curve::GetLength() = %g\n", curve_length );

  ON_NurbsCurve nurbs_curve;
  if( curve->GetNurbForm(nurbs_curve) )
  {
...
BOOL ON_NurbsCurve_GetLength(
        const ON_NurbsCurve& curve,
        double* length,
        double fractional_tolerance = 1.0e-8,
        const ON_Interval* sub_domain = NULL
        )
{
  return curve.GetLength( length, fractional_tolerance, sub_domain );
}


GUIDES / CPP / CANCELING-LONG-PROCESSES-WITH-ESC
------------------------------------------------------------

Index
Source: guides\cpp\canceling-long-processes-with-esc\index.md
Overview

When writing commands that contain long, time-consuming tasks, you might want to allow the user to cancel the process or command. Here are a couple examples of ways this can be achieved...

Example 1

The following example demonstrates how to periodically test to see if the user pressed the ESC key by "peeking" in Rhino's message queue...


// -1 = Quit Rhino
// 1 = Escape key pressed
// 0 = Okay to proceed
int EscapeKeyPressed()
{
 AFXMANAGESTATE( RhinoApp().RhinoModuleState() );

 MSG msg;
 memset( &msg, 0, sizeof(MSG) );
 while( ::PeekMessage(&msg, 0, 0, 0, PMNOREMOVE) )
 {
 if( msg.message == WMKEYDOWN && msg.wParam == VKESCAPE )
 return 1;

 if( !RhinoApp().PumpMessage() )
 return -1;
 }

 return 0;
}


Using this function is quite simple: in the middle of your loop, call the above function. If the function returns something other than 0, break out of your loop.

Example 2

The following sample class demonstrates how to hook the Windows keyboard from a Rhino plugin and check for the ESC key.


//
// rhinoEscapeKey.h
//

class CRhinoEscapeKey
{
public:
 CRhinoEscapeKey( bool bHookNow = false );
 ~CRhinoEscapeKey();
 bool Start();
 void Stop();
 bool EscapeKeyPressed() const;
 void ClearEscapeKeyPressedFlag();
protected:
 static LRESULT CALLBACK HookProc( int code, WPARAM wParam, LPARAM lParam );
 static HHOOK mKeyboardHookProc;
 static bool mescapepressed;
};

//
// rhinoEscapeKey.cpp
//

bool CRhinoEscapeKey::mescapepressed = false;
HHOOK CRhinoEscapeKey::mKeyboardHookProc = NULL;

CRhinoEscapeKey::CRhinoEscapeKey( bool bStartNow )
{
 if( bStartNow )
 Start();
}

CRhinoEscapeKey::~CRhinoEscapeKey()
{
 Stop();
}

bool CRhinoEscapeKey::Start()
{
 if( NULL == mKeyboardHookProc )
 mKeyboardHookProc = ::SetWindowsHookEx(
 WHKEYBOARD,
 CRhinoEscapeKey::HookProc,
 RhinoApp().RhinoInstanceHandle(),
 ::AfxGetThread()->mnThreadID
 );
 ClearEscapeKeyPressedFlag();
 return( NULL != mKeyboardHookProc );
}

void CRhinoEscapeKey::Stop()
{
 if( mKeyboardHoo... [truncated]

Essential Code:
//  -1 = Quit Rhino
//   1 = Escape key pressed
//   0 = Okay to proceed
int EscapeKeyPressed()
{
  AFX_MANAGE_STATE( RhinoApp().RhinoModuleState() );

  MSG msg;
  memset( &msg, 0, sizeof(MSG) );
  while( ::PeekMessage(&msg, 0, 0, 0, PM_NOREMOVE) )
  {
    if( msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE )
      return 1;

    if( !RhinoApp().PumpMessage() )
      return -1;
  }

  return 0;
}
...
//
// rhinoEscapeKey.h
//

class CRhinoEscapeKey
{
public:
  CRhinoEscapeKey( bool bHookNow = false );
  ~CRhinoEscapeKey();
  bool Start();
  void Stop();
  bool EscapeKeyPressed() const;
  void ClearEscapeKeyPressedFlag();
protected:
  static LRESULT CALLBACK HookProc( int code, WPARAM wParam, LPARAM lParam );
  static HHOOK m_KeyboardHookProc;
  static bool m_escape_pressed;
};

//
...

GUIDES / CPP / CHANGING-DISPLAY-PRECISION
------------------------------------------------------------

Index
Source: guides\cpp\changing-display-precision\index.md
Problem

Rhino has a document display precision - the "display precision" option found in the Units page in the Options dialog. Imagine you want to modify this using C/C++ from your plugin.

Solution

A document's display precision, the number of decimal places used for the distance display, is maintained on an ON3dmUnitsAndTolerances object, which in turn is stored on a CRhinoDocProperties object which is a member of the current CRhinoDoc object. To modify this variable, you will need to:
Make a copy of the document's ON3dmUnitsAndTolerances object.
Modify the object's mdistancedisplayprecision member variable.
Replace the current ON3dmUnitsAndTolerances with the newly modified one.

Sample

The following sample code demonstrates how to change the unit's display precision of the current document using the Rhino C/C++ SDK...


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Make a copy of the current model units and tolerances
 ON3dmUnitsAndTolerances units = context.mdoc.Properties().ModelUnitsAndTolerances();

 // Prompt the user to enter a new display precision value
 CRhinoGetInteger gi;
 gi.SetCommandPrompt( L"New display precision" );
 gi.SetDefaultInteger( units.mdistancedisplayprecision );
 gi.SetLowerLimit( 0 );
 gi.SetUpperLimit( 6 );
 gi.GetInteger();
 if( gi.CommandResult() == CRhinoCommand::success )
 {
 // The the user's input
 int distancedisplayprecision = gi.Number();
 if( distancedisplayprecision != units.mdistancedisplayprecision )
 {
 units.mdistancedisplayprecision = distancedisplayprecision;
 // Replace the current setting with our updated value
 context.mdoc.Properties().SetModelUnitsAndTolerances( units, false );
 }
 }

 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Make a copy of the current model units and tolerances
  ON_3dmUnitsAndTolerances units = context.m_doc.Properties().ModelUnitsAndTolerances();

  // Prompt the user to enter a new display precision value
  CRhinoGetInteger gi;
  gi.SetCommandPrompt( L"New display precision" );
  gi.SetDefaultInteger( units.m_distance_display_precision );
  gi.SetLowerLimit( 0 );
  gi.SetUpperLimit( 6 );
  gi.GetInteger();
  if( gi.CommandResult() == CRhinoCommand::success )
  {
    // The the user's input
    int distance_display_precision = gi.Number();
    if( distance_display_precision != units.m_distance_display_precision )
    {
      units.m_distance_display_precision = distance_display_precision;
      // Replace the current setting with our updated value
...

GUIDES / CPP / CLEAR-UNDO-REDO-LISTS
------------------------------------------------------------

Index
Source: guides\cpp\clear-undo-redo-lists\index.md
How To

Rhino allows users to undo the most recent or several create, edit, or transform commands. If you are performing editing operations on large memory consuming objects, Rhino's undo list can quickly grow very large. When this happens, most Rhino users run the ClearUndo command to clear the undo list. It is also possible to clear the undo list from within a plugin.

The following sample code demonstrates how to clear Rhino's undo and redo lists...


CRhinoCommand::result CCommandTest::RunCommand(
 const CRhinoCommandContext& context
 )
{
 RhinoApp().Print( L"Clearing undo and redo lists.\n" );
 context.m_doc.ClearUndoRecords( true );
 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(
        const CRhinoCommandContext& context
        )
{
  RhinoApp().Print( L"Clearing undo and redo lists.\n" );
  context.m_doc.ClearUndoRecords( true );
  return CRhinoCommand::success;
}


GUIDES / CPP / CRASH-DUMP-ANALYSIS
------------------------------------------------------------

Index
Source: guides\cpp\crash-dump-analysis\index.md
Overview

If Rhino crashes, two files are created on the user's desktop: RhinoCrashDump.dmp and RhinoCrashDump.3dm. The .3dm file is Rhino's last ditch effort to save the model. The .dmp file can be used in Visual Studio to find the place in the source code where a Rhino plugin crashed.

Configuration
Before you can analyze crashes, you'll need to set up Visual Studio to help you get symbols.
Enable Symbol Servers
Open Visual Studio
From the Tools menu, click Options
Select Debugging > General and enable the following options:
 Enable source server support
 Print source server diagnostic messages to the Output window
 Allow source server for partial trust assemblies (Managed only)
 Always run untrusted source server commands without prompting
Select Debugging > Symbols
In the Symbol file (.pdb) locations box, add:
 http://s3.symbols.rhino3d.com/symbols/dujour
 https://msdl.microsoft.com/download/symbols
Optionally add these symbol servers if you need symbols for video driver related crashes:
 https://driver-symbols.nvidia.com
 https://download.amd.com/dir/bin_2018
 https://download.amd.com/dir/bin
 https://software.intel.com/sites/downloads/symbols
In the Cache symbols in this directory folder, enter a folder where Visual Studio will cache symbols. Depending on the number of crashes you debug, this folder can get quite large.
Under Symbol search preferences: select Search for all modules unless excluded
 (Note that this will make debugging your project slow. To speed this up, select Automatically choose what module symbols to search for)

Debugging Crashes
Start Visual Studio
From the File menu, click Open
Browse to the RhinoCrashDump.dmp file in the extracted folder
Click Debug with Mixed

Try it!

Below is a sample C++ plugin that will crash Rhino. To test out crash dump analysis:
Download and build the TestSdkCrash plugin.
Launch Rhino and load the plugin using the PlugInManager command.
Run the TestSdkCrash command. 
While the McNeel Error Reporting dialog is di... [truncated]

GUIDES / CPP / CREATE-DEPENDENT-DLL
------------------------------------------------------------

More information
Source: guides\cpp\create-dependent-dll\index.md
Overview

A Rhino-dependent C++ DLL is one that links with Rhino C++ SDK libraries, and that can be used to add functionality that can be shared between multiple C++ plug-ins, or that can be used to add Platform Invoke (PInvoke), interop functionality to RhinoCommon or Grasshopper plug-ins.

Create the DLL

To create a Rhino-dependent C++ DLL:
Download and install the Rhino C++ SDK.
Launch Visual Studio.
Create a new Rhino C/C++ plug-in project.
Using Solution Explorer, delete the PlugIn .cpp and .h files, and delete the Command .cpp file.
Using Property Manager, remove the Rhino.Cpp.PlugIn property page from both the Debug x64 and the Release x64 build configurations.
Again using Property Manager, add the Rhino.Cpp.PlugInComponent.props property page to both the Debug x64 and the Release x64 build configurations. The property page file is found in the PropertySheets folder in the Rhino C++ SDK installation folder.
Build the project.

Done! You now have a Rhino-dependent DLL project. Now you are ready to add your functionality; either by adding or linking in other libraries, or by exporting custom C++ functions.

More information

Wrapping Native Libraries

GUIDES / CPP / CREATING-A-SKIN
------------------------------------------------------------

Index
Source: guides\cpp\creating-a-skin\index.md
Overview

Rhino allows developers to customize most of Rhino's interface so that the application appears to be their own. We call this a custom Skin. With a custom Skin, you can change the application icon, splash screen, the application name etc.

Creating a custom Skin for Rhino involves creating a custom skin assembly:
skin name.rhs This is a regular MFC DLL (.dll) that implements the skin's icon, splash screen, application name, etc. In this guide, we will refer this to the "Skin DLL."
skin name.rhp is a Rhino utility plugin that implements the menu handler, if necessary, and one or more custom commands. In this article, we refer to this as the "Skin Plugin."

Create the Skin DLL

To create the Skin DLL:
Launch Visual Studio and run the Rhino Skin DLL wizard installed by the Rhino C/C++ SDK.
The Rhino Skin DLL wizard creates three classes:
A CWinApp-derived class. This is the entry point of the DLL.
A CRhinoSkinDLL-derived class. This class lets you specify Rhino's icon, splash screen, and menu. h.
CSplashWnd. This is a basic implementation of a splash screen class. If you need something fancier, feel free to replace it with your own implementation.
Modify the project's icon and splash screen bitmap. If your Skin is going to override Rhino's main menu, then you need to create your menu resources as well.
Remember to fill out the developer information block found at the top of your DLL's .cpp file. This block is similar to that of Rhino plugins.

Create the Skin Plugin

To create a Skin Plugin:
Launch Visual Studio and run the Rhino Plugin wizard installed by the Rhino C/C++ SDK. When picking the wizard to run, make sure to add the new project to the open solution instead of creating a new solution. This way, your Skin project is organized into a single solution.
If the Skin DLL provides a custom menu, then copy the UUID generated by the plugin AppWizard and found in your plugin's CRhinoPlugIn::PlugInID() me... [truncated]

Essential Code:
// Skin DLL menu update handler
void OnInitPlugInMenuPopups(WPARAM wparam, LPARAM lparam);
// Skin DLL menu command handler
BOOL OnPlugInMenuCommand(WPARAM wparam );
// Change to CRhinoPlugIn::load_plugin_at_startup
plugin_load_time PlugInLoadTime();

CRhinoPlugIn::plugin_load_time CSkinPlugInSamplePlugIn::PlugInLoadTime()
{
  // Override to change load time to "at startup"
  return CRhinoPlugIn::load_plugin_at_startup;
}


GUIDES / CPP / CREATING-BLOCKS
------------------------------------------------------------

Index
Source: guides\cpp\creating-blocks\index.md
Overview

Rhino blocks, known in the SDK as instances, are single objects that combine one or more objects. Using blocks lets you:
Create parts libraries.
Update all instances by modifying the block definition.
Keep a smaller model size by using block instances instead of copying identical geometry.
Use the BlockManager command to view information about the blocks defined in the model.
Use the Insert command to place block instances into your model, which scales and rotates the instance.

How To

Creating instance definitions using C/C++ requires two steps:
Define the instance definition objects. Instance definition objects are similar to regular Rhino objects - the ones that you see on the screen. The difference is that instance definition objects reside in a different location in the document. To add instance definition objects to the document, use CRhinoDoc::AddObject and make sure you set the bInstanceDefinition parameter to true.
Add a new instance definition object to Rhino's instance definition table, which is located on the Rhino document. An instance definition defines the name of the instance and the instance definition objects used by it.

 Knowing this, you need to orient your instance definition geometry around the world origin. The Block command does this by prompting the user for a base point and then transforming the selected objects from the user's picked point to the world origin. If you are adding your own geometry on the fly, and not picking it, just create your objects knowing that the base point for your instance definition will be the world origin.

Sample

The following example code demonstrates how to select one or more objects and create a block definition with them.



CRhinoCommand:... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Select objects to define block
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select objects to define block" );
  go.EnableReferenceObjectSelect( false );
  go.EnableSubObjectSelect( false );
  go.EnableGroupSelect( true );

  // Phantoms, grips, lights, etc., cannot be in blocks.
  const unsigned int forbidden_geometry_filter
                = CRhinoGetObject::light_object
                | CRhinoGetObject::grip_object
                | CRhinoGetObject::phantom_object;
  const unsigned int geometry_filter = forbidden_geometry_filter
                               ^ CRhinoGetObject::any_object;
  go.SetGeometryFilter( geometry_filter );
  go.GetObjects( 1, 0 );
  if( go.CommandResult() != success )
    return go.CommandResult();
...

GUIDES / CPP / CREATING-CUSTOM-COLOR-PICKER
------------------------------------------------------------

Index
Source: guides\cpp\creating-custom-color-picker\index.md
How To

To replace Rhino's color picking dialog, derive a new class from CRhinoReplaceColorDialog and override the ColorDialog() virtual function. Note, if more that one CRhinoReplaceColorDialog-derived classes exist, then the last CRhinoReplaceColorDialog-derived object created will be displayed.

The following sample code demonstrates how to replace Rhino's color picking dialog. In this example, we will simply replace it with the Windows standard color picking dialog...


class CMyColorDialog : public CRhinoReplaceColorDialog
{
public:
 CMyColorDialog() : CRhinoReplaceColorDialog(::AfxGetStaticModuleState()) {};
 virtual ~CMyColorDialog() {};
 bool CMyColorDialog::ColorDialog( HWND hWndParent,
 ONColor& color,
 bool bIncludeButtonColors,
 const wchart lpsDialogTitle )
 {
 CColorDialog dlg( color, CCANYCOLOR CCFULLOPEN, CWnd::FromHandle(hWndParent) );
 if( IDOK != dlg.DoModal() )
 return false;
 color = dlg.GetColor();
 return true;
 }
};


Now, create a new Rhino command and add a pointer to the above class as a public data member. Do not forget to initialize it's value to NULL in the command classes constructor. For example:


CMyColorDialog mpMyColorDialog;
// ...
CTestCommand::CTestCommand() : pMyColorDialog(NULL) {}


Finally, in your new command classes RunCommand() member, install the new color picker. For example:


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 if( mpMyColorDialog )
 {
 delete mpMyColorDialog;
 mpMyColorDialog = NULL;
 RhinoApp().Print( L"Rhino color dialog restored.\n" );
 }
 else
 {
 mpMyColorDialog = new CMyColorDialog;
 if( mpMyColorDialog )
 RhinoApp().Print( L"Rhino color dialog replaced.\n" );
 else
 RhinoApp().Print( L"Error replacing Rhino color dialog.\n" );
 }
 return CRhinoCommand::success;
}


h.

Essential Code:
class CMyColorDialog : public CRhinoReplaceColorDialog
{
public:
  CMyColorDialog() : CRhinoReplaceColorDialog(::AfxGetStaticModuleState()) {};
  virtual ~CMyColorDialog() {};
  bool CMyColorDialog::ColorDialog( HWND hWndParent,
                                    ON_Color& color,
                                    bool bIncludeButtonColors,
                                    const wchar_t* lpsDialogTitle )
  {
    CColorDialog dlg( color, CC_ANYCOLOR|CC_FULLOPEN, CWnd::FromHandle(hWndParent) );
    if( IDOK != dlg.DoModal() )
      return false;
    color = dlg.GetColor();
    return true;
  }
};

CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  if( m_pMyColorDialog )
  {
    delete m_pMyColorDialog;
    m_pMyColorDialog = NULL;
    RhinoApp().Print( L"Rhino color dialog restored.\n" );
  }
  else
  {
    m_pMyColorDialog = new CMyColorDialog;
    if( m_pMyColorDialog )
      RhinoApp().Print( L"Rhino color dialog replaced.\n" );
    else
      RhinoApp().Print( L"Error replacing Rhino color dialog.\n" );
  }
  return CRhinoCommand::success;
}


GUIDES / CPP / CREATING-CUSTOM-CRHINOGETOBJECT-CLASS
------------------------------------------------------------

Index
Source: guides\cpp\creating-custom-crhinogetobject-class\index.md
Overview

The CRhinoGetObject class that is used for interactively picking one or more objects is a large, full-featured class (see rhinoSdkGetObject.h for details). But, on occasion, the class does not offer enough options. For example, CRhinoGetObject is capable of picking curve objects. But, it is not capable of picking polyline curve objects that are closed. When the required object filtering exceeds the capabilities of the base class, it's time to derive your own.

CRhinoGetObject has a virtual function named CustomGeometryFilter() that is called after all obvious geometry filter checks have been performed. Thus, if you derive a new class from CRhinoGetObject and override this virtual member, you can filter for most any geometric object or property.

Sample

The following example code demonstrates deriving from CRhinoGetObject. In this example, we want to allow the user to only select closed polylines...


class CRhGetClosedPolylineObject : public CRhinoGetObject
{
public:
 bool CustomGeometryFilter(
 const CRhinoObject obj,
 const ONGeometry geom,
 RHINOCOMPONENTINDEX idx
 ) const;
};

bool CRhGetClosedPolylineObject::CustomGeometryFilter(
 const CRhinoObject obj,
 const ONGeometry geom,
 RHINOCOMPONENTINDEX idx
 ) const
{
 if( geom )
 {
 // is it a polyline?
 if( const ONPolylineCurve p = ONPolylineCurve::Cast(geom) )
 {
 if( p->IsClosed() && p->IsPolyline() > 3 )
 return true;
 }
 // is is a polycurve that looks like a polyline?
 if( const ONPolyCurve p = ONPolyCurve::Cast(geom) )
 {
 if( p->IsClosed() && p->IsPolyline() > 3 )
 return true;
 }
 // is it a [[rhino:nurbs NURBs]] curve that looks like a polyline?
 if( const ONCurve* p = ONCurve::Cast(geom) )
 {
 ONNurbsCurve n;
 if( p->GetNurbForm(n) )
 {
 if( n.IsClosed() && n.IsPolyline() > 3 )
 return true;
 }
 }
 }
 return false;
}


We can use the above class as follows:


CRhGetClosedPolylineObject go;
go.SetCommandPrompt( L"Select closed polyline" );
go.SetGeometryFilter( CRhinoGetObject::curve... [truncated]

Essential Code:
class CRhGetClosedPolylineObject : public CRhinoGetObject
{
public:
  bool CustomGeometryFilter(
        const CRhinoObject* obj,
        const ON_Geometry* geom,
        RHINO_COMPONENT_INDEX idx
        ) const;
};

bool CRhGetClosedPolylineObject::CustomGeometryFilter(
        const CRhinoObject* obj,
        const ON_Geometry* geom,
        RHINO_COMPONENT_INDEX idx
        ) const
{
  if( geom )
  {
    // is it a polyline?
    if( const ON_PolylineCurve* p = ON_PolylineCurve::Cast(geom) )
...

GUIDES / CPP / CREATING-LEADERS
------------------------------------------------------------

Index
Source: guides\cpp\creating-leaders\index.md
How To

Leaders in Rhino are defined by the ONLeader2 class. To construct a leader, you must provide:
A plane, or an ONPlane object, which defines the plane in which the leader will be located.
Two or more 2D points that line in the plane that you specified above.

In the following sample code, we will construct a simple leader object. The leader will reside in the world x-y plane and will have four points...


CRhinoCommand::result CCommandLeader::RunCommand( const CRhinoCommandContext& context )
{
 // Some set of points that define the leader
 ON3dPointArray points;
 points.Append( ON3dPoint(1.0, 1.0, 0.0) );
 points.Append( ON3dPoint(5.0, 1.0, 0.0) );
 points.Append( ON3dPoint(5.0, 5.0, 0.0) );
 points.Append( ON3dPoint(9.0, 5.0, 0.0) );

 // The plane in which the leader resides
 ONPlane plane = ONxyplane;

 // Create the leader
 ONLeader2 leader;
 leader.SetPlane( plane );

 // Add the points to the leader
 int i;
 for( i = 0; i ONSQRTEPSILON )
 leader.mpoints.Append( p2 );
 }
 }

 // Create the leader object
 CRhinoAnnotationLeader* leaderobject = new CRhinoAnnotationLeader();
 // Add our leader to the object
 leaderobject->SetAnnotation( leader );

 if( context.mdoc.AddObject(leaderobject) )
 context.mdoc.Redraw();
 else
 delete leaderobject; // error

 return success;
}


Essential Code:
CRhinoCommand::result CCommandLeader::RunCommand( const CRhinoCommandContext& context )
{
  // Some set of points that define the leader
  ON_3dPointArray points;
  points.Append( ON_3dPoint(1.0, 1.0, 0.0) );
  points.Append( ON_3dPoint(5.0, 1.0, 0.0) );
  points.Append( ON_3dPoint(5.0, 5.0, 0.0) );
  points.Append( ON_3dPoint(9.0, 5.0, 0.0) );

  // The plane in which the leader resides
  ON_Plane plane = ON_xy_plane;

  // Create the leader
  ON_Leader2 leader;
  leader.SetPlane( plane );

  // Add the points to the leader
  int i;
  for( i = 0; i < points.Count(); i++ )
  {
...

GUIDES / CPP / CREATING-POINTS-FROM-TEXT-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\creating-points-from-text-objects\index.md
Problem

Imagine you have many text elements that display numeric values that identify elevation and you would like to convert these elements to points objects using the C/C++. The text elements denote the elevations of the locations and you would like create the 2D point by the location of the text and then use the number of the text as the z-coordinate.

Solution

To make picking text entities easier for the user, we will use a custom object picker that just filters CRhinoAnnotationText objects...


class CRhGetTextObject : public CRhinoGetObject
{
public:
 bool CustomGeometryFilter(
 const CRhinoObject object,
 const ONGeometry geometry,
 ONCOMPONENTINDEX componentindex
 ) const
 {
 if( object && CRhinoAnnotationText::Cast(object) )
 return true;
 return false;
 }
};


Here is the portion of the command that creates points from the text entities...


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhGetTextObject go;
 go.SetCommandPrompt( L"Select text" );
 go.GetObjects( 1, 0 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 int i;
 for( i = 0; i String() );
 textstr.TrimLeftAndRight();

 double z = 0.0;
 if( RhinoParseNumber(textstr, &z) )
 {
 ON3dPoint textpt = textobj->mtextblock.Plane().Origin();
 textpt.z = z;
 context.mdoc.AddPointObject( textpt );
 }
 }

 context.m_doc.Redraw();

 return success;
}


Essential Code:
class CRhGetTextObject : public CRhinoGetObject
{
public:
  bool CustomGeometryFilter(
        const CRhinoObject* object,
        const ON_Geometry* geometry,
        ON_COMPONENT_INDEX component_index
        ) const
  {
    if( object && CRhinoAnnotationText::Cast(object) )
      return true;
    return false;
  }
};

CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhGetTextObject go;
  go.SetCommandPrompt( L"Select text" );
  go.GetObjects( 1, 0 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  int i;
  for( i = 0; i < go.ObjectCount(); i++ )
  {
    const CRhinoAnnotationText* text_obj = CRhinoAnnotationText::Cast( go.Object(i).Object() );
    if( 0 == text_obj )
      continue;

    ON_wString text_str( text_obj->String() );
    text_str.TrimLeftAndRight();

    double z = 0.0;
    if( RhinoParseNumber(text_str, &z) )
...

GUIDES / CPP / CREATING-PRINCIPAL-CURVATURE-CURVES
------------------------------------------------------------

Index
Source: guides\cpp\creating-principal-curvature-curves\index.md
Problem

You are looking for a way to create Principal Curvature lines starting with points on a surface. There is an ONEvPrincipalCurvatures function, it's not clear how it should be used.

Solution

Before using ONEvPrincipalCurvatures, you will need to calculate the second derivative of the surface that the test location. Then, it is just a matter of creating up some curves based on the results.

Sample

The following is an example of how you might write such a command.


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 CRhinoGetObject go;
 go.SetCommandPrompt(L"Select surface");
 go.SetGeometryFilter(CRhinoGetObject::surfaceobject);
 go.GetObjects(1, 1);
 if (go.CommandResult() != CRhinoCommand::success)
 return go.CommandResult();

 const CRhinoObject obj = go.Object(0).Object();
 const ONBrepFace face = go.Object(0).Face();
 if (nullptr == obj nullptr == face)
 return CRhinoCommand::failure;

 CRhinoGetPoint gp;
 gp.SetCommandPrompt(L"Select point on surface");
 gp.Constrain(face, obj->Attributes().mwiredensity);
 gp.GetPoint();
 if (gp.CommandResult() != CRhinoCommand::success)
 return gp.CommandResult();

 double s = 0.0, t = 0.0;
 const ONSurface srf = gp.PointOnSurface(&s, &t);
 if (nullptr == srf)
 return CRhinoCommand::failure;

 ON3dPoint P;
 ON3dVector Ds, Dt, Dss, Dst, Dtt;
 if (!srf->Ev2Der(s, t, P, Ds, Dt, Dss, Dst, Dtt))
 return CRhinoCommand::failure; // failed to evaluate derivatives

 ON3dVector N;
 if (!srf->EvNormal(s, t, N))
 return CRhinoCommand::failure; // failed to evaluate normal

 double gauss = 0.0, mean = 0.0, k[2] = { 0.0, 0.0 };
 ON3dVector K[2];
 if (!ONEvPrincipalCurvatures(Ds, Dt, Dss, Dst, Dtt, N, &gauss, &mean, &k[0], &k[1], K[0], K[1]))
 return CRhinoCommand::failure; // failed to evaluate principal curvatures

 for (int i = 0; i = 1.0e4)
 {
 // just draw a line as curvature is huge/tiny
 ONLine line(P - K[i] 5.0, P + K[i] 5.0);
 context.mdoc.AddCurveObject(line);
 }
 else
 {
 double ... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetObject go;
  go.SetCommandPrompt(L"Select surface");
  go.SetGeometryFilter(CRhinoGetObject::surface_object);
  go.GetObjects(1, 1);
  if (go.CommandResult() != CRhinoCommand::success)
    return go.CommandResult();

  const CRhinoObject* obj = go.Object(0).Object();
  const ON_BrepFace* face = go.Object(0).Face();
  if (nullptr == obj || nullptr == face)
    return CRhinoCommand::failure;

  CRhinoGetPoint gp;
  gp.SetCommandPrompt(L"Select point on surface");
  gp.Constrain(*face, obj->Attributes().m_wire_density);
  gp.GetPoint();
  if (gp.CommandResult() != CRhinoCommand::success)
    return gp.CommandResult();
...

GUIDES / CPP / CREATING-SUBLAYERS
------------------------------------------------------------

Index
Source: guides\cpp\creating-sublayers\index.md
Problem

You would like to create a "sublayer" (or a "child layer") of a parent layer.

Solution

All layers have a layer id field, returned by ONLayer::Id(), that uniquely identifies that layer. Layers also maintain a parent id field, returned by ONLayer::ParentLayerId(), that identifies the layer's parent. If a layer's parent id is a null UUID, then the layer does not have a parent and, thus, is considered a root layer.

Sample

The following sample demonstrates how to add a parent layer then then add a child layer to that parent.


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 CRhinoLayerTable& layertable = context.mdoc.mlayertable;

 // Define parent layer
 ONLayer parentlayer;
 parentlayer.SetName(L"Parent");

 // Add parent layer
 int parentlayerindex = layertable.AddLayer(parentlayer);
 if (parentlayerindex >= 0) 
 {
 // Get the layer we just added
 const CRhinoLayer& layer = layertable[parentlayerindex];

 // Define child layer
 ONLayer childlayer;
 childlayer.SetName(L"Child");

 // Assign parent layer's id as child's parent id
 childlayer.SetParentLayerId(layer.Id());

 // Add child layer
 layertable.AddLayer(childlayer);
 }

 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoLayerTable& layer_table = context.m_doc.m_layer_table;

  // Define parent layer
  ON_Layer parent_layer;
  parent_layer.SetName(L"Parent");

  // Add parent layer
  int parent_layer_index = layer_table.AddLayer(parent_layer);
  if (parent_layer_index >= 0) 
  {
    // Get the layer we just added
    const CRhinoLayer& layer = layer_table[parent_layer_index];

    // Define child layer
    ON_Layer child_layer;
    child_layer.SetName(L"Child");

    // Assign parent layer's id as child's parent id
...

GUIDES / CPP / CREATING-ZOO-PLUGINS
------------------------------------------------------------

Index
Source: guides\cpp\creating-zoo-plugins\index.md
Overview

The LAN Zoo supports 3rd party plugins. The Rhino C/C++ SDK allows developers to write plugins for Rhino that use the Rhino license manager and obtain licenses from LAN Zoo servers.

When a customer attempts to add a product license to the LAN Zoo, the product's plugin is called to validate the user's request. Upon validation, the plugin will return the product's licensing information back to the LAN Zoo. In turn, the LAN Zoo will serialize, maintain, and distribute this license.

Prerequisites

It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows).

Also, all plugins that use the LAN Zoo license system must be signed with an Authenticode certificate issued by McNeel Plugin Security. These certificates are free, but must be requested by each developer. Developers must agree to the Terms of Use before a certificate is issued. 

It is also presumed you have a C/C++ plugin you wish to add license support to. See the Your First Plugin (Windows) guide for instructions.

Adding Licensing Support

After you have built and tested your basic plugin, you can add licensing support as follows:

Step-by-Step
Add a new .cpp file to your project.
In this .cpp file, declare a new class that is derived from CRhinoLicenseValidator.
Override the CRhinoLicenseValidator::ProductBuildType virtual function and return the build type of the license that your product requires.
Override and implement the CRhinoLicenseValidator::VerifyLicenseKey virtual function. Rhino will call into this function whenever it needs your plugin to validate a license that is entered by a user, returned by the Rhino license manager (standalone node), or returned from a LAN Zoo server (network node).
Override and implement the CRhinoLicenseValidator::VerifyPreviousVersionLicense virtual function. Rhino will call into this function if a lic... [truncated]

GUIDES / CPP / CUSTOM-PICKING-GRIP-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\custom-picking-grip-objects\index.md
Problem

Imagine you are trying to wrote code to pick grip objects, and you want that only grips at the boundary of a mesh to be selectable. You might have just spent a considerable amount of time trying to get the following to work:
Derive a class from CRhinoGetObject.
Override CRhinoGetObject::CustomGeometryFilter.

What is missing is a pointer to a grip object inside CRhinoGetObject::CustomGeometryFilter. One might think this code would work...


CMyGetObject go;
go.SetGeometryFilter( CRhinoGetObject::gripobject );


but now CRhinoGetObject::CustomGeometryFilter override is not even called anymore. On the other hand, if you do not specify a CRhinoGetObject::SetGeometryFilter up front, the function is called but you don't get any grip object from the geometry parameter of CRhinoGetObject::CustomGeometryFilter.

Is there a way around this problem?

Solution

Yes. In order to pick grip objects, using CRhinoGetObject, you must set the CRhinoGetObject::gripobject geometry filter. If not, then Rhino will ignore grips in an effort to improve picking performance.

Also, if you want your CRhinoGetObject::CustomGeometryFilter override to be called, make sure to call CRhinoGetObject::EnableSubObjectSelect to disable subobject picking. For example:


CMyGetObject go;
go.SetGeometryFilter( CRhinoObject::gripobject );
go.EnableSubObjectSelect( false );
go.GetObjects( 1, 0 );
if( go.CommandResult() == CRhinoCommand::success )
{
 // TODO...
}


Regarding the picking of grips at the boundary of a mesh, here is a sample class that you can use...


class CRhGetMeshBoundaryGrip : public CRhinoGetObject
{
public:
 bool CustomGeometryFilter(
 const CRhinoObject obj,
 const ONGeometry geo,
 ONCOMPONENTINDEX ci
 ) const;
};

bool CRhGetMeshBoundaryGrip::CustomGeometryFilter(
 const CRhinoObject obj,
 const ONGeometry geo,
 ONCOMPONENTINDEX ci
 ) const
{
 if( 0 == obj )
 return false;

 // Is grip object?
 const CRhinoGripObject gripobj = CRhinoGripObject::Cast( obj );
 if... [truncated]

Essential Code:
class CRhGetMeshBoundaryGrip : public CRhinoGetObject
{
public:
  bool CustomGeometryFilter(
    const CRhinoObject* obj,
    const ON_Geometry* geo,
    ON_COMPONENT_INDEX ci
    ) const;
};

bool CRhGetMeshBoundaryGrip::CustomGeometryFilter(
  const CRhinoObject* obj,
  const ON_Geometry* geo,
  ON_COMPONENT_INDEX ci
  ) const
{
  if( 0 == obj )
    return false;

  // Is grip object?
...

GUIDES / CPP / CUSTOM-UNDO-EVENTS
------------------------------------------------------------

Index
Source: guides\cpp\custom-undo-events\index.md
Overview

The Rhino C/C++ SDK supports adding custom undo events. This way plugins can take advantage of Rhino's built in Undo, Redo, UndoSelected, UndoMultiple, RedoMultiple and ClearUndo commands, and any future Rhino commands that deal with undo/redo operations.

How To

Basically, you create a class derived from CRhinoUndoEventHandler, pass it to Rhino, and let Rhino deal with all the details. Sample 1 below shows how to do this.

In order to have stable plugins, developers must follow the rules for using CRhinoDoc::AddCustomUndoEvent...


// Description:
// If you want to your plugin to do something when the Rhino
// Undo/Redo command runs, the call AddCustomUndoEvent during
// your command.
//
// This function is for expert plugin developers. If you
// don't do a good job here, you will really break Rhino.
//
// Parameters:
// undoeventhandler - [in]
// Pointer to a class allocated with a call to new.
// Never delete this class.
// Never pass a pointer to a stack variable.
//
// Returns:
// If a non zero number is returned, then this is the runtime
// serial number Rhino has assigned to this undo event.
// If zero is returned, then the user has disabled undo
// and undoeventhandler was deleted.

unsigned int AddCustomUndoEvent(
 CRhinoUndoEventHandler undoeventhandler
 );


When you are debugging your code, you may find the AuditUndo command useful. This command lists all the undo information saved in Rhino.

You can also use and event watcher to monitor Rhino undo/redo activity. Sample 2 (below) is a simple undo event watcher that reports undo activity in the Rhino command windows...

Samples

Sample 1

This "plugin" has one piece of data, the account balance, and two commands, EarnTenEuros and SpendFiveEuros. The commands use CUndoEuroTransaction class to provide integrated Undo/Redo support...


////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// BEGIN CUndoEuroTra... [truncated]

Essential Code:
// Description:
//   If you want to your plugin to do something when the Rhino
//   Undo/Redo command runs, the call AddCustomUndoEvent during
//   your command.
//
//   This function is for expert plugin developers.  If you
//   don't do a good job here, you will really break Rhino.
//
// Parameters:
//   undo_event_handler - [in]
//     Pointer to a class allocated with a call to new.
//     Never delete this class.
//     Never pass a pointer to a stack variable.
//
// Returns:
//   If a non zero number is returned, then this is the runtime
//   serial number Rhino has assigned to this undo event.
//   If zero is returned, then the user has disabled undo
//   and undo_event_handler was deleted.

...
////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// BEGIN CUndoEuroTransaction class definition
//

static double m_plugin_data_euro_balance = 0.0;

class CUndoEuroTransaction : public CRhinoUndoEventHandler
{
public:
  CUndoEuroTransaction();
  ~CUndoEuroTransaction();

  // virtual CRhinoUndoEventHandler function
  void Undo(
    const CRhinoCommand* cmd,
    const wchar_t* action_description,
    bool bCreatedByRedo,
    unsigned int undo_event_sn
...

GUIDES / CPP / DEFINING-NEW-PLUGIN-COMMANDS
------------------------------------------------------------

Index
Source: guides\cpp\defining-new-plugin-commands\index.md
Overview

Rhino plugins can contain any number of commands. Commands are created by deriving a new class from CRhinoCommand. See rhinoSdkCommand.h for details on the CRhinoCommand class.

Command classes must return a unique GUID. If you try to use a GUID that is already in use, then your command will not work. Use the GUIDGEN.EXE utility, that comes with Visual Studio, to create unique GUIDs.

Command classes must return a unique command name. If you try to use a command name that is already in use, then your command will not work.

Only ONE instance of a command class can be created. This is why you should put the definition of your command classes in .cpp files.

Rhino 8

The Rhino Visual Studio Extension, for the Rhino 8 C/C++ SDK, includes a template that lets you quickly add new commands to your plugin project.

To add a new Rhino command to your plugin project, right-click on the Source Files folder, in Visual Studio’s Solution Explorer, and click Add > New Item.... From the Add New Item dialog, select Empty Command for Rhino 3D (C++), specify the name of the command, and click Add.

!Add New Item

Rhino 7

The Rhino Command Generator wizard, included with the Rhino 7 C/C++ SDK, is a standalone application that will generate new skeleton CRhinoCommand-derived class. The generated source code is copied to the Windows clipboard so you can easily paste it into your source files.

To use this tool in Visual Studio:
Launch Visual Studio.
Navigate to Tools > External Tools....
Use the Add button to add the RhinoCommandGenerator.exe file to the list. The file can be found in the following location: C:\\Program Files\\Rhino 7.0 SDK\\Wizards\\Command

!Rhino Command Generator

Once the tool is installed, you can create a new command by selecting Tools > Rhino Command. If you add the command declaration to a new .cpp file, be sure to #include "stdafx.h" at the top.

Sample

The following sample code demonstrates a simple command class that essentially does nothing:

... [truncated]

Essential Code:
// Do NOT put the definition of class CCommandTest in a header
// file. There is only ONE instance of a CCommandTest class
// and that instance is the static theTestCommand that appears
// immediately below the class definition.

class CCommandTest : public CRhinoCommand
{
public:
  // The one and only instance of CCommandTest is created below.
  // No copy constructor or operator= is required.
  // Values of member variables persist for the duration of the application.

  // CCommandTest::CCommandTest()
  // is called exactly once when static theTestCommand is created.
  CCommandTest() = default;

  // CCommandTest::~CCommandTest()
  // is called exactly once when static theTestCommand is destroyed.
  // The destructor should not make any calls to the Rhino SDK. 
  // If your command has persistent settings, then override 
...

GUIDES / CPP / DETERMINING-CURVE-OBJECT-TYPES
------------------------------------------------------------

Index
Source: guides\cpp\determining-curve-object-types\index.md
Problem

Given an ONCurve, how can one determine which kind of ONCurve-derived object it really is? (e.g. ONLineCurve, ONArcCurve, ONPolylineCurve, ONPolyCurve, ONNurbsCurve, etc.)?

Solution

Basically, you try to cast the ONCurve object to one of the ONCurve-derived classes using its Cast operator. If the cast operation is success, you are good to go. If it fails, then you know the test object is some other ONCurve-derived object.

Sample


const ONLineCurve GetLineCurve( const ONCurve crv )
{
 const ONLineCurve p = 0;
 if( crv != 0 )
 p = ONLineCurve::Cast( crv );
 return p;
}

const ONArcCurve GetArcCurve( const ONCurve crv )
{
 const ONArcCurve p = 0;
 if( crv != 0 )
 p = ONArcCurve::Cast( crv );
 return p;
}

const ONPolylineCurve GetPolylineCurve( const ONCurve crv )
{
 const ONPolylineCurve p = 0;
 if( crv != 0 )
 p = ONPolylineCurve::Cast( crv );
 return p;
}

const ONPolyCurve GetPolyCurve( const ONCurve crv )
{
 const ONPolyCurve p = 0;
 if( crv != 0 )
 p = ONPolyCurve::Cast( crv );
 return p;
}

const ONNurbsCurve GetNurbsCurve( const ONCurve crv )
{
 const ONNurbsCurve* p = 0;
 if( crv != 0 )
 p = ONNurbsCurve::Cast( crv );
 return p;
}


Essential Code:
const ON_LineCurve* GetLineCurve( const ON_Curve* crv )
{
  const ON_LineCurve* p = 0;
  if( crv != 0 )
    p = ON_LineCurve::Cast( crv );
  return p;
}

const ON_ArcCurve* GetArcCurve( const ON_Curve* crv )
{
  const ON_ArcCurve* p = 0;
  if( crv != 0 )
    p = ON_ArcCurve::Cast( crv );
  return p;
}

const ON_PolylineCurve* GetPolylineCurve( const ON_Curve* crv )
{
  const ON_PolylineCurve* p = 0;
  if( crv != 0 )
...

GUIDES / CPP / DETERMINING-IF-BREP-IS-BOX
------------------------------------------------------------

Index
Source: guides\cpp\determining-if-brep-is-box\index.md
Problem

You would like to determine whether or not a polysurface is a (brep) box.

Solution

For a polysurface to be a box, the following conditions must be true:
The brep must be solid.
The brep must have six faces.
Each of the six faces must be planar.
Each of the planar face must be either perpendicular or antiparallel to the other planar faces.

Sample

The following sample functions demonstrate how to determine whether or not a polysurface is a box.


bool IsBrepBox( const ONBrep& brep )
{
 double zerotolerance = 1.0e-6; // or whatever
 ON3dVector N[6];

 bool rc = brep.IsSolid();

 if (rc)
 rc = (brep.mF.Count() == 6);

 if (rc)
 {
 for (int i = 0; rc && i < 6; i++)
 {
 ONPlane plane;
 if (brep.mF[i].IsPlanar(&plane, zerotolerance))
 {
 N[i] = plane.zaxis;
 N[i].Unitize();
 }
 else
 rc = false;
 }
 }

 if (rc)
 {
 for (int i = 0; rc && i < 6; i++)
 {
 int count = 0;
 for (int j = 0; rc && j < 6; j++)
 {
 double dot = fabs(N[i] * N[j]);
 if (fabs(dot) <= zerotolerance)
 continue;
 if (fabs(dot - 1.0) <= zero_tolerance)
 count++;
 else
 rc = false;
 }

 if (rc)
 {
 if (2 != count)
 rc = false;
 }
 }
 }

 return rc;
}


Essential Code:
bool IsBrepBox( const ON_Brep& brep )
{
  double zero_tolerance = 1.0e-6; // or whatever
  ON_3dVector N[6];

  bool rc = brep.IsSolid();

  if (rc)
    rc = (brep.m_F.Count() == 6);

  if (rc)
  {
    for (int i = 0; rc && i < 6; i++)
    {
      ON_Plane plane;
      if (brep.m_F[i].IsPlanar(&plane, zero_tolerance))
      {
        N[i] = plane.zaxis;
        N[i].Unitize();
      }
...

GUIDES / CPP / DETERMINING-LANGUAGE-SETTING
------------------------------------------------------------

Index
Source: guides\cpp\determining-language-setting\index.md
Overview

Rhino provides support for multiple languages. Rhino's language setting is independent of the operating system's language setting. Thus, as a plugin developer, knowing Rhino's current language setting is important if you plan on supporting multiple languages.

Rhino stores its current Locale ID (LCID) in a CRhinoAppAppearanceSettings object that is held within Rhino applications settings object, or CRhinoAppSettings.

Sample

The following is an example of how to determine Rhino's current language setting.


ONwString wstr;
CRhinoAppSettings settings = ::RhinoApp().AppSettings();
CRhinoAppAppearanceSettings appearance = settings.AppearanceSettings();

switch( appearance.mlanguage_identifier )
{
case 1028: // zh-tw
 wstr = L"Chinese - Taiwan";
 break;
case 1029: // cs
 wstr = L"Czech";
 break;
case 1031: // de-de
 wstr = L"German - Germany";
 break;
case 1033: // en-us
 wstr = L"English - United States";
 break;
case 1034: // es-es
 wstr = L"Spanish - Spain";
 break;
case 1036: // fr-fr
 wstr = L"French - France";
 break;
case 1040: // it-it
 wstr = L"Italian - Italy";
 break;
case 1041: // ja
 wstr = L"Japanese";
 break;
case 1042: // ko
 wstr = L"Korean";
 break;
case 1045: // pl
 wstr = L"Polish";
 break;
case 2052: // zh-cn
 wstr = L"Chinese - China";
 break;
default:
 wstr = L"unknown";
 break;
}
::RhinoApp().Print( L"The current language is \"%s\ , wstr );


GUIDES / CPP / DETERMINING-NORMAL-DIRECTION-OF-BREP-FACE
------------------------------------------------------------

Index
Source: guides\cpp\determining-normal-direction-of-brep-face\index.md
Overview

To determine the normal direction of a surface, you can use one of the following functions:


ONSurface::NormalAt()
ONSurface::EvNormal()


To determine the normal direction of a face which is part of a Brep, you can also use the above functions, as an ONBrepFace object is derived from ONSurface. But, you will also need to take into account the orientation of the Brep face. If the orientation of the Brep face is opposite of the underlying, natural surface orientation, then you will need to reverse the direction of the calculated normal vector.

It should also be noted that most surfaces in Rhino are really Breps with a single face.

Sample

The following sample code demonstrates how to interactively determine the normal direction of a selected surface or Brep face.


CRhinoCommand::result CCommandNormal::RunCommand( const CRhinoCommandContext& context )
{
 // Select a surface
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select surface" );
 go.SetGeometryFilter( CRhinoGetObject::surfaceobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 // Get the selected face
 const CRhinoObjRef& ref = go.Object(0);
 const ONBrepFace face = ref.Face();
 if( 0 == face )
 return failure;

 // Pick a point on the surface. Constrain
 // picking to the face.
 CRhinoGetPoint gp;
 gp.SetCommandPrompt( L"Select point on surface" );
 gp.Constrain( face );
 gp.GetPoint();
 if( gp.CommandResult() != success )
 return gp.CommandResult();

 ON3dPoint pt = gp.Point();

 // Get the parameters of the point on the
 // surface that is closest to pt
 double u, v;
 if( face->GetClosestPoint(pt, &u, &v) )
 {
 ON3dPoint pt;
 ON3dVector du, dv, dir;
 if( face->EvNormal(u, v, pt, du, dv, dir) )
 {
 // if the face orientation is opposite of
 // the natural surface orientation, then
 // reverse the direction of the vector.
 if( face->mbRev )
 dir.Reverse();

 RhinoApp().Print(
 L"Surface normal at uv(%.2f,%.2f) = (%.2f,%.2f,%.2f)\n",
 u,
 ... [truncated]

Essential Code:
CRhinoCommand::result CCommandNormal::RunCommand( const CRhinoCommandContext& context )
{
  // Select a surface
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select surface" );
  go.SetGeometryFilter( CRhinoGetObject::surface_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  // Get the selected face
  const CRhinoObjRef& ref = go.Object(0);
  const ON_BrepFace* face = ref.Face();
  if( 0 == face )
    return failure;

  // Pick a point on the surface. Constrain
  // picking to the face.
  CRhinoGetPoint gp;
  gp.SetCommandPrompt( L"Select point on surface" );
...

GUIDES / CPP / DETERMINING-THE-ACTIVE-VIEWPORT
------------------------------------------------------------

Index
Source: guides\cpp\determining-the-active-viewport\index.md
Problem

You are trying to determine if the current active view is a detail or a standard view. You are having some trouble differentiating between an active page layout and an active detail in a page layout.

Solution

Standard Rhino views are represented by the CRhinoView class. Layout views are represented by the CRhinoPageView class. This class is derived from CRhinoView. A CRhinoPageView object maintains an array of CRhinoDetailViewObject objects - one for each detail in the layout.

To determine whether a layout or one if it's details is active, get the UUID of the layout's active detail object. If the returned UUID is nil, then the layout itself is active. Otherwise, the detail object that has the returned UUID is active.

Sample


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoView view = RhinoApp().ActiveView();
 if (nullptr == view)
 return CRhinoCommand::failure;

 CRhinoPageView pageview = staticcast(view);
 if (pageview)
 {
 ONwString layoutname = pageview->MainViewport().Name();
 ONUUID activedetailuuid = pageview->ActiveDetailObject();
 if (ONUuidIsNotNil(activedetailuuid))
 {
 ONwString detailname = pageview->ActiveViewport().Name();
 RhinoApp().Print(L"The detail \"%s\" on layout \"%s\" is active.\n", 
 staticcast(detailname), 
 staticcast(layoutname)
 );
 }
 else
 {
 RhinoApp().Print(L"The layout \"%s\" is active.\n", 
 staticcast(layoutname)
 );
 }
 }
 else
 {
 ONwString viewportname = view->ActiveViewport().Name();
 RhinoApp().Print(L"The viewport \"%s\" is active.\n", 
 staticcast(viewportname)
 );
 }

 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoView* view = RhinoApp().ActiveView();
  if (nullptr == view)
    return CRhinoCommand::failure;

  CRhinoPageView* page_view = static_cast<CRhinoPageView*>(view);
  if (page_view)
  {
    ON_wString layout_name = page_view->MainViewport().Name();
    ON_UUID active_detail_uuid = page_view->ActiveDetailObject();
    if (ON_UuidIsNotNil(active_detail_uuid))
    {
      ON_wString detail_name = page_view->ActiveViewport().Name();
      RhinoApp().Print(L"The detail \"%s\" on layout \"%s\" is active.\n", 
        static_cast<const wchar_t*>(detail_name), 
        static_cast<const wchar_t*>(layout_name)
      );
    }
    else
...

GUIDES / CPP / DO-NOT-TEST-FOR-EQUALITY
------------------------------------------------------------

Index
Source: guides\cpp\do-not-test-for-equality\index.md
A Warning

You almost never want to write code like the following:


double x;
double y;
...
if (x == y) {...}


Most floating point operations involve at least a tiny loss of precision and so even if two numbers are equal for all practical purposes, they may not be exactly equal down to the last bit, and so the equality test is likely to fail. For example, the following code snippet prints -1.778636e-015. Although in theory, squaring should undo a square root, the round-trip operation is slightly inaccurate.


double x = 10;
double y = sqrt(x);
y *= y;
if (x == y)
 RhinoApp().Print(L"Square root is exact\n");
else
 RhinoApp().Print(L"%f\n", x-y);


In most cases, the equality test above should be written as something like the following:


double tolerance = ...
if (fabs(x - y) < tolerance) {...}


Here, tolerance is some threshold that defines what is "close enough" for equality. This begs the question of: how close is close enough? This cannot be answered in the abstract; you have to know something about your particular problem to know how close is close enough in your context.

GUIDES / CPP / DRAFT-ANGLE-CONTOURING
------------------------------------------------------------

Index
Source: guides\cpp\draft-angle-contouring\index.md
Problem

Rhino's draft angle analysis is very useful. However, it would be great it it could create contour curves at specific angles. For example:

!Draft Angle

Notice the red curve on the right-hand image above. This is what you would like to automate. Is there an Rhino function that will help do this?

Solution

There is not an function that will help you do this. But, it is possible to write your own tool.

Draft angle analysis works by calculating the angles between mesh vertex normals and the unit normal (in most cases this is the world z-axis). It is possible to perform this calculation from a plugin command. From these angles, it is possible to determine whether or not a contour line would pass through a mesh vertex or if it would cross between two mesh vertices.

Sample

The follow sample code demonstrates this process:


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Pick a mesh object
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select mesh for draft angle contour" );
 go.SetGeometryFilter( CRhinoGetObject::meshobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 const ONMesh pMesh = go.Object(0).Mesh();
 if( 0 == pMesh )
 return failure;

 // Copy mesh so we can tweak it if necessary
 ONMesh mesh( pMesh );

 // To make our life easy, convert all quads to triangles.
 mesh.ConvertQuadsToTriangles();

 // For draft angle analysis, mesh must have vertex normals.
 if( !mesh.HasVertexNormals() )
 {
 if( !mesh.ComputeVertexNormals() )
 return failure;
 }

 // Specify a draft angle
 CRhinoGetNumber gn;
 gn.SetCommandPrompt( L"Draft angle" );
 gn.SetDefaultNumber( mangle );
 gn.SetLowerLimit( 0.0, TRUE );
 gn.SetUpperLimit( 90.0, TRUE );
 gn.GetNumber();
 if( gn.CommandResult() != success )
 return gn.CommandResult();

 mangle = gn.Number(); // degrees

 //////////////////////////////////////////////////////////////

 double A = mangle ( ONPI / 180.0 ); // alpha
 ON... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Pick a mesh object
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select mesh for draft angle contour" );
  go.SetGeometryFilter( CRhinoGetObject::mesh_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  const ON_Mesh* pMesh = go.Object(0).Mesh();
  if( 0 == pMesh )
    return failure;

  // Copy mesh so we can tweak it if necessary
  ON_Mesh mesh( *pMesh );

  // To make our life easy, convert all quads to triangles.
  mesh.ConvertQuadsToTriangles();

...

GUIDES / CPP / DRAWING-ARROWHEADS-IN-DISPLAY-CONDUITS
------------------------------------------------------------

Index
Source: guides\cpp\drawing-arrowheads-in-display-conduits\index.md
Problem

You are trying to get your head around drawing arrowheads through conduits in the Rhino C/C++ SDK. You create an instance of the CRhinoArrowhead class and set 2D information (point and direction) and then need to set a parent (any type of CRhinoAnnotationObject). As CRhinoAnnotationObject is a virtual class, for your purposes the best version seems to be the leader class. But (not surprisingly) the arrowhead behaves like a leader, sitting in world space, and is not aligned or scaled to the viewport's construction as desired. Is there any other way to draw an arrowhead that does not involve using the CRhinoArrowhead class?

Solution

Drawing arrowheads in a conduit by using an CRhinoArrowhead object might appear to be the correct approach, but this object is fairly specialized and designed to be used in conjunction with other annotation objects. So in this case, this might not work well.

If you add your lines to the document, you can set the objects' decorations. Then Rhino would draw the arrowheads for you.

But adding temporary geometry to the document just for display purposes is awkward and frowned upon.

You might be better off just drawing your own arrowheads. It's really not that hard. Draw arrowheads by calling the display pipeline's DrawPolygon() member with the fill parameter set to true. The trick is defining the polygon you want to draw.

Below is some sample code that draws a 2D arrowhead at the end of a line similar to a leader object. Perhaps this will give you an idea how to implement arrowhead drawing in your project.


#pragma region SampleDrawArrowheadConduit conduit

class CSampleDrawArrowheadConduit : public CRhinoDisplayConduit
{
public:
 CSampleDrawArrowheadConduit(ONPlane plane, ONLine line, double scale);

 bool ExecConduit(CRhinoDisplayPipeline& dp, UINT channel, bool& terminate);

protected:
 bool GetArrowHead(ON2dVector dir, ON2dPoint tip, double scale, ON3dPointArray& triangle);

protected:
 static double mdefaultarrowsize;... [truncated]

Essential Code:
#pragma region SampleDrawArrowheadConduit conduit

class CSampleDrawArrowheadConduit : public CRhinoDisplayConduit
{
public:
  CSampleDrawArrowheadConduit(ON_Plane plane, ON_Line line, double scale);

  bool ExecConduit(CRhinoDisplayPipeline& dp, UINT channel, bool& terminate);

protected:
  bool GetArrowHead(ON_2dVector dir, ON_2dPoint tip, double scale, ON_3dPointArray& triangle);

protected:
  static double m_default_arrow_size;
  bool m_bDraw;
  ON_Line m_line;
  ON_Plane m_plane;
  ON_3dPointArray m_arrowhead;
};

...
CRhinoCommand::result CCommandSampleDrawArrowhead::RunCommand( const CRhinoCommandContext& context )
{
  ON_Line line;
  ON_Plane plane;

  CRhinoGetPoint gp;
  gp.SetCommandPrompt(L"Start of line");
  gp.GetPoint();
  if (gp.CommandResult() != CRhinoCommand::success)
    return gp.CommandResult();

  line.from = gp.Point();
  plane = RhinoActiveCPlane();
  plane.SetOrigin(line.from);

  gp.SetCommandPrompt(L"End of line");
  gp.Constrain(plane);
  gp.SetBasePoint(line.from);
  gp.DrawLineFromPoint(line.from, TRUE);
  gp.GetPoint();
...

GUIDES / CPP / DUPLICATING-OBJECTS-WITH-GROUP
------------------------------------------------------------

Index
Source: guides\cpp\duplicating-objects-with-group\index.md
Problem

When you duplicate a Rhino object which happens to be a member of a group, the duplicate object is (also) a member of that same group. Is there a quick way to duplicate a Rhino object and have the duplicated object be a member of a new group?

Solution

You can use the RhinoUpdateObjectGroups function. See rhinoSdkGrips.h for details.

Here is a sample of its usage:


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select objects to copy in-place" );
 go.EnableGroupSelect( TRUE );
 go.EnableSubObjectSelect( FALSE );
 go.GetObjects( 1, 0 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 ONXform xform;
 xform.Identity();

 ON2dexMap groupmap;

 for( int i = 0; i < go.ObjectCount(); i++ )
 {
 const CRhinoObject object = go.Object(i).Object();
 if( object )
 {
 CRhinoObject duplicate = context.mdoc.TransformObject( object, xform, true, false, true );
 if( duplicate )
 RhinoUpdateObjectGroups( duplicate, groupmap );
 }
 }

 context.mdoc.Redraw();

 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select objects to copy in-place" );
  go.EnableGroupSelect( TRUE );
  go.EnableSubObjectSelect( FALSE );
  go.GetObjects( 1, 0 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  ON_Xform xform;
  xform.Identity();

  ON_2dexMap group_map;

  for( int i = 0; i < go.ObjectCount(); i++ )
  {
    const CRhinoObject* object = go.Object(i).Object();
    if( object )
    {
...

GUIDES / CPP / DYNAMICALLY-DRAWING-GEOMETRY-WHEN-PICKING-POINTS
------------------------------------------------------------

Index
Source: guides\cpp\dynamically-drawing-geometry-when-picking-points\index.md
Overview

When using Rhino, you have probably noticed that many of the object creation commands, such as Line and Circle, and transformation commands, such as Move and Copy, dynamically draw objects as they are being created or transformed. This operation is performed by deriving a new class from Rhino's point pick class, CRhinoGetPoint, and overriding two member functions: OnMouseMove() and DynamicDraw().

OnMouseMove() is called every time the mouse moves. This is a great place to perform calculations, such as transformations.

DynamicDraw() is called as the mouse moves, as well. Every time the mouse moves, DynamicDraw() will be called once per viewport. 


Sample

The following sample demonstrates how to derive a new class from CRhinoGetPoint and override OnMouseMove() and DynamicDraw() to dynamically draw geometry. In this sample, we are going to dynamically draw a circle while the user is specifying its radius.


class CGetCircleRadiusPoint : public CRhinoGetPoint
{
public:
 CGetCircleRadiusPoint();
 void SetCenterPoint( const ON3dPoint centerpoint );
 bool CalculateCircle( CRhinoViewport& vp, const ON3dPoint& pt );

 void OnMouseMove( CRhinoViewport& vp,
 UINT flags,
 const ON3dPoint& pt,
 const CPoint* pt2d );

 void DynamicDraw( HDC hDC, CRhinoViewport& vp, const ON3dPoint& pt );
 const ONCircle& Circle() const;
private:
 ONCircle mcircle;
 ON3dPoint mcenterpoint;
 bool mdrawcircle;
};

CGetCircleRadiusPoint::CGetCircleRadiusPoint()
{
 mdrawcircle = false;
}

void CGetCircleRadiusPoint::SetCenterPoint( const ON3dPoint centerpoint )
{
 mcenterpoint = centerpoint;
}

bool CGetCircleRadiusPoint::CalculateCircle( CRhinoViewport& vp, const ON3dPoint& pt )
{
 double radius = mcenterpoint.DistanceTo( pt );
 if( radius Viewport(), gc.Point() ))
 {
 ONCircle circle = gc.Circle();
 context.mdoc.AddCurveObject( circle );
 context.mdoc.Redraw();
 }
 return CRhinoCommand::success;
}


Essential Code:
class CGetCircleRadiusPoint : public CRhinoGetPoint
{
public:
  CGetCircleRadiusPoint();
  void SetCenterPoint( const ON_3dPoint center_point );
  bool CalculateCircle( CRhinoViewport& vp, const ON_3dPoint& pt );

  void OnMouseMove( CRhinoViewport& vp,
                    UINT flags,
                    const ON_3dPoint& pt,
                    const CPoint* pt2d );

  void DynamicDraw( HDC hDC, CRhinoViewport& vp, const ON_3dPoint& pt );
  const ON_Circle& Circle() const;
private:
  ON_Circle m_circle;
  ON_3dPoint m_center_point;
  bool m_draw_circle;
};

...
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetPoint gp;
  gp.SetCommandPrompt( L"Center point" );
  gp.ConstrainToConstructionPlane( FALSE );
  gp.GetPoint();
  if( gp.CommandResult() != CRhinoCommand::success )
    return gp.CommandResult();

  ON_3dPoint center_point = gp.Point();

  CGetCircleRadiusPoint gc;
  gc.SetCommandPrompt( L"Radius" );
  gc.ConstrainToConstructionPlane( FALSE );
  gc.SetBasePoint( center_point );
  gc.DrawLineFromPoint( center_point, TRUE );
  gc.SetCenterPoint( center_point );
  gc.GetPoint();
  if( gc.CommandResult() != CRhinoCommand::success )
    return gc.CommandResult();
...

GUIDES / CPP / DYNAMICALLY-DRAWING-POLYLINES
------------------------------------------------------------

Index
Source: guides\cpp\dynamically-drawing-polylines\index.md
Problem

What is the best way to draw dynamically a geometry based on a polyline? How is it possible to compute an object geometry based on a polyline picked by the user?

Solution

If you are not interested in writing your own drawing routine and you want to just use Rhino's built-in polyline drawing tool, then you can just use Rhino's RhinoGetPolyline function. See rhinoSdkGetLine.h 

If you need more control over how the polyline is define or how it is drawn, then you can derive your own class from CRhinoGetPoint and draw the polyline yourself.

Sample

The following sample code demonstrates a simple class, derived from CRhinoGetPoint, that dynamically draws a polyline based on the points picked by a user.


/////////////////////////////////////////////////////////////////////////////
// CRhGetPoints declaration

class CRhGetPoints : public CRhinoGetPoint
{
public:
 CRhGetPoints();
 void DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON3dPoint& pt );
 CRhinoGet::result GetPoints( CRhinoHistory history = NULL, bool bOnMouseUp = false );
 int Points( ON3dPointArray& points );

public:
 ON3dPointArray mP;
};

/////////////////////////////////////////////////////////////////////////////
// CRhGetPoints definition

CRhGetPoints::CRhGetPoints()
{
 mP.SetCapacity( 64 );
}

CRhinoGet::result CRhGetPoints::GetPoints( CRhinoHistory history, bool bOnMouseUp )
{
 mP.Empty();

 SetCommandPrompt( L"First point" );

 CRhinoGet::result res = GetPoint( history, bOnMouseUp );

 if( res == CRhinoGet::point )
 {
 mP.Append( Point() );

 SetCommandPrompt( L"Next point" );
 PermitOrthoSnap();
 AcceptNothing();

 for( ;; )
 {
 SetBasePoint( Point() );

 res = GetPoint( history, bOnMouseUp );

 if( res == CRhinoGet::point )
 {
 mP.Append( Point() );
 continue;
 }

 else if( res == CRhinoGet::nothing )
 res = CRhinoGet::point;

 else if( res == CRhinoGet::cancel )
 mP.Empty();

 break;
 }
 }

 return res;
}

void CRhGetPoints::DynamicDraw( HDC hdc, CRhinoViewpo... [truncated]

Essential Code:
/////////////////////////////////////////////////////////////////////////////
// CRhGetPoints declaration

class CRhGetPoints : public CRhinoGetPoint
{
public:
  CRhGetPoints();
  void DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON_3dPoint& pt );
  CRhinoGet::result GetPoints( CRhinoHistory* history = NULL, bool bOnMouseUp = false );
  int Points( ON_3dPointArray& points );

public:
  ON_3dPointArray m_P;
};

/////////////////////////////////////////////////////////////////////////////
// CRhGetPoints definition

CRhGetPoints::CRhGetPoints()
{
...
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhGetPoints gp;
  CRhinoGet::result res = gp.GetPoints();
  if( res == CRhinoGet::point )
  {
    // TODO...
  }
  return CRhinoCommand::success;
}


GUIDES / CPP / DYNAMICALLY-DRAWING-TEXT-STRINGS
------------------------------------------------------------

Index
Source: guides\cpp\dynamically-drawing-text-strings\index.md
Overview

On occasion, it is useful to dynamically display some text while in the middle of a point picking operation. Rhino's VariableFilletSrf command is a good example of a command that does this.

To add this capability to an plugin command, you need to:
Derive a new class from CRhinoGetPoint.
Override the CRhinoGetPoint::DynamicDraw virtual function.
From within the DynamicDraw override, call CRhinoViewport::DrawString.

Sample

The following example code demonstrates how to derive a new class from CRhinoGetPoint, override the CRhinoGetPoint::DynamicDraw member, and draw text dynamically.


class CDrawStringGetPoint : public CRhinoGetPoint
{
public:
 CDrawStringGetPoint() {}
 void DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON3dPoint& pt );
};

void CDrawStringGetPoint::DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON3dPoint& pt )
{
 // Format active point as a string
 ONwString str;
 RhinoFormatPoint( pt, str );

 // Build world-to-screen coordinate transformation
 ONXform w2s;
 vp.VP().GetXform( ON::worldcs, ON::screencs, w2s );

 // Transform point from world to screen coordinates
 ON_3dPoint screenpoint = w2s * pt;

 // Offset point so text does not overlap cursor
 screenpoint.x += 5.0;
 screenpoint.y += -5.0;

 // Draw string using the system font
 vp.DrawString( str, str.Length(), screenpoint, false, 0, 12, L"System" );

 // Allow base class to draw
 CRhinoGetPoint::DynamicDraw( hdc, vp, pt );
}


You can use the above class as you would a CRhinoGetPoint object. Just create a new CDrawStringGetPoint object, initialize the class by calling base class members, and call it's GetPoint member. For example:


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CDrawStringGetPoint gp;
 gp.SetCommandPrompt( L"Pick test point" );
 gp.GetPoint();
 if( gp.CommandResult() != success )
 return gp.CommandResult();

 // TODO...

 return success;
}


Essential Code:
class CDrawStringGetPoint : public CRhinoGetPoint
{
public:
  CDrawStringGetPoint() {}
  void DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON_3dPoint& pt );
};

void CDrawStringGetPoint::DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON_3dPoint& pt )
{
  // Format active point as a string
  ON_wString str;
  RhinoFormatPoint( pt, str );

  // Build world-to-screen coordinate transformation
  ON_Xform w2s;
  vp.VP().GetXform( ON::world_cs, ON::screen_cs, w2s );

  // Transform point from world to screen coordinates
  ON_3dPoint screenpoint = w2s * pt;

...
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CDrawStringGetPoint gp;
  gp.SetCommandPrompt( L"Pick test point" );
  gp.GetPoint();
  if( gp.CommandResult() != success )
    return gp.CommandResult();

  // TODO...

  return success;
}


GUIDES / CPP / DYNAMICALLY-INSERTING-BLOCKS
------------------------------------------------------------

Index
Source: guides\cpp\dynamically-inserting-blocks\index.md
Overview

To dynamically insert and draw blocks, you can take advantage of the new display pipeline technology, which is capable of drawing block instance definitions. For example, the following code demonstrates how to draw a block instance definition from a CRhinoGetPoint-derived object's DynamicDraw member...


class CGetBlockInsertPoint : public CRhinoGetPoint
{
public:
 CGetBlockInsertPoint( const CRhinoInstanceDefinition idef );

 // CRhinoGetPoint overrides
 void OnMouseMove( CRhinoViewport&, UINT, const ON3dPoint&, const CPoint );
 void DynamicDraw( HDC, CRhinoViewport&, const ON3dPoint& );

 bool CalculateTransform( CRhinoViewport&, const ON3dPoint&, ONXform& );

private:
 const CRhinoInstanceDefinition midef;
 ONXform mxform;
 bool mbDraw;
};

CGetBlockInsertPoint::CGetBlockInsertPoint( const CRhinoInstanceDefinition idef )
: midef(idef)
{
 mxform.Identity();
 mbDraw = false;
}

void CGetBlockInsertPoint::OnMouseMove(
 CRhinoViewport& vp,
 UINT flags,
 const ON3dPoint& pt,
 const CPoint p
 )
{
 mbDraw = CalculateTransform( vp, pt, mxform );
 CRhinoGetPoint::OnMouseMove( vp, flags, pt, p );
}

void CGetBlockInsertPoint::DynamicDraw(
 HDC hdc,
 CRhinoViewport& vp,
 const ON3dPoint& pt
 )
{
 if( midef && mbDraw )
 {
 CRhinoDisplayPipeline dp = vp.DisplayPipeline();
 if( dp )
 {
 dp->PushObjectColor( 0 );
 dp->DrawObject( midef, &mxform );
 dp->PopObjectColor();
 }
 }
 CRhinoGetPoint::DynamicDraw( hdc, vp, pt );
}

bool CGetBlockInsertPoint::CalculateTransform(
 CRhinoViewport& vp,
 const ON3dPoint& pt,
 ONXform& xform
 )
{
 bool rc = false;
 ON3dVector v = pt - BasePoint();
 if( v.IsTiny() )
 xform.Identity();
 else
 xform.Translation( v );
 return xform.IsValid();
}


Sample

The following sample code demonstrates how to insert a block definition into the Rhino document and allow the user to interactively pick the insertion point.


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Prompt for instance defin... [truncated]

Essential Code:
class CGetBlockInsertPoint : public CRhinoGetPoint
{
public:
  CGetBlockInsertPoint( const CRhinoInstanceDefinition* idef );

  // CRhinoGetPoint overrides
  void OnMouseMove( CRhinoViewport&, UINT, const ON_3dPoint&, const CPoint* );
  void DynamicDraw( HDC, CRhinoViewport&, const ON_3dPoint& );

  bool CalculateTransform( CRhinoViewport&, const ON_3dPoint&, ON_Xform& );

private:
  const CRhinoInstanceDefinition* m_idef;
  ON_Xform m_xform;
  bool m_bDraw;
};

CGetBlockInsertPoint::CGetBlockInsertPoint( const CRhinoInstanceDefinition* idef )
: m_idef(idef)
{
...
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Prompt for instance definition to insert
  CRhinoGetString gs;
  gs.SetCommandPrompt( L"Name of block to insert" );
  gs.GetString();
  if( gs.CommandResult() != success )
    return gs.CommandResult();

  ON_wString idef_name = gs.String();
  idef_name.TrimLeftAndRight();
  if( idef_name.IsEmpty() )
    return nothing;

  // Find specified instance definition
  CRhinoInstanceDefinitionTable& idef_table = context.m_doc.m_instance_definition_table;
  int idef_index = idef_table.FindInstanceDefinition( idef_name );
  if( idef_index < 0 )
  {
    RhinoApp().Print( L"Unable to insert \"%s\". Block not found.\n", idef_name );
...

GUIDES / CPP / ENABLING-ORTHOGONAL-MODE
------------------------------------------------------------

Index
Source: guides\cpp\enabling-orthogonal-mode\index.md
Problem

You are trying to draw a line and you need ortho enabled.

Solution

The state of Rhino's orthogonal drawing mode is stored in Rhino's application settings, or it's CRhinoAppSettings object. To check the current state of ortho, call CRhinoAppSettings::Ortho. To enable or disable ortho, call CRhinoAppSettings::EnableOrtho and pass in the boolean value that is appropriate. h.

Sample

The following sample code illustrates how to use this feature:


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 CRhinoGetPoint gp;
 gp.SetCommandPrompt(L"Starting point");
 gp.GetPoint();
 if (gp.CommandResult() != success)
 return gp.CommandResult();

 ON3dPoint startpoint = gp.Point();

 CRhinoAppSettings& settings = RhinoApp().AppSettings();
 bool bOldValue = settings.Ortho();
 if (bOldValue == false)
 settings.EnableOrtho(true);

 gp.SetCommandPrompt(L"Ending point");
 gp.SetBasePoint(startpoint);
 gp.DrawLineFromPoint(startpoint, true);
 gp.GetPoint();

 if (bOldValue != settings.Ortho())
 settings.EnableOrtho(bOldValue);

 if (gp.CommandResult() != success)
 return gp.CommandResult();

 ON3dPoint endpoint = gp.Point();

 ONLine line(startpoint, endpoint);
 context.mdoc.AddCurveObject(line);
 context.m_doc.Redraw();

 return success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetPoint gp;
  gp.SetCommandPrompt(L"Starting point");
  gp.GetPoint();
  if (gp.CommandResult() != success)
    return gp.CommandResult();

  ON_3dPoint start_point = gp.Point();

  CRhinoAppSettings& settings = RhinoApp().AppSettings();
  bool bOldValue = settings.Ortho();
  if (bOldValue == false)
    settings.EnableOrtho(true);

  gp.SetCommandPrompt(L"Ending point");
  gp.SetBasePoint(start_point);
  gp.DrawLineFromPoint(start_point, true);
  gp.GetPoint();

...

GUIDES / CPP / EXTRACTING-CURVE-EDIT-POINTS
------------------------------------------------------------

Index
Source: guides\cpp\extracting-curve-edit-points\index.md
Problem

You would like to extract a curve's edit points - the points you see when you run the EditPtOn command, but you do not see any methods on ONCurve or ONNurbsCurve to do this.

Solution

Unlike control points, edit points are not part of a NURBS curve's data structure. Rather, they are calculated when needed.

The following code demonstrates to get obtain the edit points for a NURBS curve and then create point objects at those locations.


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 const ONCurve* crv = go.Object(0).Curve();
 if( 0 == crv )
 return failure;

 ONNurbsCurve nc;
 if( crv->GetNurbForm(nc) )
 {
 // For every control point, we can calculate
 // a cooresponding edit point.
 ONSimpleArray t( nc.CVCount() );
 t.SetCount( nc.CVCount() );

 if( nc.GetGrevilleAbcissae(t.Array()) )
 {
 int i;
 for( i = 0; i < t.Count(); i++ )
 context.mdoc.AddPointObject( nc.PointAt(t[i]) );
 context.mdoc.Redraw();
 }
 }

 return success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  const ON_Curve* crv = go.Object(0).Curve();
  if( 0 == crv )
    return failure;

  ON_NurbsCurve nc;
  if( crv->GetNurbForm(nc) )
  {
    // For every control point, we can calculate
    // a cooresponding edit point.
    ON_SimpleArray<double> t( nc.CVCount() );
    t.SetCount( nc.CVCount() );
...

GUIDES / CPP / EXTRACTING-THUMBNAIL-PREVIEW-IMAGES
------------------------------------------------------------

Index
Source: guides\cpp\extracting-thumbnail-preview-images\index.md
Problem

You would like to be able to display a 3dm file's thumbnail preview image in a dialog box.

Solution

When Rhino reads a 3dm file, it ignores the thumbnail preview image stored in the file (since it is never used). Thus, if you want to obtain the thumbnail preview image for the current document, or any 3dm file, you will have to read the 3dm file yourself. Fortunately, you only need to read a very small portion of the 3dm file to get the thumbnail preview image.

Rhino stores a document's thumbnail preview image as an ONWindowsBitmap, which is just an uncompressed Windows device independent bitmap, or DIB. At the heart of ONWindowsBitmap is simply a Windows BITMAPINFO structure.

Sample

The following sample code demonstrates how to read the thumbnail preview image from a 3dm file.


bool Read3dmThumbnailPreviewImage( const wchart filename, ONWindowsBitmap& bitmap )
{
 if( 0 == filename 0 == filename[0] )
 return false;

 try
 {
 FILE archivefp = ON::OpenFile( filename, L"rb" );
 if( 0 == archivefp )
 return false;

 ONBinaryFile archive( ON::read3dm, archivefp );

 // STEP 1: REQUIRED - Read start section
 int fileversion = 0;
 ONString strComments;
 if( !archive.Read3dmStartSection(&fileversion, strComments) )
 {
 ON::CloseFile( archivefp );
 return false;
 }

 // STEP 2: REQUIRED - Read properties section
 ON3dmProperties properties;
 if( !archive.Read3dmProperties(properties) )
 {
 ON::CloseFile( archivefp );
 return false;
 }

 ON::CloseFile( archivefp );

 if( !properties.mPreviewImage.IsValid() )
 return false;

 bitmap = properties.m_PreviewImage;
 }

 catch(...) // Handle all exceptions
 {
 return false;
 }

 return true;
}


Essential Code:
bool Read3dmThumbnailPreviewImage( const wchar_t* filename, ON_WindowsBitmap& bitmap )
{
  if( 0 == filename | 0 == filename[0] )
    return false;

  try
  {
    FILE* archive_fp = ON::OpenFile( filename, L"rb" );
    if( 0 == archive_fp )
      return false;

    ON_BinaryFile archive( ON::read3dm, archive_fp );

    // STEP 1: REQUIRED - Read start section
    int file_version = 0;
    ON_String strComments;
    if( !archive.Read3dmStartSection(&file_version, strComments) )
    {
      ON::CloseFile( archive_fp );
      return false;
...

GUIDES / CPP / FINDING-PARAMETER-OF-CURVE-AT-POINT
------------------------------------------------------------

Index
Source: guides\cpp\finding-parameter-of-curve-at-point\index.md
Overview

In general, to find the parameter of a point on a curve that is closest to a test point, use ONCurve::GetClosestPoint(). See opennurbscurve.h 

Sample

The following sample code demonstrates how to find the parameter of a curve at a point. The code demonstrates how to select a curve object, and how to pick a point on a curve.

h.


CRhinoCommand::result CCommandTest::RunCommand(
 const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 const CRhinoObjRef& objref = go.Object( 0 );
 const ONCurve crv = objref.Curve();
 if( !crv )
 return CRhinoCommand::failure;

 CRhinoGetPoint gp;
 gp.SetCommandPrompt( L"Pick a location on the curve" );
 gp.Constrain( crv ); // constrain to curve
 gp.GetPoint();
 if( gp.CommandResult() != CRhinoCommand::success )
 return gp.CommandResult();

 ON3dPoint pt = gp.Point();
 double t = 0.0;
 if( crv->GetClosestPoint(pt, &t) )
 RhinoApp().Print(
 L"Curve parameter at (%f,%f,%f) is %g.\n",
 pt.x, pt.y, pt.z, t );

 return CRhinoCommand::success;
}


It is possible to save a step by examining the CRhinoObjRef class. The class return information on the picking operation that just occurred, including the object that was picked, the point that the user picked, and in this case, the parameter of the curve that was closest to the picked point.


CRhinoCommand::result CCommandTest::RunCommand(
 const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 const CRhinoObjRef& objref = go.Object( 0 );

 ON3dPoint pt;
 objref.SelectionPoint( pt ... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(
    const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  const CRhinoObjRef& objref = go.Object( 0 );
  const ON_Curve* crv = objref.Curve();
  if( !crv )
    return CRhinoCommand::failure;

  CRhinoGetPoint gp;
  gp.SetCommandPrompt( L"Pick a location on the curve" );
  gp.Constrain( *crv ); // constrain to curve
  gp.GetPoint();
  if( gp.CommandResult() != CRhinoCommand::success )
...
CRhinoCommand::result CCommandTest::RunCommand(
      const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  const CRhinoObjRef& objref = go.Object( 0 );

  ON_3dPoint pt;
  objref.SelectionPoint( pt )
  double t = 0.0;
  const ON_Curve* crv = objref.CurveParameter( &t );
  if( crv )
    RhinoApp().Print(
        L"Curve parameter at (%f,%f,%f) is %g.\n",
        pt.x, pt.y, pt.z, t );
...

GUIDES / CPP / FINDING-POINTS-ON-CURVES-AT-ARC-LENGTH-DISTANCES
------------------------------------------------------------

Index
Source: guides\cpp\finding-points-on-curves-at-arc-length-distances\index.md
Problem

For a given length from the beginning of a curve, you would like to get the curve's parameter at this point.

Solution

The two functions on ONCurve that are useful for determining the parameter of the point on a curve that is a prescribed arc length distance from the start of a curve are:
ONCurve::GetNormalizedArcLengthPoint
ONCurve::GetNormalizedArcLengthPoints

To use these functions, calculate a normalized arc length parameter. That is, a parameter on the curve where 0.0 = the start of the curve, 0.5 = the midpoint of the curve, and 1.0 = the end of the curve.


Sample

The following code sample demonstrates how to use these functions:


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 const CRhinoObjRef& objref = go.Object(0);
 const ONCurve* crv = objref.Curve();
 if( 0 == crv )
 return failure;

 double crvlength = 0.0;
 if( !crv->GetLength(&crvlength) )
 return failure;

 CRhinoGetNumber gn;
 gn.SetCommandPrompt( L"Length from start" );
 gn.SetLowerLimit( 0.0, TRUE );
 gn.SetUpperLimit( crvlength, TRUE );
 gn.GetNumber();
 if( gn.CommandResult() != success )
 return gn.CommandResult();

 // Cook up a normalized arc length parameter,
 // where 0.0 GetNormalizedArcLengthPoint(s, &t) )
 {
 ON3dPoint pt = crv->PointAt( t );
 context.mdoc.AddPointObject( pt );
 context.m_doc.Redraw();
 }

 return success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  const CRhinoObjRef& obj_ref = go.Object(0);
  const ON_Curve* crv = obj_ref.Curve();
  if( 0 == crv )
    return failure;

  double crv_length = 0.0;
  if( !crv->GetLength(&crv_length) )
    return failure;

  CRhinoGetNumber gn;
  gn.SetCommandPrompt( L"Length from start" );
...

GUIDES / CPP / FINDING-RHINO-INSTALLATION-FOLDER
------------------------------------------------------------

Index
Source: guides\cpp\finding-rhino-installation-folder\index.md
Problem

You are putting together an installer for your Rhino plugin. You would like to know how you can, programatically, get Rhino's installation folder.

Solution

Rhino 8, 7, and 6

If you are looking for Rhino 8, 7, or 6, then you can find the location of Rhino's installation folder by looking in the Windows Registry in this location:


Hive: HKEYLOCALMACHINE
Key: SOFTWARE\McNeel\Rhinoceros\\Install
Name: InstallPath
Type: REGSZ


If you are looking for Rhino 8, for example, replace with 8.0.

Rhino 5

If you are looking for Rhino 5 64-bit, then you can find the location of Rhino's installation folder by looking in the Windows Registry in this location:


Hive: HKEYLOCALMACHINE
Key: SOFTWARE\McNeel\Rhinoceros\5.0x64\Install
Name: InstallPath
Type: REGSZ


If you are looking for Rhino 5 32-bit, then you can find the location of Rhino's installation folder by looking in the Windows Registry in this location:


Hive: HKEYLOCALMACHINE
Key: SOFTWARE\WOW6432Node\McNeel\Rhinoceros\5.0\Install
Name: InstallPath
Type: REG_SZ


GUIDES / CPP / FPU-ISSUES
------------------------------------------------------------

Index
Source: guides\cpp\fpu-issues\index.md
Problem

When your plugin tries to perform a certain calculation, you get the following text in Visual Studio's output window:


[[developer:opennurbs:home opennurbs]] ERROR # 2 .\rhino3MathErrorHandling.cpp:154 Serious math library or floating point errors occurred.

[[developer:opennurbs:home opennurbs]] ERROR # 3 .\opennurbsplusfpu.cpp:289 ONFPUBeforeSloppyCall - fpu STAT is already dirty. See source comment for next steps.


Workaround

These two opennurbs errors are most likely related.

Sometimes it is impossible to avoid calling code that performs invalid floating point operations or rudely changes the FPU control settings. We have found dozens of cases in Windows core DLLs, 3rd party DLLs, OpenGL drivers, VBScript, and the .NET JIT compiler where the FPU CTRL setting is changed or floating point exceptions are generated. When these cases are discovered, we bracket the code that is abusing the FPU with:


ONFPUBeforeSloppyCall();
// call that abuses the FPU
ONFPUAfterSloppyCall();


In doing this, we don't lose any information about exceptions in our own code and we don't get pestered about exceptions we can't do anything about. (Note, if you are calling something that may run the .NET JIT, then use ONFPUAfterDotNetJITUse instead of ONFPUAfterSloppyCall).

Also, the following error occurs when a serious divide by zero, overflow, or invalid operation happened sometime before the call to ONFPUBeforeSloppyCall:


[[developer:opennurbs:home opennurbs]] ERROR # 3 .\opennurbsplusfpu.cpp:289 ONFPUBeforeSloppyCall - fpu STAT is already dirty. See source comment for next steps.


These are easy to find. Start Rhino, run TestErrorCheck and set CrashOnFPUException=Yes. Then do whatever it is that made the FPU dirty. You will crash on the line that is dividing by zero, overflowing, or performing the invalid operation.

GUIDES / CPP / GETTING-LAYER-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\getting-layer-objects\index.md
Problem

You would like to get all the objects on a specific layer.

Solution

You can get all of the objects on a specified layer in two ways:
Use CRhinoDoc::LookupObject.
Use a CRhinoObjectIterator.

The CRhinoDoc::LookupObject is somewhat easier. So, we will demonstrate this in the following sample...

Sample


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 const wchart* pszlayername = L"Default"; ;
 int layerindex = context.mdoc.mlayertable.FindLayerFromFullPathName(pszlayername, ONUNSETINTINDEX);
 if (layerindex >= 0 && layerindex objects;
 int objectcount = context.mdoc.LookupObject(layer, objects);
 if (objectcount > 0)
 {
 RhinoApp().Print(L"%s layer object(s)s:\n", pszlayer_name);
 for (int i = 0; i ShortDescription(false));
 }
 }
 }
 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  const wchar_t* psz_layer_name = L"Default"; ;
  int layer_index = context.m_doc.m_layer_table.FindLayerFromFullPathName(psz_layer_name, ON_UNSET_INT_INDEX);
  if (layer_index >= 0 && layer_index < context.m_doc.m_layer_table.LayerCount())
  {
    const CRhinoLayer& layer = context.m_doc.m_layer_table[layer_index];
    ON_SimpleArray<CRhinoObject*> objects;
    int object_count = context.m_doc.LookupObject(layer, objects);
    if (object_count > 0)
    {
      RhinoApp().Print(L"%s layer object(s)s:\n", psz_layer_name);
      for (int i = 0; i < object_count; i++)
      {
        const CRhinoObject* object = objects[i];
        if (object)
          RhinoApp().Print(L"  %s\n", object->ShortDescription(false));
      }
    }
  }
...

GUIDES / CPP / GETTING-OBJECT-UUID
------------------------------------------------------------

Index
Source: guides\cpp\getting-object-uuid\index.md
Overview

Rhino can create and manipulate many geometric objects, including points, point clouds, curves, surfaces, Breps, extrusions, subds, meshes, lights, annotations and more.

A universally unique identifier, or UUID, is assigned to each object in the Rhino document when the objects are created. The object's UUID uniquely identifies the object.

Because UUIDs are saved in the 3DM file, an object's unique identifier will persist between editing sessions.

Sample

The following code sample demonstrates how to obtain an object's unique identifier, or UUID, using C/C++:


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 CRhinoGetObject go;
 go.SetCommandPrompt(L"Select object");
 go.GetObjects(1, 1);
 if (go.CommandResult() != CRhinoCommand::success)
 return go.CommandResult();

 const CRhinoObjRef& ref = go.Object(0);
 const CRhinoObject* obj = ref.Object();
 if (nullptr == obj)
 return CRhinoCommand::failure;

 ONUUID uuid = obj->ModelObjectId();
 ONwString str;
 ON_UuidToString(uuid, str);
 RhinoApp().Print(L"The object's unique identifier is \"%s\".\n", str);

 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetObject go;
  go.SetCommandPrompt(L"Select object");
  go.GetObjects(1, 1);
  if (go.CommandResult() != CRhinoCommand::success)
    return go.CommandResult();

  const CRhinoObjRef& ref = go.Object(0);
  const CRhinoObject* obj = ref.Object();
  if (nullptr == obj)
    return CRhinoCommand::failure;

  ON_UUID uuid = obj->ModelObjectId();
  ON_wString str;
  ON_UuidToString(uuid, str);
  RhinoApp().Print(L"The object's unique identifier is \"%s\".\n", str);

  return CRhinoCommand::success;
}
...

GUIDES / CPP / GETTING-SCRIPT-ADDED-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\getting-script-added-objects\index.md
Problem

You have a command, derived from CRhinoScriptCommand, that scripts several Rhino command that add objects. After running the scripts, with CRhinoApp::RunScript, you would like to get the addresses, or pointers, of the added objects. But the commands that create the new objects do not select then. Is there a way to get the added objects' addresses in this case?

Solution

See of the following sample gives you any ideas...


static int CompareObjectPtr( const CRhinoObject const a, const CRhinoObject const b )
{
 INTPTR d = (a) - (b);
 return ( (d 0) ? 1 : 0 ) );
}

CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Disable redrawing
 CRhinoView::EnableDrawing( FALSE );

 // Get the next runtime object serial number before scripting
 unsigned int firstsn = CRhinoObject::NextRuntimeObjectSerialNumber();

 // Do some scripting...
 RhinoApp().RunScript( L"-Line 0,0,0 10,10,0", 0 );
 RhinoApp().RunScript( L"SelLast", 0 );
 RhinoApp().RunScript( L"-Properties Object Color Object 255,0,0 Enter Enter", 0 );
 RhinoApp().RunScript( L"-Circle 0,0,0 10", 0 );
 RhinoApp().RunScript( L"SelLast", 0 );
 RhinoApp().RunScript( L"-Properties Object Color Object 0,0,255 Enter Enter", 0 );

 // Get the next runtime object serial number after scripting
 unsigned int nextsn = CRhinoObject::NextRuntimeObjectSerialNumber();

 // Enable redrawing
 CRhinoView::EnableDrawing( TRUE );

 // if the two are the same, then nothing happened
 if( firstsn == nextsn )
 return CRhinoCommand::nothing;

 // The the pointers of all of the objects that were added during scripting
 ONSimpleArray objects;
 for( unsigned int sn = firstsn; sn IsDeleted() )
 objects.Append( obj );
 }

 // Sort and cull the list, as there may be duplicates
 if( objects.Count() > 1 )
 {
 objects.HeapSort( CompareObjectPtr );
 const CRhinoObject lastobj = objects[objects.Count()-1];
 for( int i = objects.Count()-2; i >= 0; i-- )
 {
 const CRhinoObject prevobj = objects[i];
 if( l... [truncated]

Essential Code:
static int CompareObjectPtr( const CRhinoObject* const * a, const CRhinoObject* const * b )
{
  INT_PTR d = (*a) - (*b);
  return ( (d < 0) ? -1 : ( (d > 0) ? 1 : 0 ) );
}

CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Disable redrawing
  CRhinoView::EnableDrawing( FALSE );

  // Get the next runtime object serial number before scripting
  unsigned int first_sn = CRhinoObject::NextRuntimeObjectSerialNumber();

  // Do some scripting...
  RhinoApp().RunScript( L"_-Line 0,0,0 10,10,0", 0 );
  RhinoApp().RunScript( L"_SelLast", 0 );
  RhinoApp().RunScript( L"_-Properties _Object _Color _Object 255,0,0 _Enter _Enter", 0 );
  RhinoApp().RunScript( L"_-Circle 0,0,0 10", 0 );
  RhinoApp().RunScript( L"_SelLast", 0 );
...

GUIDES / CPP / GETTING-UNITS-OF-ACTIVE-DOCUMENT
------------------------------------------------------------

Index
Source: guides\cpp\getting-units-of-active-document\index.md
Overview

There are two unit systems associated with a document, model and page units. The ONUnitSystem class makes it easy to work with custom units. The Rhino document class contains two functions to return these unit systems:
const ONUnitSystem& CRhinoDoc::ModelUnits() const;
const ONUnitSystem& CRhinoDoc::PageUnits() const;

More information

The unit system of the active document is stored on an ON3dmUnitsAndTolerances class that is located on the CRhinoDoc object.

If you inside of a CRhinoCommand-derived object's RunCommand() member, you can get the current units system as follows:


const CRhinoDocProperties& docprops = context.mdoc.Properties();
const ON3dmUnitsAndTolerances& unitstolerances = docprops.ModelUnitsAndTolerances();
ON::LengthUnitSystem unitssystem = unitstolerances.munitsystem;


As a shortcut, you can do the following:


ON::LengthUnitSystem unitssystem = context.mdoc.UnitSystem();


If you outside of a CRhinoCommand-derived object's RunCommand() member, you can get the current units system as follows:


CRhinoDoc* doc = RhinoApp().ActiveDoc();
if (nullptr != doc)
{
 ON::LengthUnitSystem unitssystem = doc->UnitSystem();
}


GUIDES / CPP / HANDLING-ENTER-ESC-FROM-MODAL-DIALOGS
------------------------------------------------------------

Index
Source: guides\cpp\handling-enter-esc-from-modal-dialogs\index.md
Problem

The problem is simple: how to stop my MFC modal dialog box from closing when the user presses the Enter or Escape keys?

Solution

The first step is to, on your CDialog-drived class, override the CWnd::PreTranslateMessage virtual function. This function is used translate window messages before they are dispatched to the TranslateMessage and DispatchMessage Windows functions. Then, add the following block of code:


BOOL CMyModalDialog::PreTranslateMessage( MSG* pMsg )
{
 if( pMsg )
 {
 if( pMsg->message == WMKEYDOWN )
 {
 if( pMsg->wParam == VKRETURN pMsg->wParam == VK_ESCAPE )
 pMsg->wParam = NULL;
 }
 }
 // Call the base class PreTranslateMessage. In this example,
 // CRhinoDialog is the base class to CMyModalDialog.
 return CRhinoDialog::PreTranslateMessage( pMsg );
}


Essential Code:
BOOL CMyModalDialog::PreTranslateMessage( MSG* pMsg )
{
  if( pMsg )
  {
    if( pMsg->message == WM_KEYDOWN )
    {
      if( pMsg->wParam == VK_RETURN | pMsg->wParam == VK_ESCAPE )
        pMsg->wParam = NULL;
    }
  }
  // Call the base class PreTranslateMessage. In this example,
  // CRhinoDialog is the base class to CMyModalDialog.
  return CRhinoDialog::PreTranslateMessage( pMsg );
}


GUIDES / CPP / HIGHLIGHTING-OBJECTS-IN-CONDUITS
------------------------------------------------------------

Index
Source: guides\cpp\highlighting-objects-in-conduits\index.md
Problem

You need to highlight a curve object on display conduit.

Solution

Consider the following sample CRhinoDisplayConduit derived class:


class CTestHighlightCurveConduit : public CRhinoDisplayConduit
{
public:
 CTestHighlightCurveConduit();

 bool ExecConduit(
 CRhinoDisplayPipeline& dp,
 UINT nChannel,
 bool& bTerminate
 );

public:
 unsigned int mruntimeobjectserialnumber;
};

CTestHighlightCurveConduit::CTestHighlightCurveConduit()
: CRhinoDisplayConduit( CSupportChannels::SCDRAWOBJECT )
{
 // TODO: initialize members here
}

bool CTestHighlightCurveConduit::ExecConduit(
 CRhinoDisplayPipeline& dp,
 UINT nChannel,
 bool& bTerminate
 )
{
 switch( nChannel )
 {
 case CSupportChannels::SCDRAWOBJECT:
 {
 if( mpChannelAttrs->mpObject->mruntimeobjectserialnumber == mruntimeobjectserialnumber )
 mpDisplayAttrs->mObjectColor = RGB(255, 105, 180); // hot pink
 }
 break;
 }

 return true;
}


During the SCDRAWOBJECT channel, the code looks for the target object. If found, it overrides the object's drawing color.

To use this conduit, you could write a command such as this:


CRhinoCommand::result CCommandTestHighlightCurve::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curve to highlight" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 const CRhinoObject* obj = go.Object(0).Object();
 if( 0 == obj )
 return CRhinoCommand::failure;

 CTestHighlightCurveConduit conduit;
 conduit.mruntimeobjectserialnumber = obj->mruntimeobjectserialnumber;
 conduit.Enable();
 context.mdoc.Redraw();

 CRhinoGetString gs;
 gs.SetCommandPrompt( L"Press to continue" );
 gs.GetString();

 conduit.Disable();
 context.mdoc.Redraw();

 return CRhinoCommand::success;
}


Essential Code:
class CTestHighlightCurveConduit : public CRhinoDisplayConduit
{
public:
  CTestHighlightCurveConduit();

  bool ExecConduit(
    CRhinoDisplayPipeline& dp,
    UINT nChannel,
    bool& bTerminate
    );

public:
  unsigned int m_runtime_object_serial_number;
};

CTestHighlightCurveConduit::CTestHighlightCurveConduit()
: CRhinoDisplayConduit( CSupportChannels::SC_DRAWOBJECT )
{
  // TODO: initialize members here
}
...
CRhinoCommand::result CCommandTestHighlightCurve::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curve to highlight" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  const CRhinoObject* obj = go.Object(0).Object();
  if( 0 == obj )
    return CRhinoCommand::failure;

  CTestHighlightCurveConduit conduit;
  conduit.m_runtime_object_serial_number = obj->m_runtime_object_serial_number;
  conduit.Enable();
  context.m_doc.Redraw();

  CRhinoGetString gs;
  gs.SetCommandPrompt( L"Press <Enter> to continue" );
...

GUIDES / CPP / INSTALLING-TOOLS-WINDOWS
------------------------------------------------------------

Index
Source: guides\cpp\installing-tools-windows\index.md
By the end of this guide, you should have all the tools installed necessary for authoring, building, and debugging C/C++ plugins using the Rhino C/C++ SDK on Windows.

Prerequisites

This guide presumes you have:

Rhino 8
A PC running Microsoft Windows 10 or later.
Rhino 8 for Windows.

Rhino 7
A PC running Microsoft Windows 8.1 or later.
Rhino 7 for Windows.

Install Visual Studio

Rhino 8

To write C++ plugins for Rhino 8 using the Rhino 8 C/C++ SDK, you will need a version of Microsoft Visual Studio that includes the Visual Studio 2019 (v142) platform toolset. Thus, you can use either Visual Studio 2022 or Visual Studio 2019.
Download Microsoft Visual Studio, either Visual Studio 2022 or Visual Studio 2019.
Run the Visual Studio installer you just downloaded.

 !Visual Studio Install
Follow the onscreen prompts to install Visual Studio.
Check the Desktop development with C++ workload.
Click the Individual components tab.
Scroll to the Compilers, build tools, and runtimes section and check the following option:
MSVC v142 - VS 2019 C++ x64/x86 build tools
Scroll to the SDKs, libraries, and frameworks section and check the following options:
C++ v14.2 ATL for v142 build tools (x86 & x64)
C++ v14.2 MFC for v142 build tools (x86 & x64)
Windows 10 SDK
Check any additional features required for your project.
When finished, click Install.
Depending on your internet connection, this can take several minutes to complete.

If you already have Microsoft Visual Studio 2022 or 2019 installed, then you will want to re-run the Visual Studio Installer and verify you have all the the components installed.

Rhino 7

To write C++ plugins for Rhino 7 using the Rhino 7 C/C++ SDK, you will need Microsoft Visual Studio 2019.
Download Visual Studio 2019.
Run the Visual Studio installer you just downloaded.

 !Visual Studio Install
Follow the onscreen prompts to install Visual Studio.
Check the Desktop development with C++ workload.
Click the Individual components tab.
Scroll to the SDKs,... [truncated]

GUIDES / CPP / ITERATING-GEOMETRY-TABLE
------------------------------------------------------------

Index
Source: guides\cpp\iterating-geometry-table\index.md
Overview

The CRhinoGetObject class is useful when you need the user to interactively pick one or more objects. But, it is not too useful if you need to walk through the entire document looking for objects. This is where the CRhinoObjectIterator class comes in.

The CRhinoObjectIterator class is used to iterate through the objects in a CRhinoDoc object. You can limit the iteration by specifying one of five mutually exclusive object states and one of three mutually exclusive object categories.

Sample


CRhinoCommand::result CCommandTestIterator::RunCommand(
 const CRhinoCommandContext& context )
{
 CRhinoObjectIterator it(
 CRhinoObjectIterator::undeletedobjects,
 CRhinoObjectIterator::activeandreferenceobjects
 );
 it.IncludeLights( TRUE );
 it.IncludeGrips( false );
 int count = 0;
 for( CRhinoObject pObject = it.First(); pObject; pObject = it.Next() )
 {
 if( pObject->IsSelected() )
 continue;
 if( !pObject->IsSelectable() )
 continue;
 pObject->Select();
 count++;
 }

 if( count )
 context.m_doc.Redraw();

 ::RhinoApp().Print( L"%d object(s) selected.\n", count );
 return CRhinoCommand::success;
}


h* SDK header file.

Essential Code:
CRhinoCommand::result CCommandTestIterator::RunCommand(
                  const CRhinoCommandContext& context )
{
  CRhinoObjectIterator it(
        CRhinoObjectIterator::undeleted_objects,
        CRhinoObjectIterator::active_and_reference_objects
        );
  it.IncludeLights( TRUE );
  it.IncludeGrips( false );
  int count = 0;
  for( CRhinoObject* pObject = it.First(); pObject; pObject = it.Next() )
  {
    if( pObject->IsSelected() )
      continue;
    if( !pObject->IsSelectable() )
      continue;
    pObject->Select();
    count++;
  }

...

GUIDES / CPP / LICENSE-AGREEMENT
------------------------------------------------------------

Index
Source: guides\cpp\license-agreement\index.md
Rhino C/C++ Software Development Kit (SDK) 

Copyright (c) 1993-2023 Robert McNeel & Associates. All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software.

THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY. ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF MERCHANTABILITY ARE HEREBY DISCLAIMED.

Rhinoceros and openNURBS are a registered trademarks of Robert McNeel & Associates.

GUIDES / CPP / LIGHT-ATTENUATION
------------------------------------------------------------

Index
Source: guides\cpp\light-attenuation\index.md
Problem

So you are interested in taking advantage ONLight::Attenuation in your render plugin, and you need to clarify how you can use it. Is the input vector supposed to represent the distance over which you want the light to attenuate to zero?

Solution

Light attenuation determines how fast the light intensity decreases with distance from objects.

The three coefficients to light attenuation are:
Constant attenuation ({{}}$$C$${{}})
Linear attenuation ({{}}$$L$${{}})
Quadratic attenuation ({{}}$$Q$${{}})

Thus, you could create the input vector as follows:


ON3dVector attenuation( C, L, Q );



Types of Attenuation

Constant

If you want constant attenuation, or:

{{}}$$1 \over C$${{}}

then both {{}}$$L$${{}} and {{}}$$Q$${{}} must be {{}}$$0$${{}} and {{}}$$C > 0$${{}} (usually {{}}$$= 1.0$${{}}).

Linear

If you want linear attenuation:

{{}}$$1 \over C + dL$${{}}

where {{}}$$d$${{}} = distance to light, then {{}}$$C$${{}} and {{}}$$L$${{}} vary and {{}}$$Q$${{}} must be {{}}$$0$${{}}.

Quadratic

If you want quadratic attenuation:

{{}}$$1 \over C + dL + d^{2Q}$${{}}

then all 3 coefficients can and should vary.

GUIDES / CPP / LOADING-PLUGINS-AT-STARTUP
------------------------------------------------------------

Index
Source: guides\cpp\loading-plugins-at-startup\index.md
Problem

You would like your plugin to load at Rhino's startup.

Solution

Rhino will load plugins in two ways:
When Needed (Default). Plugin will not be loaded when Rhino starts. Plugin will be loaded when a plugin defined command is run, when a user selects a plugin defined file import/export type, or if a 3DM file has user data that was created by your plugin.
At Startup. Plugin is loaded when Rhino is loaded and initialized.

To set your plugin to load on startup, you need to override your plugin object's CRhinoPlugIn::PlugInLoadTime() virtual function and return the CRhinoPlugIn::loadpluginatstartup enumerated value. See rhinoSdkPlugIn.h for details.

Sample


// Description:
// Called by Rhino when writing plug-in information to the registry. This
// information will be read the next time Rhino starts to identify properly
// installed plug-ins.
CRhinoPlugIn::pluginloadtime CTestPlugIn::PlugInLoadTime()
{
 return CRhinoPlugIn::loadpluginatstartup;
}


Details

If you have already loaded your plugin using Rhino's plugin manager, when debugging for example, then you will need to either remove your plugin's registry key, which can be found here:


HKEYLOCALMACHINE\SOFTWARE\McNeel\Rhinoceros\\\Plug-Ins\


 WARNING
 if you are running on a system with limited rights, with user-account control enabled for example, then there will be a corresponding key in HKEYCURRENTUSER

Or, you can just modify your plugin's "LoadMode" registry key value. The available values for this key are as follows:

 Load mode Registry Value Description 

 loadpluginwhenneeded 2 - REGDWORD, Decimal Default. Load the first time a plugin command used 
 loadpluginatstartup 1 - REGDWORD, Decimal Load when Rhino is loaded 

The reason this step is required is that the "LoadMode" Registry key value is only written the first time the plugin is loaded (when it is initially installed or registered). This will not be an issue for customers of your plugin for the correct registry key value will ... [truncated]

Essential Code:
// Description:
//    Called by Rhino when writing plug-in information to the registry.  This
//    information will be read the next time Rhino starts to identify properly
//    installed plug-ins.
CRhinoPlugIn::plugin_load_time CTestPlugIn::PlugInLoadTime()
{
  return CRhinoPlugIn::load_plugin_at_startup;
}


GUIDES / CPP / LOFTING-SURFACE-THAT-MAINTAIN-TANGENCY
------------------------------------------------------------

Index
Source: guides\cpp\lofting-surface-that-maintain-tangency\index.md
Overview

When trying to loft a surface with starting or ending tangency, it is not enough just to set CArgsRhinoLoft object's mstartcondition and mendcondition members to CArgsRhinoLoft::leTangent. You also need to tell Rhino's lofter what it is that this lofted surface need to be tangent to. You do this by setting the mtrim parameter of the starting and ending CRhinoLoftCurve objects. This is a constant ONBrepTrim pointer. If you are lofting curves that you have picked using a CRhinoGetObject object, you can retrieve this pointer by simply calling CRhinoObjRef::Trim().

Sample

The following sample code demonstrates how to loft surfaces that maintain tangency with adjacent surfaces using the CArgsRhinoLoft class and the RhinoSdkLoftSurface function. The definitions of these are in rhinoSdkLoft.h.

 This is the responsibility of the plugin developer.


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Select curves to loft
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select curves to loft" );
 go.SetGeometryFilter( CRhinoGetObject::curveobject CRhinoGetObject::edgeobject);
 go.SetGeometryAttributeFilter( CRhinoGetObject::opencurve );
 go.EnablePreSelect( false );
 go.GetObjects( 2, 0 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 // Create loft arguments object
 const int objcount = go.ObjectCount();
 CArgsRhinoLoft args;
 args.mloftcurves.SetCapacity( objcount );

 // Add curves to loft arguments object
 int i;
 for( i = 0; i mcurve = crv->DuplicateCurve();
 lc->mcurve->RemoveShortSegments( ONZEROTOLERANCE );

 // Set other loft curve parameters
 lc->mbPlanar = ( lc->mcurve->IsPlanar(&lc->mplane) ? true : false );

 // If referenced geometry is a surface edge,
 // assign associated brep trim.
 lc->mtrim = ref.Trim();

 // Append loft curve to loft argument
 args.mloftcurves.Append( lc );
 }
 }

 // If we do... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Select curves to loft
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select curves to loft" );
  go.SetGeometryFilter( CRhinoGetObject::curve_object | CRhinoGetObject::edge_object);
  go.SetGeometryAttributeFilter( CRhinoGetObject::open_curve );
  go.EnablePreSelect( false );
  go.GetObjects( 2, 0 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  // Create loft arguments object
  const int obj_count = go.ObjectCount();
  CArgsRhinoLoft args;
  args.m_loftcurves.SetCapacity( obj_count );

  // Add curves to loft arguments object
  int i;
  for( i = 0; i < obj_count; i++ )
...

GUIDES / CPP / LOGGING-DEBUG-INFO
------------------------------------------------------------

Index
Source: guides\cpp\logging-debug-info\index.md
Overview

The openNURBS C/C++ SDK, which is also included with the Rhino C/C++ SDK, contains a ONTextLog class that makes it very simple to write, or dump, information to a text file. The class can be very handy when trying to debug geometric objects, for most objects have the ability to dump their contents to a log file.

Sample

The following is an example of using the ONTextLog class to dump the contents of a brep object to a text file. h


CRhinoCommand::result CCommandTest::RunCommand(
 const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select brep" );
 go.SetGeometryFilter(
 CRhinoGetObject::surfaceobject 
 CRhinoGetObject::polysrfobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() == CRhinoCommand::success )
 {
 const ONBrep brep = go.Object(0).Brep();
 if( brep )
 {
 FILE fp = ON::OpenFile( L"c:\\bugreport.txt", L"w" );
 if( fp )
 {
 ONTextLog textlog( fp );
 textlog.Print( L"Dumping Brep...\n" );
 brep->Dump( textlog );
 ON::CloseFile( fp );
 }
 }
 }
 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(
    const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select brep" );
  go.SetGeometryFilter(
       CRhinoGetObject::surface_object |
       CRhinoGetObject::polysrf_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() == CRhinoCommand::success )
  {
    const ON_Brep* brep = go.Object(0).Brep();
    if( brep )
    {
      FILE* fp = ON::OpenFile( L"c:\\bug_report.txt", L"w" );
      if( fp )
      {
        ON_TextLog text_log( fp );
        text_log.Print( L"Dumping Brep...\n" );
        brep->Dump( text_log );
...

GUIDES / CPP / MAKING-PLUGINS-THAT-EXPIRE
------------------------------------------------------------

Index
Source: guides\cpp\making-plugins-that-expire\index.md
Problem

You would like to release a work-in-progress, or WIP, version of your plugin so you can get some customer feedback before shipping. You would like the plugin to expire after a number of days. Is there something in Rhino that could help with this?

Solution

Rhino does not have any feature that can help with this. But, it is not too difficult to compare the compile date of the plugin with the current date to see if you plugin should load or not. The following example code demonstrates this...

Sample


BOOL CTestPlugIn::OnLoadPlugIn()
{
#if defined(WIP)

 // Easy cheezy way of testing to see if plugin has expired.
 COleDateTime compiletime;
 compiletime.ParseDateTime( ONwString(DATE" "TIME), 0, 0x0409 );

 COleDateTime currenttime( COleDateTime::GetCurrentTime() );

 COleDateTimeSpan span = currenttime - compiletime;
 int elapseddays = span.GetDays();

 const int warnafterdays = 30; // or whatever...
 const int expireafterdays = 40; // or whatever...

 if( elapseddays >= warnafterdays )
 {
 HWND hWnd = RhinoApp().MainWnd();
 if( elapseddays >= expireafterdays )
 {
 ONwString str = L"This WIP has expired. Please download the latest and greatest...";
 ::MessageBox( hWnd, str, PlugInName(), MBOK MBICONERROR );
 return -1; // This will cause the plugin not to load and not display an Rhino error.
 }
 else
 {
 ONwString str;
 str.Format( L"This WIP will expire in %d days. Please download the latest and greatest...", expireafterdays - elapseddays );
 ::MessageBox( hWnd, str, PlugInName(), MBOK MBICONEXCLAMATION );
 }
 }
#endif

 // If we got here, then the WIP was good.
 // So, do other plugin initialization
 // and return TRUE to run.

 return TRUE;
}


Essential Code:
BOOL CTestPlugIn::OnLoadPlugIn()
{
#if defined(WIP)

  // Easy cheezy way of testing to see if plugin has expired.
  COleDateTime compile_time;
  compile_time.ParseDateTime( ON_wString(__DATE__" "__TIME__), 0, 0x0409 );

  COleDateTime current_time( COleDateTime::GetCurrentTime() );

  COleDateTimeSpan span = current_time - compile_time;
  int elapsed_days = span.GetDays();

  const int warn_after_days = 30;   // or whatever...
  const int expire_after_days = 40; // or whatever...

  if( elapsed_days >= warn_after_days )
  {
    HWND hWnd = RhinoApp().MainWnd();
    if( elapsed_days >= expire_after_days )
...

GUIDES / CPP / MESH-TYPES
------------------------------------------------------------

Index
Source: guides\cpp\mesh-types\index.md
Which Mesh?

There is an ONBrep::GetMeshes() routine of the C/C++ SDK. You might find that very adequate meshes can be pulled from this routine when specifying ON::rendermesh. You may have also noticed that you can also run this routine with an enumeration for an "analysis mesh," a "default mesh," a "preview mesh," or "any mesh."

What are the differences between all of these options?

Discussion

Here is an overview of the mesh types:
ON::rendermesh is a mesh for, obviously, rendering. This rendering can be for shaded or rendered display. It can also be used by rendering plugins. The quality of these meshes is controlled by the Meshes page in the Document Properties dialog, but can also be overridden on a per-object basis.
ON::analysismesh is used by analysis modes, such as curvature, draft angle, environment map, and zebra.
ON::previewmesh is used when you use the Mesh command and poke the preview button - the pipeline needs a way to display preview meshes and this is it.
ON::default mesh returns ON::rendermesh if it exists. Otherwise it returns ON::analysismesh if it exists.
ON::anymesh is only used when we want delete all meshes at one time.

 Some command must trigger their creation, whether its just setting viewport for rendered display or running an analysis command. The can also be generated from plugins that call SDK functions.

GUIDES / CPP / MIGRATE-PROPERTIES-PAGES-WINDOWS
------------------------------------------------------------

Index
Source: guides\cpp\migrate-properties-pages-windows\index.md
You can find instructions regarding migrating your Rhino 5 plugin project to Rhino 6 here.

The code used in this document is available on GitHub here.

Migrating CRhinoPlugIn derived class

The Rhino 5 CRhinoPlugIn class includes AddPagesToObjectPropertiesDialog, AddPagesToOptionsDialog and AddPagesToDocumentPropertiesDialog virtual methods which may be overridden when adding custom pages to the Options, Document Properties and Object Properties dialogs. These methods have been modified in Rhino 6 and will require changes to your derived plug-in classes.

Rhino 5 code


void CSamplePropertiesPagesPlugIn::AddPagesToObjectPropertiesDialog(
 ONSimpleArray& pages)
{
 pages.Append(&mpropertiespage);
}

void CSamplePropertiesPagesPlugIn::AddPagesToOptionsDialog(
 HWND hwndParent,
 ONSimpleArray& pages)
{
 pages.Append(new COptionsPage());
}

void CSamplePropertiesPagesPlugIn::AddPagesToDocumentPropertiesDialog(
 CRhinoDoc& doc,
 HWND hwndParent,
 ONSimpleArray& pages)
{
 pages.Append(new CDocumentPropertiesPage(doc));
}


Rhino 6 code


void CSamplePropertiesPagesPlugIn::AddPagesToObjectPropertiesDialog(
 CRhinoPropertiesPanelPageCollection& collection)
{
 collection.Add(&mpropertiespage);
}

void CSamplePropertiesPagesPlugIn::AddPagesToOptionsDialog(
 CRhinoOptionsPageCollection& collection)
{
 collection.AddPage(new COptionsPage());
}

void CSamplePropertiesPagesPlugIn::AddPagesToDocumentPropertiesDialog(
 CRhinoOptionsPageCollection& collection)
{
 collection.AddPage(new CDocumentPropertiesPage());
}


Migrating CRhinoOptionsDialogPage derived pages

The CRhinoOptionsDialogPage class is used to add pages to both the Options and Document Properties dialog sections. The following is a description of what has changed in the Rhino 6 SDK and some simple examples of how to migrate your existing Rhino 5 code.

Virtual method changes

Several virtual methods in the CRhinoOptionsDialogPage and the CRhinoStackedDialogPage base class have changed in Rhino 6. The following i... [truncated]

Essential Code:
void CSamplePropertiesPagesPlugIn::AddPagesToObjectPropertiesDialog(
  ON_SimpleArray<class CRhinoObjectPropertiesDialogPage*>& pages)
{
  pages.Append(&m_properties_page);
}

void CSamplePropertiesPagesPlugIn::AddPagesToOptionsDialog(
  HWND hwndParent,
  ON_SimpleArray<CRhinoOptionsDialogPage*>& pages)
{
  pages.Append(new COptionsPage());
}

void CSamplePropertiesPagesPlugIn::AddPagesToDocumentPropertiesDialog(
  CRhinoDoc& doc,
  HWND hwndParent,
  ON_SimpleArray<CRhinoOptionsDialogPage*>& pages)
{
  pages.Append(new CDocumentPropertiesPage(doc));
}
...
void CSamplePropertiesPagesPlugIn::AddPagesToObjectPropertiesDialog(
  CRhinoPropertiesPanelPageCollection& collection)
{
  collection.Add(&m_properties_page);
}

void CSamplePropertiesPagesPlugIn::AddPagesToOptionsDialog(
  CRhinoOptionsPageCollection& collection)
{
  collection.AddPage(new COptionsPage());
}

void CSamplePropertiesPagesPlugIn::AddPagesToDocumentPropertiesDialog(
  CRhinoOptionsPageCollection& collection)
{
  collection.AddPage(new CDocumentPropertiesPage());
}


GUIDES / CPP / MIGRATE-YOUR-PLUGIN-MANUAL-WINDOWS
------------------------------------------------------------

Index
Source: guides\cpp\migrate-your-plugin-manual-windows\index.md
It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows).

Migrate the project
Launch Visual Studio 2017 and click File > Open > Project/Solution....
Navigate to your project's folder and open either your plugin project (.vcxproj) or solution (.sln)
When your plugin project opens, navigate to the project's setting by clicking Project > Properties....
In the project's settings, set the Configuration to All Configurations, and set the platform to x64.
Then, set the Platform Toolset to Visual Studio 2017 (v141) and the click Apply.
 !Plugin Settings

Remove 32-bit support

Rhino 6 plugins are 64-bit only. If your plugin project has Win32 platform support, then it is safe to remove it using Visual Studio’s Configuration Manager.
From Visual Studio 2017, click Build > Configuration Manager....
 !Configuration Manager
In Project Contexts, click Platform > Edit....
 !Select Project Platforms
In Edit Project Platforms, select the Win32 platform, click Remove and then click Close.
 !Edit Project Platforms
Repeat the above step for the solution by click Active solution platform > Edit....
In Edit Solution Platforms, select the Win32 platform, click Remove and then click Close.

Rename build configurations

Rhino 6 plugin projects have different project build configuration names. In order to use the new SDK Property Sheets, you will need to rename the plugin project's build configurations so they match the new build configuration names.
In Project Contexts, click Configuration > Edit....
 !Select Project Configurations
In Edit Project Configurations, remove the Debug configuration.
And then, rename the PseudoDebug configuration to Debug.
 !Edit Project Configurations
When you have finished renaming the configurations, click Close.
 !Rename Project Configurations
Repeat the above step for the solution by click Active solution Configuration > Edit....
In Edit Solution Configurations, remove the De... [truncated]

GUIDES / CPP / MIGRATE-YOUR-PLUGIN-WINDOWS
------------------------------------------------------------

Index
Source: guides\cpp\migrate-your-plugin-windows\index.md
Prerequisites

It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows)

Migrate the project

To migrate your Rhino 6 C++ plugin project to Rhino 7:
Launch Visual Studio 2019 and click File > Open > Project/Solution....
Navigate to your project's folder and open either your plugin project (.vcxproj) or solution (.sln)
When your plugin project opens, Visual Studio will display the Retarget Projects dialog box. Specify the following actions and then click OK. 
 !Retarget Projects

Replace property sheets

The Rhino C/C++ SDK includes Visual Studio Property Sheets that provide a convenient way to synchronize or share common settings among other plugin projects. You will need to remove references to Rhino 6 C/C++ SDK property sheets and replace them with references to Rhino 7 C/C++ SDK property sheets.
From Visual Studio 2019, click View > Property Manager.
 !Property Manager
Right-click on the Rhino.Cpp.PlugIn property sheets in both Debug &#124; x64 and Release &#124; x64 configurations and click Remove.
Right-click on the Debug &#124; x64 configuration and click Add Existing Property Sheet.
Navigate to the following location: C:\Program Files\Rhino 7.0 SDK\PropertySheets
Select Rhino.Cpp.PlugIn.props and click OK.
Repeat the above steps for the the Release &#124; x64 configuration.
Save the changes to your solution.

Your plugin project should now be ready to build with the Rhino 7 C/C++ SDK.

Related Topics
What's New?

GUIDES / CPP / MIGRATE-YOUR-PLUGIN-WINDOWS-8
------------------------------------------------------------

Index
Source: guides\cpp\migrate-your-plugin-windows-8\index.md
Prerequisites

It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows)

Migrate the project

To migrate your Rhino 7 C++ plugin project to Rhino 8:
Launch Visual Studio and click File > Open > Project/Solution....
Navigate to your project's folder and open either your plugin project (.vcxproj) or solution (.sln)
When your plugin project opens, Visual Studio may display the Retarget Projects dialog box. Just click Cancel. 

 !Retarget Projects

Replace property sheets

The Rhino C/C++ SDK includes Visual Studio Property Sheets that provide a convenient way to synchronize or share common settings among other plugin projects. You will need to remove references to Rhino 7 C/C++ SDK property sheets and replace them with references to Rhino 8 C/C++ SDK property sheets.
From Visual Studio, click View > Property Manager.

 !Property Manager
Right-click on the Rhino.Cpp.PlugIn property sheets in both Debug &#124; x64 and Release &#124; x64 configurations and click Remove.
Right-click on the Debug &#124; x64 configuration and click Add Existing Property Sheet.
Navigate to the following location: C:\Program Files\Rhino 8.0 SDK\PropertySheets
Select Rhino.Cpp.PlugIn.props and click OK.
Repeat the above steps for the the Release &#124; x64 configuration.
Save the changes to your solution.

Your plugin project should now be ready to build with the Rhino 8 C/C++ SDK.

Related Topics
What's New?

GUIDES / CPP / MODIFYING-ADVANCED-DISPLAY-SETTINGS
------------------------------------------------------------

Index
Source: guides\cpp\modifying-advanced-display-settings\index.md
Overview

The advanced display features in Rhino give the user almost unlimited control over how objects appear on the screen. All of these features are also exposed to the C/C++ developer.

Rhino maintains advanced display settings using the CDisplayPipelineAttributes class. Rhino will maintain a number of these objects, one for each advanced display setting created by the user (i.e. Wireframe, Shaded, Rendered, Ghosted, X-Ray, etc.) or by 3rd party plugins.

The C/C++ developer can gain access to these objects using the Display Attributes Manager, which is implemented as a number of static functions found on the CRhinoDisplayAttrsMgr class.

The process for updating advanced display settings is similar to updating or modifying other objects in Rhino.
Make a copy of the original.
Modify one or more setting or parameters.
Replace the original object with the modified copy.

Sample


// The following example code demonstrates how to modify advanced display settings using
// the Rhino SDK. In this example, a display mode's mesh wireframe thickness (in pixels)
// will be modified.
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Use the display attributes manager to build a list of display modes.
 // Note, these are copies of the originals...
 DisplayAttrsMgrList attrslist;
 int attrscount = CRhinoDisplayAttrsMgr::GetDisplayAttrsList( attrslist );
 if( attrscount == 0 )
 return failure;

 // Construct an options picker so the user can pick which
 // display mode they want modified
 CRhinoGetOption go;
 go.SetCommandPrompt( L"Display mode to modify mesh thickness" );

 ONSimpleArray optlist( attrscount );
 optlist.SetCount( attrscount );

 for( int i = 0; i EnglishName();
 englishname.Remove( L'' );
 englishname.Remove( L' ' );
 englishname.Remove( L'-' );
 englishname.Remove( L',' );
 englishname.Remove( L'.' );

 // Get the display attributes localized name
 ONwString localname = attrslist[i].mpAttrs->LocalName();
 local... [truncated]

Essential Code:
// The following example code demonstrates how to modify advanced display settings using
// the Rhino SDK. In this example, a display mode's mesh wireframe thickness (in pixels)
// will be modified.
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Use the display attributes manager to build a list of display modes.
  // Note, these are copies of the originals...
  DisplayAttrsMgrList attrs_list;
  int attrs_count = CRhinoDisplayAttrsMgr::GetDisplayAttrsList( attrs_list );
  if( attrs_count == 0 )
    return failure;

  // Construct an options picker so the user can pick which
  // display mode they want modified
  CRhinoGetOption go;
  go.SetCommandPrompt( L"Display mode to modify mesh thickness" );

  ON_SimpleArray<int> opt_list( attrs_count );
  opt_list.SetCount( attrs_count );

...

GUIDES / CPP / MODIFYING-AN-OBJECTS-COLOR
------------------------------------------------------------

Index
Source: guides\cpp\modifying-an-objects-color\index.md
Overview

The color used to display an object is specified in one of four ways...
ON::colorfromlayer - the object's layer color, ONLayer::Color(), determines the object's color. This is the default method used when adding new objects to Rhino
ON::colorfromobject - the value of an object's mcolor attribute determines the object's color.
ON::colorfrommaterial - the diffuse color of the object's render material determines the object's color.
ON::colorfromparent - if the object is part of an instance reference, the color is taken from the instance

Sample

The following code sample demonstrates how to override the default "color by layer" behavior and set an object to use "color by object."


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select object" );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 const CRhinoObjRef& objref = go.Object( 0 );
 const CRhinoObject* obj = objref.Object();
 if( !obj )
 return CRhinoCommand::failure;

 ONColor oldcolor = obj->Attributes().DrawColor();
 ON::objectcolorsource colorsource = obj->Attributes().ColorSource();
 ONColor newcolor( oldcolor );

 if( !RhinoColorDialog( ::RhinoApp().MainWnd(), newcolor) )
 return CRhinoCommand::cancel;

 if( newcolor == oldcolor )
 return CRhinoCommand::nothing;

 CRhinoObjectAttributes att( obj->Attributes() );
 att.mcolor = newcolor;
 att.SetColorSource( ON::colorfromobject );
 context.mdoc.ModifyObjectAttributes( objref, att );
 context.mdoc.Redraw();
 return CRhinoCommand::success;
}


When adding new objects using the C/C++ SDK, you can specify the attributes of the object when adding it to Rhino. Thus, if you want to override the default color behavior for new objects, just get a copy of the active document's default new object attributes, modify it in whatever way you want, and pass it (along with the geometry) to the appropriate object creation ... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select object" );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  const CRhinoObjRef& obj_ref = go.Object( 0 );
  const CRhinoObject* obj = obj_ref.Object();
  if( !obj )
    return CRhinoCommand::failure;

  ON_Color old_color = obj->Attributes().DrawColor();
  ON::object_color_source color_source = obj->Attributes().ColorSource();
  ON_Color new_color( old_color );

  if( !RhinoColorDialog( ::RhinoApp().MainWnd(), new_color) )
    return CRhinoCommand::cancel;

...
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  ON_Circle circle;
  circle.Create( RhinoActiveCPlane(), 5.0 );
  ON_3dmObjectAttributes att;
  context.m_doc.GetDefaultObjectAttributes( att );

  att.m_color = RGB(255,191,191);
  att.SetColorSource( ON::color_from_object );
  context.m_doc.AddCurveObject( circle, &att );
  context.m_doc.Redraw();
  return CRhinoCommand::success;
}


GUIDES / CPP / MODIFYING-LIGHT-COLORS
------------------------------------------------------------

Index
Source: guides\cpp\modifying-light-colors\index.md
Overview

The process for modifying a light object is slightly different than the process for modifying other geometric objects, such as points, curves, and surfaces. This is because light objects are stored in a different location in the Rhino document.

How To

Light objects are stored in a CRhinoLightTable object that is held by the active document object. Thus, instead of using one of the ModifyObject() members found on CRhinoDoc, you need to use the ModifyLight() member found on CRhinoLightTable in order to modify an existing light object.

For more details on CRhinoLight and CRhinoLightTable, see rhinoSdkLight.h included with the C/C++ SDK.

Sample

The following example demonstrates how to modify the diffuse color of a light object...


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Pick an existing light object
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select light to change color" );
 go.SetGeometryFilter( CRhinoGetObject::lightobject );
 go.GetObjects( 1, 1 );
 if( go.CommandResult() != CRhinoCommand::success )
 return go.CommandResult();

 // The the light object
 CRhinoObjRef& ref = go.Object(0);
 const CRhinoLight* lightobj = CRhinoLight::Cast( ref.Object() );
 if( !lightobj )
 return CRhinoCommand::failure;

 // Prompt the user to pick a new color
 ONColor color = lightobj->Light().Diffuse();
 if( !RhinoColorDialog(RhinoApp().MainWnd(), color) )
 CRhinoCommand::cancel;

 // Copy the light object's underlying ONLight
 ONLight light( lightobj->Light() );
 // Modify the diffuse color
 light.SetDiffuse( color );

 // Modify the light
 CRhinoLightTable& lighttable = context.mdoc.mlighttable;
 lighttable.ModifyLight( light, lightobj->LightIndex() );

 return CRhinoCommand::success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Pick an existing light object
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select light to change color" );
  go.SetGeometryFilter( CRhinoGetObject::light_object );
  go.GetObjects( 1, 1 );
  if( go.CommandResult() != CRhinoCommand::success )
    return go.CommandResult();

  // The the light object
  CRhinoObjRef& ref = go.Object(0);
  const CRhinoLight* light_obj = CRhinoLight::Cast( ref.Object() );
  if( !light_obj )
    return CRhinoCommand::failure;

  // Prompt the user to pick a new color
  ON_Color color = light_obj->Light().Diffuse();
  if( !RhinoColorDialog(RhinoApp().MainWnd(), color) )
    CRhinoCommand::cancel;
...

GUIDES / CPP / MOVING-CURVE-AND-SURFACE-GRIPS
------------------------------------------------------------

Index
Source: guides\cpp\moving-curve-and-surface-grips\index.md
Problem

You would like to move the control points of a curve or surface object using the Rhino C/C++ SDK.

Solution

The curve and surface grips you see on the screen, after running Rhino's PointsOn command, are represented by CRhinoGripObject-derived objects. To move a grip object, you have to do a few things:
Get a CRhinoGripObject. You can use a CRhinoGetObject object to do this.
Call CRhinoGripObject::MoveGrip to transform the grip's location.
Call CRhinoGripObject::Owner to get the grips owning CRhinoObject object.
Call CRhinoObject::NewObject to create a new CRhinoObject object based on the new grip location.
Call CRhinoDoc::ReplaceObject to replace the original owning object with the new one.

Sample

The following sample code demonstrates this. 



CRhinoCommand::result CCommandMoveGrips::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select grips to move" );
 go.SetGeometryFilter( CRhinoGetObject::gripobject );
 go.GetObjects( 1, 0 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 CRhinoXformObjectList xformlist;
 if( xformlist.AddObjects(go, true) MoveGrip( xform );

 // Replace the old owner with a new one
 for( i = 0; i mgrips->NewObject();
 if( newobject )
 context.mdoc.ReplaceObject( CRhinoObjRef(oldobject), newobject, true );
 }
 }

 context.m_doc.Redraw();
 }

 return success;
}


Essential Code:
CRhinoCommand::result CCommandMoveGrips::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select grips to move" );
  go.SetGeometryFilter( CRhinoGetObject::grip_object );
  go.GetObjects( 1, 0 );
  if( go.CommandResult() != success )
    return go.CommandResult();

  CRhinoXformObjectList xform_list;
  if( xform_list.AddObjects(go, true) < 1 )
    return failure;

  CRhinoGetPoint gp;
  gp.SetCommandPrompt( L"Point to move from" );
  gp.GetPoint();
  if( gp.CommandResult() != success )
    return gp.CommandResult();

  ON_3dPoint from = gp.Point();
...

GUIDES / CPP / MOVING-MESH-VERTICES
------------------------------------------------------------

Index
Source: guides\cpp\moving-mesh-vertices\index.md
Problem

You would like to modify a particular point, or vertex, of CRhinoMeshObject object.

Solution

A CRhinoMeshObject's geometric data member is an ONMesh object. For information on the ONMesh class, the opennurbsmesh.h header file.

Mesh vertices are stored on an ONMesh in an mV data member, which is simply an array of points. So, if you want to modify the vertices of a mesh, you need to modify the data in this array.

In order to modify anything in Rhino, you might:
Get the object.
Make a copy of the object.
Modify this copied object.
Call one of the CRhinoDoc::ReplaceObject overrides to update the object.

Sample

The following sample demonstrates how you might do this from a command...


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject gv;
 gv.SetCommandPrompt( L"Select mesh vertex to move" );
 gv.SetGeometryFilter( CRhinoGetObject::meshvertexobject );
 gv.GetObjects( 1, 1 );
 if( gv.CommandResult() != success )
 return gv.CommandResult();

 const CRhinoObject obj = gv.Object(0).Object();
 const ONMeshVertexRef vertex = gv.Object(0).MeshVertex();
 if( 0 == obj 0 == vertex )
 return failure;

 const ONMesh mesh = vertex->mmesh;
 if( 0 == mesh )
 return failure;

 ON3dPoint pt = mesh->mV[vertex->mmeshvi];

 CRhinoGetPoint gp;
 gp.SetCommandPrompt( L"New location" );
 gp.SetBasePoint( pt );
 gp.DrawLineFromPoint( pt, TRUE );
 gp.GetPoint();
 if( gp.CommandResult() != success )
 return gp.CommandResult();

 ONMesh dupemesh( mesh );
 dupemesh.SetVertex( vertex->mmeshvi, gp.Point() );

 // Since we've modified ONMesh.mV array,
 // we need to invalidate a few things so they
 // can be recalculated based on the new data.
 dupemesh.InvalidateVertexBoundingBox();
 dupemesh.InvalidateVertexNormalBoundingBox();
 dupemesh.InvalidateCurvatureStats();
 dupemesh.mFN.SetCount(0);
 dupemesh.mN.SetCount(0);
 dupemesh.ComputeFaceNormals();
 dupemesh.ComputeVertexNormals();
 dupemesh.SetClosed(-1);

 if( dupemesh.IsVa... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject gv;
  gv.SetCommandPrompt( L"Select mesh vertex to move" );
  gv.SetGeometryFilter( CRhinoGetObject::meshvertex_object );
  gv.GetObjects( 1, 1 );
  if( gv.CommandResult() != success )
    return gv.CommandResult();

  const CRhinoObject* obj = gv.Object(0).Object();
  const ON_MeshVertexRef* vertex = gv.Object(0).MeshVertex();
  if( 0 == obj | 0 == vertex )
    return failure;

  const ON_Mesh* mesh = vertex->m_mesh;
  if( 0 == mesh )
   return failure;

  ON_3dPoint pt = mesh->m_V[vertex->m_mesh_vi];

...

GUIDES / CPP / OBJECT-PROPERTIES-PAGE-ICONS
------------------------------------------------------------

Index
Source: guides\cpp\object-properties-page-icons\index.md
Problem

In Rhino, the object properties dialog shows a list of icons that allows you to select between the available properties pages. You would like to add a custom icon to the object properties dialog when your plugin adds a custom page.

Solution

Derive your custom object properties page from CRhinoObjectPropertiesDialogPageEx, which has a virtual Icon() member that you must override and implement. You will want to implement this virtual function as follows:


HICON CTestObjectPropertiesPageExDlg::Icon() const
{
 AFXMANAGESTATE( AfxGetStaticModuleState() );
 return (HICON)::LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDIOBJPROPPAGEDIALOG), IMAGEICON, 24, 24, LRSHARED);
}


 See MFC Technical Notes 33 and 58 for additional details.

Related Topics
TN033: DLL Version of MFC (on MSDN)
TN058: MFC Module State Implementation (on MSDN)

Essential Code:
HICON CTestObjectPropertiesPageExDlg::Icon() const
{
  AFX_MANAGE_STATE( AfxGetStaticModuleState() );
  return (HICON)::LoadImage(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_OBJPROPPAGE_DIALOG), IMAGE_ICON, 24, 24, LR_SHARED);
}


GUIDES / CPP / OBJECT-TYPES
------------------------------------------------------------

Index
Source: guides\cpp\object-types\index.md
Overview

CRhinoObject is the base class for all runtime Rhino geometric objects. ONGeometry is the base class for all geometry class. All CRhinoObject derived object maintain a ONGeometry derived class as a data member.

The following is an inventory of the geometric objects you are most likely to encounter in Rhino:
CRhinoAnnotationObject - Virtual base class for annotation objects.
ONAnnotation2
CRhinoAngularDimension - Angular dimension.
ONAngularDimension2
CRhinoAnnotationLeader - Annotation leader.
ONLeader2
CRhinoLinearDimension - Linear dimension.
ONLinearDimension2
CRhinoOrdinateDimension - Ordinate dimension.
ONOrdinateDimension2
CRhinoRadialDimension - Radial dimension.
ONRadialDimension2
CRhinoAnnotationText - Annotation text.
ONTextEntity2
CRhinoBrepObject - Surface or polysurface.
ONBrep
CRhinoClippingPlaneObject - Clipping plane.
ONClippingPlane
CRhinoCurveObject - Curve.
ONCurve - Virtual base class for curve objects.
ONArcCurve
ONCurveOnSurface
ONCurveProxy
ONLineCurve
ONNurbsCurve
ONPolyCurve
ONPolylineCurve
CRhinoDetailViewObject - Detail view.
ONDetailView
CRhinoExtrusionObject - Lightweight extrusion
ONExtrusion
CRhinoGripObject - Grip object. Note grip objects are not stored in the document.
ONPoint
CRhinoHatch - Area hatching.
ONHatch
CRhinoInstanceObject - Block instance.
ONInstanceRef
CRhinoLight - Rendering light.
ONLight
CRhinoMeshObject - Polygon mesh.
ONMesh
CRhinoPointCloudObject - Point cloud.
ONPointCloud
CRhinoPointObject - Point.
ONPoint
CRhinoSurfaceObject - Untrimmed surface.
ONSurface
ONNurbsSurface
ONPlaneSurface
ONRevSurface
ONSumSurface
CRhinoTextDot - Text dot.
ONTextDot

GUIDES / CPP / OFFSETTING-CURVES-ON-SURFACES
------------------------------------------------------------

Index
Source: guides\cpp\offsetting-curves-on-surfaces\index.md
Problem

You are using the RhinoOffsetCurveOnSrf function to offset a curve which was interpolated on a cylindrical surface. The problem is that the results do not seem to match those of Rhino's OffsetCrvOnSrf command. That is, the offset curve does not extend to the edges of the surfaces. Why is this?

Solution

After calculating the offset curve, the OffsetCrvOnSrf command extends both ends of that curve to the surface edge using RhinoExtendCrvOnSrf. Below is an sample of how you can do this using the SDK...

Sample


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Select curve on surface
 CRhinoGetObject gc;
 gc.SetCommandPrompt( L"Select curve on surface" );
 gc.SetGeometryFilter( CRhinoGetObject::curveobject );
 gc.GetObjects( 1, 1 );
 if( gc.CommandResult() != CRhinoCommand::success )
 return gc.CommandResult();

 // Validate curve
 const ONCurve crv = gc.Object(0).Curve();
 if( 0 == crv )
 return CRhinoCommand::failure;

 // Select base surface
 CRhinoGetObject gs;
 gs.SetCommandPrompt( L"Select base surface" );
 gs.SetGeometryFilter( CRhinoGetObject::surfaceobject );
 gs.EnablePreSelect( false );
 gs.EnableDeselectAllBeforePostSelect( false );
 gs.GetObjects( 1, 1 );
 if( gs.CommandResult() != CRhinoCommand::success )
 return gs.CommandResult();

 // Validate face
 const ONBrepFace face = gs.Object(0).Face();
 if( 0 == face )
 return CRhinoCommand::failure;

 // Validate brep
 const ONBrep brep = face->Brep();
 if( 0 == brep )
 return CRhinoCommand::failure;

 // Specify offset distance
 CRhinoGetNumber gd;
 gd.SetCommandPrompt( L"Offset distance" );
 gd.SetDefaultNumber( 1.0 );
 gd.GetNumber();
 if( gd.CommandResult() != CRhinoCommand::success )
 return gd.CommandResult();

 double dist = gd.Number();

 // Do offset curve on surface
 double tol = context.mdoc.AbsoluteTolerance();
 ONSimpleArray offsetcurves;
 CRhinoCommand::result cmdrc = RhinoOffsetCurveOnSrf( crv, brep, face->mfaceindex, dist, tol, offsetcu... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Select curve on surface
  CRhinoGetObject gc;
  gc.SetCommandPrompt( L"Select curve on surface" );
  gc.SetGeometryFilter( CRhinoGetObject::curve_object );
  gc.GetObjects( 1, 1 );
  if( gc.CommandResult() != CRhinoCommand::success )
    return gc.CommandResult();

  // Validate curve
  const ON_Curve* crv = gc.Object(0).Curve();
  if( 0 == crv )
    return CRhinoCommand::failure;

  // Select base surface
  CRhinoGetObject gs;
  gs.SetCommandPromp... [compressed]UNDER CONSTRUCTION
 This guide has yet to be written. Please check back soon for updates.

GUIDES / CPP / RDK-RENDER-CONTENT
------------------------------------------------------------

Index
Source: guides\cpp\rdk-render-content\index.md
!Material Environment and Texture

Introduction
Probably the most important object in the Rhino RDK is the Render Content (AKA ‘Content’) object. This object is an abstraction that represents one of three possible ways of describing something that is going to be drawn (rendered) on the screen. There are three kinds of contents: Materials, Environments and Textures. A material describes how a surface will be rendered. It has properties such as color, glossiness, etc. An environment describes how the surroundings of a model affect its appearance. A texture describes the texture of a surface. In addition to color and glossiness, all real-world surfaces have a detailed appearance such as a wood grain. This appearance is described by RDK textures. Objects and layers in the document can have a material assigned to them. This material is usually (but not always) associated with an RDK Material. The Ground Plane can also have such a material assigned to it. As you will see later, render contents are actually a tree hierarchy. The assigned RDK material is always the top-level material which means it has no parent. It can, however, have children.

Classes
The base class for contents is CRhRdkContent. This is an abstraction that controls the features common to all contents. For example, all contents have a unique identifier called the instance id which identifies each instance of CRhRdkContent. They also have a unique type id which defines their type and an instance name which is the user-defined name that appears on the screen. They can also have any number of children which means that a content is usually considered as a hierarchy because these children can also have children to any depth. The hierarchy is therefore a tree structure.

This flexibility allows the user to create very complex materials if so desired. All these properties and more are stored in and managed by the base class called CRhRdkContent. This base class has a single immediate subclass called CRhRdkCoreCo... [truncated]

Essential Code:

  auto* pContent = new CMyMaterial;

  // Initialize the content.
  pContent->Initialize();

  // Edit the content in the Modal Editor. If the user clicks OK, this returns an edited version
  // of the content (the original is unaltered) and you own this object as well as the original one.
  auto* pEdited = pContent->Edit();
  if (nullptr != pEdited) // Returns null if the editor is canceled.
  {
    // Uninitialize the edited content to prepare it for deletion.
    pEdited->Uninitialize();

    // Delete the edited content. This is possible because the content is owned by you.
    delete pEdited;
  }

  // Uninitialize the original content to prepare it for deletion.
  pContent->Uninitialize();
...
class CCarPaintMaterial : public CRhRdkMaterial
{
protected:
	virtual UUID TypeId(void) const override { return _unique_type_id_ }
	virtual UUID PlugInId(void) const override { return _unique_plug_in_id_; }
	virtual UUID RenderEngineId(void) const override { return _unique_render_engine_id_; }
	virtual ON_wString InternalName(void) const override { return L"car-paint-material"; }
	virtual ON_wString TypeName(void) const override { return L"Car Paint"; }
	virtual ON_wString TypeDescription(void) const override { return L"Demo car paint material"; }
};


GUIDES / CPP / RDK-RENDER-CONTENT-EDITORS
------------------------------------------------------------

Index
Source: guides\cpp\rdk-render-content-editors\index.md
The RDK Render Content Editors display objects called Render Contents and allow the user to edit them. These editors are all based on a similar interface with only small functional differences between them. Render Contents are the foundation of the RDK core and one of the most important objects it provides. Please see Render Content  The Texture Editor is known to users as the Texture Palette but programmatically it is an editor just like the other two.

{{}}
Navigation controls similar to those found on a web browser.
Resizeable Floating Previews.
Configurable thumbnails with multiple sizes and styles.
Resizeable preview pane.
User interface for editing render content parameters (AKA fields).
Breadcrumb navigation control similar to those found on file explorers.
Task menu for performing actions on render contents and setting editor options.

These editors are integrated with Rhino's tabbed pane system. You can access them through the Rhino Render menu, the Rendering tool bar, or the editor commands.

Lists of materials, environments, and textures are stored in the Rhino document. Each editor displays the relevant render content type as preview thumbnails.

Contents display an interface below the preview thumbnails in an area reserved for collapsible UI panels. An addition to the basic UI panels, several additional collapsible panels are provided by Rhino within the same area as the content UI. These include the Name, Notes, Texture Summary, Local Mapping, Graph and Adjustment panels.

Each material, environment or texture can have child nodes (AKA child slots or sub-nodes). The children can be of any content type, but specific child slots will only support specific types. The most common child type is a texture. For example, the Color child slot for a Custom Material will only support textures, as will the Background image child slot on a Basic Environment.

GUIDES / CPP / RDK-RENDERING-CLASSES
------------------------------------------------------------

Index
Source: guides\cpp\rdk-rendering-classes\index.md
Introduction
Even before the RDK existed, Rhino had a rendering pipeline and a Render command which would allow the current render engine (e.g., Rhino Render or Flamingo) to render the scene. The RDK builds on and enhances this system to provide the following features:

 An extensible Render Window UI.
 A frame buffer with both built-in and customizable channels.
 An extensible post effect system.
 Exposure and color adjustment controls.
 Asynchronous rendering.

In addition to the built-in functionality, plug-in developers have the ability to add their own UI panes, custom channels, and post effects. The asynchronous rendering feature frees users from being locked out of Rhino while rendering proceeds and actually allows multiple renders to run at the same time using different render engines, if so desired.

The many faces of a render window.
The term render window can be a source of confusion, because there are several different objects in the RDK that could be called by that name:

 The physical render window that the user sees on the screen.
 The data and structures that lie behind the IRhRdkRenderWindow interface.
 The RenderWindow() SDK method (on CRhinoSdkRender and CRhRdkSdkRender).
 The RenderWindow command.

In order to avoid confusion, the physical render window will be called the render frame in this article. Elsewhere, the phrase 'render window' will mean the IRhRdkRenderWindow interface. If the method is mentioned, it will be written in this form: RenderWindow() including the parentheses. The command will be referred to as the RenderWindow command.

Getting started
Let's start at the top and follow the rendering process from the moment the user presses the Render button until the render frame is closed. You must first create a subclass of CRhRdkSdkRender:

class CExampleSdkRender : public CRhRdkSdkRender
{
public:
 CExampleSdkRender(const CRhinoCommandContext& context, CRhinoRenderPlugIn& plugIn,
 bool bPreview, const ONwString& sCaption, UINT uIc... [truncated]

Essential Code:
class CExampleSdkRender : public CRhRdkSdkRender
{
public:
	CExampleSdkRender(const CRhinoCommandContext& context, CRhinoRenderPlugIn& plugIn,
	                  bool bPreview, const ON_wString& sCaption, UINT uIconId);

	virtual CRhinoSdkRender::RenderReturnCodes Render(const ON_2iSize& sizeImage) override;
	virtual CRhinoSdkRender::RenderReturnCodes RenderWindow(CRhinoView* pView,
	                         const LPRECT pRect, bool bInPopupWindow) override;
	...
};

CRhinoCommand::result CExampleRhinoPlugIn::Render(const CRhinoCommandContext& context, bool bPreview)
{
	const auto* pDoc = context.Document();
	if (nullptr == pDoc)
		return CRhinoCommand::failure;

	// If you need to check for a valid license, do that first.
	if (!CheckLicense())
		return CRhinoCommand::failure;

	// Instantiate your SDK Render object.
	CExampleSdkRender sdkRender(context, *this, L"Example", IDI_EXAMPLE, bPreview);

	// Get the size of the image to render.
	const auto size = sdkRender.RenderSize(*pDoc, true);

	// Do the rendering.
	const auto result = sdkRender.Render(size);

	if (CRhinoSdkRender::render_ok == result)
...

GUIDES / CPP / RDK-SAFE-FRAME-CLASSES
------------------------------------------------------------

Index
Source: guides\cpp\rdk-safe-frame-classes\index.md
Introduction
A Safe Frame is a guide to help ensure that the most important elements of a scene will appear inside a certain region of the rendered image. The name comes from movie and TV production where a camera operator sees one or more rectangles in the camera's viewfinder which shows limits inside which an actor or prop is guaranteed to be visible on all viewer's screens.

!SafeFrame

The Document Safe Frame
The RDK Document Safe Frame is a document-resident safe frame which can be displayed in viewports. If you have a Rhino document, you can read and write that document's safe frame through the document's IRhRdkSafeFrame interface. Any changes you make will appear in the Safe Frame UI and will also be stored in the 3dm file. Getting the safe frame from a document always returns a const reference. To write to the safe frame, you must begin a batch of write operations and afterwards end the batch. This is done using the RDK's standard BeginChange / EndChange system. The following is an example of how to access and change the document safe frame:

static class CSafeFrameExampleCommand : public CRhinoTestCommand
{
protected:
 virtual UUID CommandUUID() override { static const UUID uuid = youruuidhere; return uuid; }
 virtual const wchart EnglishCommandName() override { return RHSTRLIT(L"MySafeFrameCmd"); }
 virtual CRhinoCommand::result RunCommand(const CRhinoCommandContext& context) override;
}
theSafeFrameExampleCommand;

CRhinoCommand::result CSafeFrameExampleCommand::RunCommand(const CRhinoCommandContext& context)
{
 auto pDoc = context.Document();
 if (nullptr == pDoc)
 return failure;

 const auto& sf = pDoc->SafeFrame();

 RhinoApp().Print(L"Safe frame before: %s\n", sf.On() ? L"on" : L"off");

 auto& writesf = sf.BeginChange(RhRdkChangeContext::Program);
 writesf.SetOn(false);
 write_sf.EndChange();

 RhinoApp().Print(L"Safe frame after: %s\n", sf.On() ? L"on" : L"off");

 return success;
}


Essential Code:
static class CSafeFrameExampleCommand : public CRhinoTestCommand
{
protected:
	virtual UUID CommandUUID() override { static const UUID uuid = your_uuid_here; return uuid; }
	virtual const wchar_t* EnglishCommandName() override { return RHSTR_LIT(L"MySafeFrameCmd"); }
	virtual CRhinoCommand::result RunCommand(const CRhinoCommandContext& context) override;
}
theSafeFrameExampleCommand;

CRhinoCommand::result CSafeFrameExampleCommand::RunCommand(const CRhinoCommandContext& context)
{
	auto* pDoc = context.Document();
	if (nullptr == pDoc)
		return failure;

	const auto& sf = pDoc->SafeFrame();

	RhinoApp().Print(L"Safe frame before: %s\n", sf.On() ? L"on" : L"off");

	auto& write_sf = sf.BeginChange(RhRdkChangeContext::Program);
...

GUIDES / CPP / RDK-SKYLIGHT-CLASSES
------------------------------------------------------------

Index
Source: guides\cpp\rdk-skylight-classes\index.md
Introduction
The skylight is a feature that allows a scene to be rendered realistically, as if the objects in the scene were in a real environment under a real sky. When the skylight is used, the objects in the scene are lit not only by the scene's lights (or the sun), but also by the environment. The image below shows a comparison of a scene rendered with the skylight disabled (left) and enabled (right). Notice the subtly different coloring and the softer more diffuse shadows in the sky-lit image. The disadvantage of the skylight is that it is very CPU-intensive and renderings are much slower when it is enabled.

!Road

The Document Skylight
The RDK Document Skylight is a document-resident skylight which affects viewports and renderings. If you have a Rhino document, you can read and write that document's skylight through the document's IRhRdkSkylight interface. Any changes you make will appear in the Lighting section of the Rendering panel and will also be stored in the 3dm file. Getting the skylight from a document always returns a const reference. To write to the skylight, you must begin a batch of write operations and afterwards end the batch. This is done using the RDK's standard BeginChange / EndChange system. The following is an example of how to access and change the document skylight:

static class CSkylightExampleCommand : public CRhinoTestCommand
{
protected:
 virtual UUID CommandUUID() override { static const UUID uuid = youruuidhere; return uuid; }
 virtual const wchart EnglishCommandName() override { return RHSTRLIT(L"MySkylightCmd"); }
 virtual CRhinoCommand::result RunCommand(const CRhinoCommandContext& context) override;
}
theSkylightExampleCommand;

CRhinoCommand::result CSkylightExampleCommand::RunCommand(const CRhinoCommandContext& context)
{
 auto pDoc = context.Document();
 if (nullptr == pDoc)
 return failure;

 const auto& sl = pDoc->Skylight();

 RhinoApp().Print(L"Skylight before: %s\n", sl.On() ? L"on" : L"off");

 auto& writesl = sl... [truncated]

Essential Code:
static class CSkylightExampleCommand : public CRhinoTestCommand
{
protected:
	virtual UUID CommandUUID() override { static const UUID uuid = your_uuid_here; return uuid; }
	virtual const wchar_t* EnglishCommandName() override { return RHSTR_LIT(L"MySkylightCmd"); }
	virtual CRhinoCommand::result RunCommand(const CRhinoCommandContext& context) override;
}
theSkylightExampleCommand;

CRhinoCommand::result CSkylightExampleCommand::RunCommand(const CRhinoCommandContext& context)
{
	auto* pDoc = context.Document();
	if (nullptr == pDoc)
		return failure;

	const auto& sl = pDoc->Skylight();

	RhinoApp().Print(L"Skylight before: %s\n", sl.On() ? L"on" : L"off");

	auto& write_sl = sl.BeginChange(RhRdkChangeContext::Program);
...

GUIDES / CPP / RDK-SUN-CLASSES
------------------------------------------------------------

Index
Source: guides\cpp\rdk-sun-classes\index.md
Introduction
The angle and color of sunlight at various times of the day changes drastically with the location on Earth, the time of day and the time of year. When rendering an outdoor scene, the angle and color of the sunlight can be a very important part of the result. Buildings and other objects might be designed and placed to look aesthetically pleasing or have certain highlights at certain times of the day or year. To facilitate this kind of visualization, the RDK provides a comprehensive set of sun tools which allow the plug-in developer to do sun calculations and display a sun user interface.

!Buildings
Costa Mesa, CA., USA ~ Turku Castle, Finland ~ Downtown Austin, TX., USA ~ Photos by John Croudy.

IRhRdkSun

IRhRdkSun is an abstract sun interface. It provides access to all the properties of a sun. It can be used to modify the RDK Document Sun or any temporary 'working' sun you might have access to.

The RDK Document Sun
The RDK Document Sun is a document-resident sun which affects viewports and renderings. If you have a Rhino document, you can read and write that document's sun through the document's IRhRdkSun interface. Any changes you make will appear in the main sun UI and will also be stored in the 3dm file. Getting the sun from a document always returns a const reference. To write to the sun, you must begin a batch of write operations and afterwards end the batch. This is done using the RDK's standard BeginChange / EndChange system:

// Read some information from the document sun.
const auto& sun = pDoc->Sun();
const bool b = sun.EnableOn();
... // Read other properties here.

// Change some properties of the document sun.
auto& writesun = sun.BeginChange(RhRdkChangeContext::Program);
writesun.SetEnableOn(true);
... // Set other properties here.
writesun.EndChange();

CRhRdkSun

CRhRdkSun is a simple sun object that can be placed on the stack or used as a class member. It can be used as a temporary 'working' sun and it provides access to an und... [truncated]

Essential Code:
static class CTestSunEphemeris : public CRhinoTestCommand
{
protected:
	virtual UUID CommandUUID() override { static const UUID uuid = { your_uuid_here } }; return uuid; }
	virtual const wchar_t* EnglishCommandName() override { return RHSTR_LIT(L"SunEphemeris"); }
	virtual CRhinoCommand::result RunCommand(const CRhinoCommandContext& context) override;
}
theTestSunEphemerisCmd;

CRhinoCommand::result CTestSunEphemeris::RunCommand(const CRhinoCommandContext& context)
{
	auto* pDoc = context.Document();
	if (nullptr == pDoc)
		return failure;

	// Make a temporary sun and set some properties.
	CRhRdkSun s;
	auto& sun = s.Sun();
	sun.SetManualControlOn(false);

...
CRhRdkSun s; // Temporary working sun.
auto& sun = s.Sun(); // Get temporary IRhRdkSun.

// You can edit any non-const instance of IRhRdkSun.
CRhRdkSimpleSunDataSource ds;

// Copy working sun data to the data source.
ds.Sun().CopyFrom(sun);

// Set up a controller with this data source attached.
const auto con = IRhinoUiController::make_shared(new CRhRdkGenericController);
con->AddDataSource(ds);

// Launch the dialog using the controller.
CRhRdkSunDialog dlg;
dlg.SetController(con);
if (IDOK != dlg.DoModal())
	return cancel; // User cancelled.

// Copy edited sun data back to the working sun.
...

GUIDES / CPP / RDK-TASK-CLASSES
------------------------------------------------------------

Index
Source: guides\cpp\rdk-task-classes\index.md
Introduction
{{}}
An RDK task encapsulates the functionality of any operation the user can perform by clicking a menu item or pressing a key in a Render Content Editor. For example, when the user right-clicks in the preview area of such an editor, a context menu is displayed with commands such as 'Assign to Objects' and 'Delete'. All of these menu items are implemented by tasks, derived from CRhRdkTask. To make it easy for plug-in developers to add their own tasks to these menus, the RDK provides the class CRhRdkCustomTask. The developer only has to implement a subclass of this and then register the subclass with the RDK. An example of how to do this is shown below. Tasks use an interface called IRhRdkTaskOrigin which represents the place in the UI where the user clicked to invoke the menu. Among other things, this interface allows the task to get the contents that are currently selected in the UI. These are the contents that the user wants to perform an operation on.
{{}}

Registering custom tasks

To register a custom task, you first need to derive a class from CRhRdkCustomTask. You provide a menu string that is displayed to the user, a menu order which tells the RDK where on the menu to put the item, and one (or optionally two) icons. You also implement an Update() method and an Execute() method.


class CExampleCustomTask : public CRhRdkCustomTask
{
public:
 virtual UUID Id(void) const override { static const UUID uuid = youruuidhere; return uuid; }
 virtual UUID PlugInId(void) const final override { return yourpluginuuidhere; }
 virtual bool IsEnabled(const IRhRdkTaskOrigin& origin) const override { return true; }
 virtual const wchart* MenuString(const IRhRdkTaskOrigin&, CRhRdkContent::Kinds)
 const override { return L"Example Custom Task"; }
 virtual bool IconOut(CRhRdkContent::Kinds kind, int w, int h, OUT CRhinoDib& dib)
 const override { return false; }
 virtual bool IconIn(CRhRdkContent::Kinds kind, int w, int h, OUT CRhinoDib& dib) const override;
 ... [truncated]

Essential Code:
class CExampleCustomTask : public CRhRdkCustomTask
{
public:
	virtual UUID Id(void) const override { static const UUID uuid = your_uuid_here; return uuid; }
	virtual UUID PlugInId(void) const final override { return your_plug_in_uuid_here; }
	virtual bool IsEnabled(const IRhRdkTaskOrigin& origin) const override { return true; }
	virtual const wchar_t* MenuString(const IRhRdkTaskOrigin&, CRhRdkContent::Kinds)
	                                 const override { return L"Example Custom Task"; }
	virtual bool IconOut(CRhRdkContent::Kinds kind, int w, int h, OUT CRhinoDib& dib)
	                     const override { return false; }
	virtual bool IconIn(CRhRdkContent::Kinds kind, int w, int h, OUT CRhinoDib& dib) const override;
	virtual void Update(IRhRdkTaskUpdate& tu) const override;
	virtual Result Execute(const IRhRdkTaskOrigin&) const override;
	virtual int MenuOrder(const IRhRdkTaskOrigin& origin) const override;
};

int  CExampleCustomTask::MenuOrder(const IRhRdkTaskOrigin& origin) const
{
	// This value should be below 100 to make your task appear
	// before all the RDK's tasks, and above 10,000 to make it
...
void CMyRdkPlugIn::RegisterExtensions(void) const
{
	...
	AddExtension(new CExampleCustomTask);
	...


GUIDES / CPP / RENAMING-LAYERS
------------------------------------------------------------

Index
Source: guides\cpp\renaming-layers\index.md
Overview

Rhino layers (CRhinoLayer) are stored on a layer table (CRhinoLayerTable) which is located on the active document. The process for modifying an existing layer, such as changing its name, is:
Get the existing layer.
Make a copy of it.
Modify the copy.
Call CRhinoLayerTable::ModifyLayer().

Sample

The following code sample demonstrates how to rename an existing layer...


CRhinoCommand::result CCommandTestSdk::RunCommand(const CRhinoCommandContext& context)
{
 // Get the layer name
 CRhinoGetString gs;
 gs.SetCommandPrompt( L"Name of layer to rename" );
 gs.GetString();
 if( gs.CommandResult() != CRhinoCommand::success )
 return gs.CommandResult();

 // Validate the string
 ONwString layername = gs.String();
 layername.TrimLeftAndRight();
 if( layername.IsEmpty() )
 return CRhinoCommand::nothing;

 // Get a reference to the layer table 
 CRhinoLayerTable& layertable = context.mdoc.mlayertable;

 // Find the layer
 int layerindex = layertable.FindLayer( layername );
 if( layerindex < 0 )
 {
 RhinoApp().Print( L"Layer \"%s\" does not exist.\n", layername );
 return CRhinoCommand::cancel;
 }

 // Get the new layer name 
 gs.SetCommandPrompt( L"New layer name" );
 gs.GetString();
 if( gs.CommandResult() != CRhinoCommand::success )
 return gs.CommandResult();

 // Validate the string
 ONwString newname = gs.String();
 layername.TrimLeftAndRight();
 if( layername.IsEmpty() )
 return CRhinoCommand::nothing;

 // Compare both names 
 if( layername.CompareNoCase(newname) == 0 )
 return CRhinoCommand::nothing;

 // Get the layer
 const CRhinoLayer& layer = layertable[layerindex];

 // Make a copy of it, and modify the name
 ONLayer onlayer( layer );
 onlayer.SetLayerName( newname );

 // Modify the exising layer with the new definition 
 CRhinoCommand::result rc = CRhinoCommand::cancel;
 if( layertable.ModifyLayer(onlayer, layer_index) )
 rc = CRhinoCommand::success;

 return rc;
}


Essential Code:
CRhinoCommand::result CCommandTestSdk::RunCommand(const CRhinoCommandContext& context)
{
  // Get the layer name
  CRhinoGetString gs;
  gs.SetCommandPrompt( L"Name of layer to rename" );
  gs.GetString();
  if( gs.CommandResult() != CRhinoCommand::success )
    return gs.CommandResult();

  // Validate the string
  ON_wString layer_name = gs.String();
  layer_name.TrimLeftAndRight();
  if( layer_name.IsEmpty() )
    return CRhinoCommand::nothing;

  // Get a reference to the layer table  
  CRhinoLayerTable& layer_table = context.m_doc.m_layer_table;

  // Find the layer
  int layer_index = layer_table.FindLayer( layer_name );
...

GUIDES / CPP / RETREIVING-RHINO-DATA-FROM-CLIPBOARD
------------------------------------------------------------

Index
Source: guides\cpp\retreiving-rhino-data-from-clipboard\index.md
Overview

Like most Windows applications, Rhino can cut, copy, and paste information to and from the Windows Clipboard. When Rhino either cuts or copies geometry to the clipboard, it creates a temporary 3DM file that contains the selected geometry. Rhino then stores the temporary filename in the Clipboard. When a paste operation is invoked, Rhino determines if the Clipboard contains the name of a temporary Rhino file. If found, Rhino simply imports the temporary file.

Rhino registers custom Clipboard formats to store the temporary file names: a unique Clipboard format for each Rhino version.

Sample

The following sample demonstrates how to determine of there is Rhino information in the Windows Clipboard. If there is Rhino data in the Clipboard, the sample will retrieve the name of the temporary file. Once this file name is known, you can whatever means necessary to retrieve the data. For example, if you are using this code from a Rhino plugin, you could script the running of Rhino's Paste command to insert the geometry into the current document. If you are in a standalone application, you would use the openNURBS toolkit to read the temporary .3DM file.


/////////////////////////////////////////////////////////////////////////////
// clipboard.cpp

#include "StdAfx.h"
#include // MFC OLE clipboard support

// TODO: Fill this in with your own message printing
static void myPrintMessage( LPCTSTR lpMessage )
{
 if( 0 == lpMessage 0 == lpMessage[0] )
 return;
#ifdef RHINOSDKCLASS
 RhinoApp().Print( ONwString(lpMessage) );
#else
 MessageBox( 0, lpMessage, T("Clipboard Message"), MBSYSTEMMODAL MBOK MBICONINFORMATION);
#endif
}

// TODO: Return your application main window handle
static HWND myMainWnd()
{
#ifdef RHINOSDKCLASS
 return RhinoApp().MainWnd();
#else
 return AfxGetMainWnd()->mhWnd;
#endif
}

static UINT myGetClipboardFormat( int ver = 4 )
{
 UINT v = 0;

 if( 1 == ver ) // Rhino 1.0
 {
 static UINT v1 = 0;
 if( v1 0 )
 return CopyClipboardToTempFile( strF... [truncated]

Essential Code:
/////////////////////////////////////////////////////////////////////////////
// clipboard.cpp

#include "StdAfx.h"
#include <afxole.h> // MFC OLE clipboard support

// TODO: Fill this in with your own message printing
static void myPrintMessage( LPCTSTR lpMessage )
{
  if( 0 == lpMessage || 0 == lpMessage[0] )
    return;
#ifdef RHINO_SDK_CLASS
  RhinoApp().Print( ON_wString(lpMessage) );
#else
  MessageBox( 0, lpMessage, _T("Clipboard Message"), MB_SYSTEMMODAL|MB_OK|MB_ICONINFORMATION);
#endif
}

// TODO: Return your application main window handle
static HWND myMainWnd()
...

GUIDES / CPP / RUNNING-RHINO-COMMANDS-FROM-PLUGINS
------------------------------------------------------------

Index
Source: guides\cpp\running-rhino-commands-from-plugins\index.md
Overview

One of the most common questions asked by new plugin developers is how to run, or script, existing Rhino commands from a plugin command. Rhino doesn't allow plugin commands to run other commands except under very special circumstances.

Here's the issue: If you have a command that is modifying the run-time database, and you run another command, problems can happen.

To work around this, the Rhino C/C++ SDK provides a special kind of command called a script command. You can create a script command as follows...

How To

Derive your command class from CRhinoScriptCommand instead of CRhinoCommand. In other words, instead of defining your command class like this:


class CCommandTest : public CRhinoCommand


Define your command class like this:


class CCommandTest : public CRhinoScriptCommand


Then, from within your command class's RunCommand() member, you can call CRhinoApp::RunScript() to script the running of a Rhino command. For example:


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 RhinoApp().RunScript( L"_-Line 0,0,0 10,10,10", 0 );
 return CRhinoCommand::success;
}


Warning

This kind of command can be very dangerous. Please be sure you understand the following:
If you are not very familiar with how C++ references work, you should only call CRhinoApp::RunScript() from within a CRhinoScriptCommand derived command.
If you are very familiar with C++ references, then please observe the following rules:
If you get a reference or pointer to any part of the Rhino run-time database, this reference or pointer will not be valid after you call CRhinoApp::RunScript().
If you get a reference or a pointer, then call CRhinoApp::RunScript(), and then use the reference, Rhino will probably crash.
All pointers and references used by the command should be scoped such that they are only valid for the time between calls to CRhinoApp::RunScript().

This is because CRhinoApp::RunScript() can change the dynamic ar... [truncated]

Essential Code:
class CCommandTest : public CRhinoCommand

class CCommandTest : public CRhinoScriptCommand


GUIDES / CPP / RUNNING-RHINO-FROM-COMMAND-LINE
------------------------------------------------------------

Index
Source: guides\cpp\running-rhino-from-command-line\index.md
Overview

Under some circumstances, it is useful to run Rhino from the command prompt. Perhaps you are batch processing many files, or maybe you need to run Rhino from a render farm management system. Rhino provides command line options (arguments) to allow you to do exactly this.

Rhino for Windows

The format is:


Rhino.exe /runscript="-command -secondCommand"


For example, if you want to start Rhino with a file called hdritest.3dm, render it with the built-in renderer, save the file, and exit Rhino, you would pass this:


"C:\Program Files\Rhinoceros 5 (64-bit)\System\Rhino.exe" /runscript="SetCurrentRenderPlugIn Rhinoceros Render -SaveRenderWindowAs test.jpg -CloseRenderWindow -Exit" test.3dm


Command line options

The following command line options are available in Rhino for Windows:
/safemode: Start in safe mode.
/nosplash: Suppress startup splash screen.
/bigdump: When Rhino crashes, include the full memory content and, also, call stack information. This can generate huge crash dumps – as big as the amount of RAM Rhino is using when it crashes.
/notemplate: Start Rhino with a default model based on hard-coded defaults.
/language: Set the startup language. For example, to start in Spanish, pass /language=1034.
/scheme: Use a custom scheme. This is used by third party developers that include custom schemes.
/runscript: Run a script at startup.

GUIDES / CPP / SAVING-PERSISTENT-SETTINGS
------------------------------------------------------------

Index
Source: guides\cpp\saving-persistent-settings\index.md
Problem

Your plugin maintains a number of settings that need to be retained between sessions. Is there an easy way to do this? Do these setting migrate from one Rhino service release to another?

Solution

You can load and save persistent plugin setting from and to the Registry using the CRhinoPlugIn::LoadProfile and CRhinoPlugIn::SaveProfile virtual functions. For information on these virtual function, see rhinoSdkPlugIn.h.

How To

Lets say we have a sample plugin class declaration that looks something like the following:


class CTestPlugIn : public CRhinoUtilityPlugIn
{
public:
 CTestPlugIn();
 ~CTestPlugIn();

 // Required overrides
 const wchart PlugInName() const;
 const wchart PlugInVersion() const;
 GUID PlugInID() const;
 BOOL OnLoadPlugIn();
 void OnUnloadPlugIn();

 private:
 ONwString mpluginversion;

 // Persistent data
 bool mvalue0;
 int mvalue1;
 double mvalue2;
 ONwString mvalue3;
};


Simply, overload the CRhinoPlugIn::LoadProfile and CRhinoPlugIn::SaveProfile virtual functions by adding the the following public declarations to our plugin class:


void LoadProfile( LPCTSTR lpszSection, CRhinoProfileContext& pc );
void SaveProfile( LPCTSTR lpszSection, CRhinoProfileContext& pc );


Then, provide the definition:


void CTestPlugIn::LoadProfile( LPCTSTR lpszSection, CRhinoProfileContext& pc )
{
 pc.LoadProfileBool( lpszSection, L"value0", &mvalue0 );
 pc.LoadProfileInt( lpszSection, L"value1", &mvalue1 );
 pc.LoadProfileDouble( lpszSection, L"value2", &mvalue2 );
 pc.LoadProfileString( lpszSection, L"value3", mvalue3 );
}

void CTestPlugIn::SaveProfile( LPCTSTR lpszSection, CRhinoProfileContext& pc )
{
 pc.SaveProfileBool( lpszSection, L"value0", mvalue0 );
 pc.SaveProfileInt( lpszSection, L"value1", mvalue1 );
 pc.SaveProfileDouble( lpszSection, L"value2", mvalue2 );
 pc.SaveProfileString( lpszSection, L"value3", mvalue3 );
}


That's it! Your data is now saved at the following location in the Registry:


HKEYCURRENTUSER\Software\M... [truncated]

Essential Code:
class CTestPlugIn : public CRhinoUtilityPlugIn
{
public:
  CTestPlugIn();
  ~CTestPlugIn();

  // Required overrides
  const wchar_t* PlugInName() const;
  const wchar_t* PlugInVersion() const;
  GUID PlugInID() const;
  BOOL OnLoadPlugIn();
  void OnUnloadPlugIn();

 private:
  ON_wString m_plugin_version;

  // Persistent data
  bool m_value0;
  int m_value1;
  double m_value2;
...
void LoadProfile( LPCTSTR lpszSection, CRhinoProfileContext& pc );
void SaveProfile( LPCTSTR lpszSection, CRhinoProfileContext& pc );


GUIDES / CPP / SELECTING-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\selecting-objects\index.md
Overview

The Rhino C/C++ SDK provides the class CRhinoGetObject that will let you interactively select objects on the screen. This is a large class with many options. We recommend that you read through the header file, rhinoSdkGetObject.h, before using.

To use the CRhinoGetObject class, put one on the stack and call its GetObjects() member. It is possible to derive custom classes from CRhinoGetObject. But, the class is powerful enough that deriving new classes from it is usually unnecessary.

If an instance of CRhinoGetObject was successful in selecting one or more objects, then use its Object() member to retrieve information about the selected object. The Object() member returns a CRhinoObjRef class which has several member functions to help you quickly get to the information you are looking for.

Samples

This sample selects a single object...


CRhinoGetObject go;
go.SetCommandPrompt( L"Select object" );
CRhinoGet::result res = go.GetObjects( 1, 1 );
if( res == CRhinoGet::object )
{
 const CRhinoObjRef& objref = go.Object( 0 );
 const CRhinoObject obj = objref.Object();
 if( obj )
 {
 // TODO
 }
}


This sample selects one or more objects...


CRhinoGetObject go;
go.SetCommandPrompt( L"Select objects" );
CRhinoGet::result res = go.GetObjects( 1, 0 );
if( res == CRhinoGet::object )
{
 int i, count = go.ObjectCount();
 for( i = 0; i < count; i++ )
 {
 const CRhinoObjRef& objref = go.Object( 0 );
 const CRhinoObject obj = objref.Object();
 if( obj )
 {
 // TODO
 }
 }
}


This sample selects a single curve object...


CRhinoGetObject go;
go.SetCommandPrompt( L"Select curve" );
go.SetGeometryFilter( CRhinoGetObject::curveobject );
CRhinoGet::result res = go.GetObjects( 1, 1 );
if( res == CRhinoGet::object )
{
 const CRhinoObjRef& objref = go.Object( 0 );
 const ONCurve* crv = objref.Curve();
 if( crv )
 {
 // TODO
 }
}


GUIDES / CPP / SETTING-UP-A-CAGE-EDIT
------------------------------------------------------------

Index
Source: guides\cpp\setting-up-a-cage-edit\index.md
Problem

Imagine you have two objects: a surface and a line curve and you would like to setup cage editing, with the surface as the captive object and the line curve as the control object.

Solution

To allow the line curve to control the surface, you will need to create a CRhinoMorphControl object. A CRhinoMorphControl object has a ONMorphControl object, as its data member, which contains the definition of the controlling object (in this case, line).

Once you have properly defined the ONMorphControl object and created the runtime CRhinoMorphControl object, you can use the RhinoCaptureObject API function to setup the "capture."

The following example code demonstrates how you might write a command that allows a surface to be controlled by a line...


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 ONWorkspace ws;
 CRhinoCommand::result rc = CRhinoCommand::success;

 // Get the captive object
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select captive surface or polysurface" );
 go.SetGeometryFilter( CRhinoGetObject::surfaceobject CRhinoGetObject::polysrfobject );
 go.GetObjects( 1, 1 );
 rc = go.CommandResult();
 if( CRhinoCommand::success != rc )
 return rc;

 const CRhinoObject captive = go.Object(0).Object();
 if( 0 == captive )
 return CRhinoCommand::failure;

 // Define the control line
 ONLine line;
 rc = RhinoGetLine( CArgsRhinoGetLine(), line );
 if( CRhinoCommand::success != rc )
 return rc;

 // Get the curve parameters
 int degree = 3;
 int cvcount = 4;
 for(;;)
 {
 CRhinoGetOption gl;
 gl.SetCommandPrompt( L"NURBS Parameters" );
 gl.AcceptNothing();
 int dopt = gl.AddCommandOptionInteger( RHCMDOPTNAME(L"Degree"), &degree, L"Curve degree", 1.0, 100.0 );
 int popt = gl.AddCommandOptionInteger( RHCMDOPTNAME(L"PointCount"), &cvcount, L"Number of control points", 2.0, 100.0 );
 gl.GetOption();
 rc = gl.CommandResult();
 if( CRhinoCommand::success != rc )
 return rc;

 if( CRhinoGet::nothing == gl.Result() )
 brea... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  ON_Workspace ws;
  CRhinoCommand::result rc = CRhinoCommand::success;

  // Get the captive object
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select captive surface or polysurface" );
  go.SetGeometryFilter( CRhinoGetObject::surface_object | CRhinoGetObject::polysrf_object );
  go.GetObjects( 1, 1 );
  rc = go.CommandResult();
  if( CRhinoCommand::success != rc )
    return rc;

  const CRhinoObject* captive = go.Object(0).Object();
  if( 0 == captive )
    return CRhinoCommand::failure;

  // Define the control line
  ON_Line line;
...

GUIDES / CPP / SETTING-VIEWPORT-TITLES
------------------------------------------------------------

Index
Source: guides\cpp\setting-viewport-titles\index.md
Problem

You would like to change the name, or title, or a viewport using the the Rhino C/C++ SDK. For example, you would like to rename the "Front" viewport to say "Facade."

Solution

To change the title of a viewport, use CRhinoViewport::SetName. A Rhino view contains a "main viewport" that fills the entire view client window. To get a view's main viewport, you can call CRhinoView::MainViewport.

For example:


CRhinoView* view = RhinoApp().ActiveView();
if (view)
 view->MainViewport().SetName("Facade");


GUIDES / CPP / SHADING-INDIVIDUAL-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\shading-individual-objects\index.md
Overview

The drawing display pipeline technology provides both users and developers great flexibility and control over how objects are drawn on the screen. One of the features available is the ability to have objects draw using different display modes in the same viewport. For example, it is possible for a viewport to display both wireframe and shaded objects at the same time.

To allow an object to draw in a display mode other than what the viewport is currently set to, all you need to do is to add an ONDisplayMaterialRef object to an object's attributes. A ONDisplayMaterialRef defines what viewport an object will draw using a different display attributes and what display attributes it will use.

Sample

The following sample code demonstrates how to shade individual objects using the Rhino C/C++ SDK. This shading is independent of the viewport's current display mode, or display attribute. Is is accomplished by adding a ONDisplayMaterialRef object to an object's attributes.


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 // Get a list of available display attributes
 DisplayAttrsMgrList attrslist;
 const int attrscount = CRhinoDisplayAttrsMgr::GetDisplayAttrsList( attrslist );
 if( attrscount EnglishName();
 englishname.Remove( '' );
 englishname.Remove( ' ' );
 englishname.Remove( '-' );
 englishname.Remove( ',' );
 englishname.Remove( '.' );

 if( englishname.CompareNoCase(displayname) == 0 )
 {
 displaymaterialid = pAttrs->Id();
 break;
 }
 }

 // Bail if not found
 if( displaymaterialid == ONniluuid )
 {
 RhinoApp().Print( L" \"%s\" display mode not found.\n", displayname );
 return CRhinoCommand::nothing;
 }

 // Select the objects to shade
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select surfaces, polysurfaces, and meshes to shade" );
 go.SetGeometryFilter( ON::surfaceobject ON::brepobject ON::meshobject );
 go.GetObjects( 1, 0 );
 if( go.CommandResult() != success )
 return go.CommandResult();

 // Get the v... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  // Get a list of available display attributes
  DisplayAttrsMgrList attrs_list;
  const int attrs_count = CRhinoDisplayAttrsMgr::GetDisplayAttrsList( attrs_list );
  if( attrs_count <= 0 )
    return CRhinoCommand::nothing;

  ON_wString display_name( L"Shaded" );
  ON_UUID display_material_id = ON_nil_uuid;

  // Find the "Shaded" display attribute
  int i;
  for( i = 0; i < attrs_count; i++ )
  {
    CDisplayPipelineAttributes* pAttrs = attrs_list[i].m_pAttrs;
    if( !pAttrs )
      continue;

    ON_wString english_name = pAttrs->EnglishName();
...

GUIDES / CPP / SHOWING-OBJECTS-TRANSFORMING-DYNAMICALLY
------------------------------------------------------------

Index
Source: guides\cpp\showing-objects-transforming-dynamically\index.md
Overview

The CRhinoViewport class has two member functions, GetModelXform() and SetModelXform(), that either retrieve or modify the model transformation matrix that is applied to objects before they are drawn. The model transformation matrix is intended to be used for dynamic drawing of objects. Note, the default model transformation matrix is the identity.

Some of the Rhino command that use this technique to dynamically draw transforming objects include the Move, Copy, Scale, and Rotate commands. These commands derive new CRhinoGetPoint classes and override the virtual DynamicDraw() member function to draw objects dynamically as the mouse moves during a point picking operation.

Sample

The following is an sample CRhinoGetPoint-derived class that demonstrates how to dynamically draw transforming objects during a point picking operation. In this sample, the transformation is a simple translation, like used in the Move command.

First, the class declaration...


////////////////////////////////////////////////////////////////////
// CRhinoGetTranslationPoint declaration

class CRhinoGetTranslationPoint : public CRhinoGetPoint
{
public:

 CRhinoGetTranslationPoint();
 ~CRhinoGetTranslationPoint() {}

 // CRhinoGetPoint overrides 
 void SetBasePoint( ON3dPoint basepoint, BOOL bShowDistanceInStatusBar = false );
 void OnMouseMove( CRhinoViewport& vp, UINT flags, const ON3dPoint& pt, const CPoint p );
 void DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON3dPoint& pt );

 // Additional helpers
 void AddObject( const CRhinoObject object );
 void CalculateTranslation( const ON3dPoint& pt, ONXform& xform );

private:
 ON3dPoint mstartpoint; // starting point of translation
 ONXform mxform; // transformation matrix
 ONSimpleArray mobjects; //objects to transform
};

////////////////////////////////////////////////////////////////////
// CRhinoGetTranslationPoint definition

CRhinoGetTranslationPoint::CRhinoGetTranslationPoint()
{
 mxform.Identity();
}

void CRhinoGet... [truncated]

Essential Code:
////////////////////////////////////////////////////////////////////
// CRhinoGetTranslationPoint declaration

class CRhinoGetTranslationPoint : public CRhinoGetPoint
{
public:

  CRhinoGetTranslationPoint();
  ~CRhinoGetTranslationPoint() {}

  // CRhinoGetPoint overrides  
  void SetBasePoint( ON_3dPoint base_point, BOOL bShowDistanceInStatusBar = false );
  void OnMouseMove( CRhinoViewport& vp, UINT flags, const ON_3dPoint& pt, const CPoint* p );
  void DynamicDraw( HDC hdc, CRhinoViewport& vp, const ON_3dPoint& pt );

  // Additional helpers
  void AddObject( const CRhinoObject* object );
  void CalculateTranslation( const ON_3dPoint& pt, ON_Xform& xform );

private:
...

GUIDES / CPP / SUPPORTING-HIGH-DPI-DISPLAYS
------------------------------------------------------------

Index
Source: guides\cpp\supporting-high-dpi-displays\index.md
Overview

Super high resolution displays are now common on Windows-based systems, and those using Rhino expect it and 3rd party plugins to display correctly on them. Plugin developers need to make sure their applications are DPI–aware. DPI-aware plugins adjust UI elements to scale appropriately to the system DPI. Plugins that are not DPI–aware, but are running on a high-DPI display setting, can suffer from many visual artifacts, including incorrect scaling of UI elements, clipped text, and blurry images.

Plugin developers should run Rhino on high-DPI displays so they can find and fix display issues. Here is how you can configure Windows for high-DPI display:

Windows 10
Right-click on your desktop and click Display settings.
Use the slider to select the text scaling and click Apply.
Logout of Windows and log back in.

Windows 8/8.1
Right-click on your desktop and click Screen resolution.
Click the Make text and other items larger or smaller.
Use the slider to select the text scaling and click Apply.
Logout of Windows and log back in.

Windows 7
Right-click on your desktop and click Screen resolution.
Click Make text and other items larger or smaller.
Select the text scaling and click Apply.
Logout of Windows and log back in.

Common C++ Issues

Most high DPI issues that plugins will encounter are due to owner-drawn control. Here, developers have hard-coded sizes or locations, assuming the standard DPI setting. In these cases, custom drawn elements don’t appear correctly, or custom controls don’t work properly.

Other issues have to do with the use of bitmaps or icons that are too small at higher DPI settings or that don’t scale well.

The Rhino SDK has some new tools that developers can use to help make UI elements DPI-aware. See the CRhinoDpi class declaration in RhinoSdkDpi.h 

General

The CRhinoDpi class contains several static function to help with DPI-aware issues.

CRhinoDpi::DpiScale returns the display DPI scale factor when Rhin... [truncated]

Essential Code:
virtual HICON Icon()
{
  const int const_icon_size = 24;
  int icon_size = CRhinoDpi::Scale(const_icon_size);
  return CRhinoDpi::LoadIcon(AfxGetInstanceHandle(), IDI_ICON, icon_size);
}

virtual HICON Icon(const CSize& size) const
{
  return CRhinoDpi::LoadIcon(AfxGetInstanceHandle(), IDI_ICON, size.cx, size.cy);
}


GUIDES / CPP / TESTING-FOR-CURVES-ON-SURFACES
------------------------------------------------------------

Index
Source: guides\cpp\testing-for-curves-on-surfaces\index.md
Problem

In your plugin, you are using a surface and an interpolated curve on that surface. You know the curve is interpolated on the surface because that is how you created it (using the InterpCrfOnSrf command). Now, what if you import some other 3dm file with curve and surface already in it? How can one check that curve lies completely on surface using C/C++?

Solution

The Rhino C/C++ SDK does not have a function that tests whether or not a curve lies on a surface. But, you can write your own test that should give you the correct answer for most cases.

The best approach for writing a function to do this would be to sample many curve points and perform closest point tests against the surface with each curve point. If the distance between the curve points and the surface points are within some tolerance, then chances are the curve is on the surface - at least the sampled points are on the surface.

Sample

The following sample function does just this:


// Description:
// Test to see if a curve lies on a surface.
// Parameters:
// srf - [in] The surface
// crv - [in] The curve
// tol - [in] The tolerance
// Returns:
// True if the curve (probably) lies on the surface.
// False otherwise.

static bool RhinoIsCurveOnSurface(
 const ONSurface& srf,
 const ONCurve& crv,
 double tol
 )
{
 if( !srf.IsValid() !crv.IsValid() )
 return false;

 ONNurbsCurve nc;
 if( !crv.GetNurbForm(nc) )
 return false;

 const int spancount = nc.SpanCount();
 ONSimpleArray spanvector( spancount + 1 );
 spanvector.SetCount( spancount + 1 );
 nc.GetSpanVector( spanvector.Array() );

 bool rc = true;
 double numsamples = nc.Degree() * 2;
 int i, j;
 for( i = 0; i < spancount && rc; i++ )
 {
 ONInterval span( spanvector[i], spanvector[i+1] );
 rc = span.IsIncreasing();
 if( rc )
 {
 for( j = 0; j <= numsamples && rc; j++ )
 {
 double crvt = span.ParameterAt( j / numsamples );
 ON3dPoint crvpt = nc.PointAt( crvt );
 double s = 0.0, t = 0.0;
 rc = srf.GetClosestPoint( crvpt, &s, &t );
 if(... [truncated]

Essential Code:
// Description:
//   Test to see if a curve lies on a surface.
// Parameters:
//   srf - [in] The surface
//   crv - [in] The curve
//   tol - [in] The tolerance
// Returns:
//   True if the curve (probably) lies on the surface.
//   False otherwise.

static bool RhinoIsCurveOnSurface(
        const ON_Surface& srf,
        const ON_Curve& crv,
        double tol
        )
{
  if( !srf.IsValid() | !crv.IsValid() )
    return false;

  ON_NurbsCurve nc;
...

GUIDES / CPP / TEXTURES-AND-MAPPINGS
------------------------------------------------------------

Index
Source: guides\cpp\textures-and-mappings\index.md
Overview

Broadly speaking, there are six concepts that are important to understand when dealing with materials, textures, and mappings:
Texture Bitmap: A bitmap image, usually saved in a file.
Texture Coordinates: In Rhino these are 2d and 3d points that are saved in an ONMesh in the mT[] or mTC[] arrays. They should always be set by a texture mapping and never modified directly.
Texture Mapping: A function that sets texture coordinates. Persistent texture mappings are stored in CRhinoDoc::mtexturemappingtable[].
Surface parameters: A set of 2d points stored in an ONMesh in the mS[] array. They are used by the surface parameter mapping.
Render Material: A collection of rendering color and shading information, including the names of texture bitmaps. Rendering materials are stored in CRhinoDoc::mmaterialtable[].
Object Attributes: Attributes of a Rhino object, including the rendering materials and texture mappings the object uses, are stored in the CRhinoObjectAttributes class returned by CRhinoObject::Attributes().

Sample

The following sample creates a material with a bitmap texture, then modifies a mesh object's attributes, sets up surface parameters and applies a surface parameter mapping so the bitmap is projected onto the mesh along the world Z axis...


 CRhinoDoc pDoc = context.Document();
 if (nullptr == pDoc)
 return CRhinoCommand::failure;
 CRhinoDoc& doc = pDoc;

 // Id of the currently active render plug-in
 const UUID renderPlugInId = RhinoApp().CurrentRenderPlugIn()->PlugInID();

 // Create a material with a texture bitmap
 ONTexture tex;
 tex.mimagefilereference.SetFullPath(L"C:/my-texture-folder/sample-texture.bmp", true);
 tex.mbOn = true;
 tex.mtype = ONTexture::TYPE::bitmaptexture;
 tex.mmode = ONTexture::MODE::modulatetexture;
 tex.mmappingchannelid = 1;

 ONMaterial mat;
 mat.mdiffuse.SetRGB(150, 0, 0);
 mat.mspecular.SetRGB(200, 200, 200);
 mat.mshine = 0.5 ONMaterial::MaxShine;
 mat.AddTexture(tex);

 int matindex = doc.mmaterialtable.Ad... [truncated]

Essential Code:
  CRhinoDoc* pDoc = context.Document();
  if (nullptr == pDoc)
    return CRhinoCommand::failure;
  CRhinoDoc& doc = *pDoc;

  // Id of the currently active render plug-in
  const UUID renderPlugInId = RhinoApp().CurrentRenderPlugIn()->PlugInID();

  // Create a material with a texture bitmap
  ON_Texture tex;
  tex.m_image_file_reference.SetFullPath(L"C:/my-texture-folder/sample-texture.bmp", true);
  tex.m_bOn = true;
  tex.m_type = ON_Texture::TYPE::bitmap_texture;
  tex.m_mode = ON_Texture::MODE::modulate_texture;
  tex.m_mapping_channel_id = 1;

  ON_Material mat;
  mat.m_diffuse.SetRGB(150, 0, 0);
  mat.m_specular.SetRGB(200, 200, 200);
  mat.m_shine = 0.5 * ON_Material::MaxShine;
...

GUIDES / CPP / TOGGLING-STATUS-BAR
------------------------------------------------------------

Index
Source: guides\cpp\toggling-status-bar\index.md
Overview

When you run the Options command, all Rhino's options or application settings that you see are maintained by a CRhinoAppSettings class stored on the Rhino application object. This class is a container class as it holds several other CRhinoAppxxxSettings classes that help to organize all the options.

The process for modifying any Rhino option is:
Find the container class in CRhinoAppSettings that holds the option you want to change.
Make a copy of that container class.
Change the appropriate members.
Replace Rhino's copy of that container class with yours by calling one of CRhinoAppSettings' SetxxxSettings() member functions.

Sample

The following sample source code demonstrates how to show or hide Rhino's status bar using the Rhino C/C++ SDK...


void ShowRhinoStatusBar( BOOL bShow )
{
 // Copy the CRhinoAppAppearanceSettings class
 CRhinoAppAppearanceSettings settings = RhinoApp().AppSettings().AppearanceSettings( true );
 if( settings.mshowstatusbar != bShow )
 {
 // Modify the desired setting
 settings.mshowstatusbar = bShow;
 // Replace the CRhinoAppAppearanceSettings with the modified version
 RhinoApp().AppSettings().SetAppearanceSettings( settings );
 }
}


Essential Code:
void ShowRhinoStatusBar( BOOL bShow )
{
  // Copy the CRhinoAppAppearanceSettings class
  CRhinoAppAppearanceSettings settings = RhinoApp().AppSettings().AppearanceSettings( true );
  if( settings.m_show_statusbar != bShow )
  {
    // Modify the desired setting
    settings.m_show_statusbar = bShow;
    // Replace the CRhinoAppAppearanceSettings with the modified version
    RhinoApp().AppSettings().SetAppearanceSettings( settings );
  }
}


GUIDES / CPP / TRACKING-CAMERA-CHANGES-WITH-CONDUITS
------------------------------------------------------------

Index
Source: guides\cpp\tracking-camera-changes-with-conduits\index.md
Problem

How can you get a windows message from Rhino viewport, specifically when rotating some object in viewport with right click? The goal is to get the parameters from the camera viewport when there is an event, like mouse move or right click. You need those camera settings parameters so that you can set them in another view.

Solution

This can be done through what is called a Conduit Notification. Basically, you setup a CRhinoDisplayConduit, attach it to a specific viewport (or all), and then "listen" for specific notifications by overriding CRhinoDisplayConduit::NotifyConduit. You would most likely be interested in CNPIPELINEOPENED, CNPIPELINECLOSED, and CNPROJECTIONCHANGED events. On those events you can query the current viewport (camera) for any settings you want, and then react accordingly.

Sample

The following sample plugin command demonstrates a conduit that uses notifiers to track camera information. It also demonstrates how to create a HUD (Heads Up Display) used to display the tracked results and overlay them onto the viewport using transparent bitmap drawing.


#include "stdafx.h"

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// BEGIN TestCameraTracker command
//
class CCameraTrackingConduit : public CRhinoDisplayConduit
{
public:
 CCameraTrackingConduit();

 bool ExecConduit(
 CRhinoDisplayPipeline&, // pipeline executing this conduit
 UINT, // current channel within the pipeline
 bool& // channel termination flag
 ); 

 void NotifyConduit(EConduitNotifiers, CRhinoDisplayPipeline&);

public:
 void StartTracking(const CRhinoView);
 void StopTracking(void);

// Conduit specific attributes...
public:
 ON3dPoint mCameraLocation;
 ON3dVector mCameraDirection;
 ON3dPoint mCameraTarget;
 double mCameraLensLength;
 double mCameraNear;
 double mCameraFar;

 // TODO: Place more tracking variables here based on what you want to track...

private:
 static const COLOR... [truncated]

Essential Code:
#include "stdafx.h"

////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////
//
// BEGIN TestCameraTracker command
//
class CCameraTrackingConduit : public CRhinoDisplayConduit
{
public:
              CCameraTrackingConduit();

  bool        ExecConduit(
                  CRhinoDisplayPipeline&, // pipeline executing this conduit
                  UINT,                   // current channel within the pipeline
                  bool&                   // channel termination flag
                  );  

  void        NotifyConduit(EConduitNotifiers, CRhinoDisplayPipeline&);

...

GUIDES / CPP / TRANSFORMING-BREPS
------------------------------------------------------------

Index
Source: guides\cpp\transforming-breps\index.md
Samples

The Short Way


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select brep" );
 go.SetGeometryFilter( ON::brepobject );
 go.GetObjects(1,1);
 if( go.CommandResult() != success )
 return go.CommandResult();

 CRhinoObjRef ref = go.Object(0);

 // Simple translation transformation
 ONXform xform;
 xform.Translation( ON3dVector(18,-18,-25) );

 context.mdoc.TransformObject( ref, xform );
 context.mdoc.Redraw();

 return success;
}


The Long Way


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select brep" );
 go.SetGeometryFilter( ON::brepobject );
 go.GetObjects(1,1);
 if( go.CommandResult() != success )
 return go.CommandResult();

 const CRhinoObjRef& ref = go.Object(0);
 const CRhinoObject obj = ref.Object();
 if( !obj )
 return failure;
 const ONBrep brep = ref.Brep();
 if( !brep )
 return failure;
 ONBrep dupe = brep->Duplicate();
 if( !dupe )
 return failure;

 // Simple translation transformation
 ONXform xform;
 xform.Translation( ON3dVector(18,-18,-25) );

 if( !dupe->Transform( xform ) )
 {
 RhinoApp().Print( L"Unable to transform object.\n" );
 delete dupe;
 return failure;
 }

 ON3dmObjectAttributes attribs = obj->Attributes();
 context.mdoc.AddBrepObject( dupe, &attribs );

 // Since CRhinoDoc::AddBrepObject() make a copy of the input
 // brep, we are responsible for deleting the original. Otherwise
 // we will leak memory;
 delete dupe;
 // Delete the selected object
 context.mdoc.DeleteObject( ref );
 context.mdoc.Redraw();
 return success;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select brep" );
  go.SetGeometryFilter( ON::brep_object );
  go.GetObjects(1,1);
  if( go.CommandResult() != success )
    return go.CommandResult();

  CRhinoObjRef ref = go.Object(0);

  // Simple translation transformation
  ON_Xform xform;
  xform.Translation( ON_3dVector(18,-18,-25) );

  context.m_doc.TransformObject( ref, xform );
  context.m_doc.Redraw();

  return success;
}
...
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select brep" );
  go.SetGeometryFilter( ON::brep_object );
  go.GetObjects(1,1);
  if( go.CommandResult() != success )
    return go.CommandResult();

  const CRhinoObjRef& ref = go.Object(0);
  const CRhinoObject* obj = ref.Object();
  if( !obj )
    return failure;
  const ON_Brep* brep = ref.Brep();
  if( !brep )
    return failure;
  ON_Brep* dupe = brep->Duplicate();
  if( !dupe )
    return failure;

...

GUIDES / CPP / TRIANGULATING-POLYGONS
------------------------------------------------------------

Index
Source: guides\cpp\triangulating-polygons\index.md
Overview

Rhino's mesh representation, ONMesh, only support three and four sided faces. This can pose a problem when trying to write an import plugin for a mesh file format that supports n-sided polygons. If you search the Internet, you can probably find a number of algorithms that will triangulate n-sided polygons so they can be used with ONMesh. The Rhino C/C++ SDK also includes a tool for doing this.

The RhinoTriangulate3dPolygon SDK function will triangulate an n-sided polygon. The polygon must project onto a plane and the projected polygon must be a simple closed curve. h.

Sample

The following sample code demonstrates how to triangulate a closed planar polygon that has more than three sides using the RhinoTriangulate3dPolygon function. Although this sample demonstrates the function on polyline curves, the code could be easily converted to work on mesh vertices.


CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
 CRhinoGetObject go;
 go.SetCommandPrompt(L"Select closed planar polygon to triangulate");
 go.SetGeometryFilter(CRhinoGetObject::curveobject);
 go.SetGeometryFilter(CRhinoGetObject::closedcurve);
 go.EnableSubObjectSelect(FALSE);
 go.GetObjects(1, 1);
 if (go.CommandResult() != success)
 return go.CommandResult();

 ON3dPointArray vertices;

 const CRhinoObjRef& ref = go.Object(0);
 const ONPolylineCurve pc = ONPolylineCurve::Cast(ref.Curve());
 if (pc)
 {
 vertices = pc->mpline;
 }
 else
 {
 const ONNurbsCurve nc = ONNurbsCurve::Cast(ref.Curve());
 if (nc)
 nc->IsPolyline(&vertices);
 }

 if (vertices.Count() < 5)
 {
 RhinoApp().Print(L"Curve not polygon with at least four sides.\n");
 return CRhinoCommand::nothing;
 }

 int triangles = (int)onmalloc((vertices.Count() - 3) sizeof(int) 3);
 if (nullptr == triangles)
 return CRhinoCommand::failure; // out of memory

 memset(triangles, 0, (vertices.Count() - 3) size... [truncated]

Essential Code:
CRhinoCommand::result CCommandTest::RunCommand(const CRhinoCommandContext& context)
{
  CRhinoGetObject go;
  go.SetCommandPrompt(L"Select closed planar polygon to triangulate");
  go.SetGeometryFilter(CRhinoGetObject::curve_object);
  go.SetGeometryFilter(CRhinoGetObject::closed_curve);
  go.EnableSubObjectSelect(FALSE);
  go.GetObjects(1, 1);
  if (go.CommandResult() != success)
    return go.CommandResult();

  ON_3dPointArray vertices;

  const CRhinoObjRef& ref = go.Object(0);
  const ON_PolylineCurve* pc = ON_PolylineCurve::Cast(ref.Curve());
  if (pc)
  {
    vertices = pc->m_pline;
  }
  else
...

GUIDES / CPP / TYPE-CASTING-RHINO-OBJECTS
------------------------------------------------------------

Index
Source: guides\cpp\type-casting-rhino-objects\index.md
Problem

Given a Rhino object, how can one convert it to another Rhino object? For example, if you have a CRhinoObject pointer, how can I convert it to a CRhinoCurveObject pointer? Or, how can one get the curve geometry?

Solution

All Rhino C/C++ SDK classes derived from ONObject provide conversions between pointers to related classes using a static ONObject::Cast function.

If you have a pointer to some base class that inherits from ONObject, and you want to convert it to a pointer of a derived class, than simply call the derived class Cast function.

For example:


const CBase a = ...;
const CDerived b = CDerived::Cast( a );


Samples


CRhinoGetObject go;
go.SetCommandPrompt( L"Select something" );
go.GetObjects( 1, 1 );
if( CRhinoCommand::success == go.CommandResult() )
{
 // Get the one (and only) object reference
 CRhinoObjRef objref = go.Object(0);

 // Get the Rhino object
 const CRhinoObject obj = objref.Object();
 if( obj )
 {
 // Try casting as a Rhino point object
 const CRhinoPointObject pointobj = CRhinoPointObject::Cast( obj );
 if( pointobj )
 {
 // Get the point object's point geometry
 const ONPoint& point = pointobj->Point();
 // todo...
 }

 // Try casting as a Rhino curve object
 const CRhinoCurveObject curveobj = CRhinoCurveObject::Cast( obj );
 if( curveobj )
 {
 // Get the curve object's curve geometry
 const ONCurve curve = curveobj->Curve();
 // todo...
 }

 // Try casting as a Rhino brep object
 const CRhinoBrepObject brepobj = CRhinoBrepObject::Cast( obj );
 if( brepobj )
 {
 // Get the brep object's brep geometry
 const ONBrep brep = brepobj->Brep();
 // todo...
 }

 // Try casting as a Rhino mesh object
 const CRhinoMeshObject meshobj = CRhinoMeshObject::Cast( obj );
 if( meshobj )
 {
 // Get the mesh object's mesh geometry
 const ONMesh mesh = meshobj->Mesh();
 // todo...
 }

 // etc...
 }
}


and...


CRhinoGetObject go;
go.SetCommandPrompt( L"Select something" );
go.GetObjects( 1, 1 );
if( CRhinoCommand::success == go... [truncated]

GUIDES / CPP / UNIFYING-MESH-NORMALS
------------------------------------------------------------

Index
Source: guides\cpp\unifying-mesh-normals\index.md
Problem

You have found that RhinoUnifyMeshNormals C/C++ functions seems to behave differently than the UnifyMeshNormals command. How can one achieve the same functionality in a plugin?

Solution

In addition to calling the RhinoUnifyMeshNormals function, the UnifyMeshNormals command also recomputes the mesh's vertex normals, based on the new face normals, using ONMesh::ComputeVertexNormals.

Sample

The following sample demonstrates this.


CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
 CRhinoGetObject go;
 go.SetCommandPrompt( L"Select mesh to unify normals" );
 go.SetGeometryFilter( CRhinoGetObject::meshobject );
 go.GetObjects( 1, 1 );
 CRhinoCommand::result rc = go.CommandResult();
 if( rc != CRhinoCommand::success )
 return rc;

 const CRhinoObjRef ref = go.Object(0);
 const ONMesh mesh = ref.Mesh();
 if( 0 == mesh )
 return CRhinoCommand::failure;

 int count = 0;
 ONMesh newmesh = RhinoUnifyMeshNormals( mesh, 0, false, &count );
 if( newmesh && newmesh->IsValid() )
 {
 newmesh->ComputeVertexNormals();

 CRhinoMeshObject newobj = new CRhinoMeshObject();
 newobj->SetMesh( newmesh );

 context.mdoc.ReplaceObject( ref, newobj );
 context.mdoc.Redraw();

 RhinoApp().Print( L"Reversed the orientation of %d faces.\n", count );
 rc = CRhinoCommand::success;
 }
 else
 {
 if( 0 != count )
 {
 RhinoApp().Print( L"Unable to unify mesh normals.\n" );
 rc = CRhinoCommand::failure;
 }
 else
 {
 RhinoApp().Print( L"All face normals are already oriented in the same direction.\n" );
 rc = CRhinoCommand::nothing;
 }
 }

 return rc;
}


Essential Code:
CRhinoCommand::result CCommandTest::RunCommand( const CRhinoCommandContext& context )
{
  CRhinoGetObject go;
  go.SetCommandPrompt( L"Select mesh to unify normals" );
  go.SetGeometryFilter( CRhinoGetObject::mesh_object );
  go.GetObjects( 1, 1 );
  CRhinoCommand::result rc = go.CommandResult();
  if( rc != CRhinoCommand::success )
    return rc;

  const CRhinoObjRef ref = go.Object(0);
  const ON_Mesh* mesh = ref.Mesh();
  if( 0 == mesh )
    return CRhinoCommand::failure;

  int count = 0;
  ON_Mesh* new_mesh = RhinoUnifyMeshNormals( *mesh, 0, false, &count );
  if( new_mesh && new_mesh->IsValid() )
  {
    new_mesh->ComputeVertexNormals();
...

GUIDES / CPP / USER-DATA
------------------------------------------------------------

Index
Source: guides\cpp\user-data\index.md
Overview

There are two basic ways plugins can store information in Rhino .3dm files:
Document User Data
Object User Data

For example, a rendering plugin might save a scene description as Document User Data and use Object User Data to attach rendering material information to individual surfaces.

Document User Data

To save document user data your plugin must override three CRhinoPlugIn base class functions:


CRhinoPlugIn::CallWriteDocument
CRhinoPlugIn::WriteDocument
CRhinoPlugIn::ReadDocument


When Rhino writes a .3dm file, it goes through all the plugins that are currently loaded. First Rhino calls CallWriteDocument() to see if the plugin wants to save document user data. If CallWriteDocument() returns true, Rhino saves information that identifies the plugin and then calls WriteDocument() when it is time for the plugin to save its document user data.

When Rhino reads a .3dm file and it encounters document user data, it uses the plugin identification information to load the plugin and then calls the plugin's ReadDocument() to read the plugin's document user data.

Object User Data

Object user data can be attached to things like layers, materials, geometry objects, and object attributes. In fact object user data can be attached to any class derived from ONObject. This user data is stored in a linked list on ONObject and can be copied, transformed, and saved along with the parent object. For example, you could attach object user data to a mesh. When the mesh is copied the object user data is copied and attached to the copy. When the mesh is transformed, the transformation is recorded by the object user data. When the mesh is saved in a .3dm file, the object user data is saved too.

All object user data is saved in a class you write that is derived from the class ONUserData.

Attaching Object User Data to CRhinoObjects

The Rhino geometry table is where the bulk of the Rhino model is stored. This is where the points, curves, meshes, surface, polysurfaces, ... [truncated]

Essential Code:
class CMyUserData1 : public ON_UserData
{
public:

  /*
  Returns:
   Uuid used to identify this type of user data.
   This is the value saved in m_userdata_uuid and
   passed to ON_Object::GetUserData().
  */
  static ON_UUID Id();

  CMyUserData1();
  ~CMyUserData1();

  ON_wString m_my_string;
};

ON_UUID CMyUserData1::Id()
{
  // Use Microsoft's guidgen to get a unique id.
  // {1129B130-B840-...}
  static const ON_UUID id = { 0x1129b130, 0xb840, ... };
  return id;
}

CMyUserData1::CMyUserData1()
{
  m_userdata_uuid = CMyUserData1::Id();
  m_application_uuid = MyPlugIn().PlugInID();
  m_userdata_copycount = 1;  // enable copying
}


GUIDES / CPP / USING-ACTIVEX-CONTROLS
------------------------------------------------------------

Index
Source: guides\cpp\using-activex-controls\index.md
Problem

ActiveX controls placed in a simple dialog box will crash Rhino.

Solution

ActiveX, or OLE, controls work in Rhino plugins, as C/C++ plugin are simply regular MFC DLLs. aspx) and MFC Technical Note 58.aspx) 

Also, you will need to call this function:


void AfxEnableControlContainer();


in your CWinApp-derived object's InitInstance() member to enable support for containment of OLE controls.

Related Topics
MFC ActiveX Controls (on MSDN).aspx)
MFC Technical Note 33 (on MSDN).aspx)
MFC Technical Note 58.aspx)

Essential Code:
void AfxEnableControlContainer();


GUIDES / CPP / USING-SIZEOF-WITH-TCHAR-WCHAR-T
------------------------------------------------------------

Index
Source: guides\cpp\using-sizeof-with-tchar-wchar-t\index.md
Discussion

The sizeof keyword gives the amount of storage, in bytes, associated with a variable or a type. It does not return number of elements in an array, such as an array of characters.

Mistakes using the sizeof operator when dealing with UNICODE strings is very common. For example:


char szBuffer[24];
GetWindowText( hWnd, szBuffer, sizeof(szBuffer) ); // OK

wchart wszBuffer[24];
GetWindowText( hWnd, wszBuffer, sizeof(wszBuffer) ); // WRONG


In the above e... [compressed]GUIDES / GENERAL / CONTRIBUTING
------------------------------------------------------------

Index
Source: guides\general\contributing\index.md
GitHub

Many McNeel projects are open-source and on GitHub. RhinoCommon - our cross-platform .NET SDK - is a great example. Even this very website you are reading now. Browse source, fork a repo, correct a typo: we welcome participation and pull-requests.

Discourse

discourse.mcneel.com is the McNeel forum. This is the fastest place to get help. Specific categories to post in are:
Rhino Developer: Customizing Rhino through VB, C#, C++, RhinoScript, and Python.
Scripting: Topics related to RhinoScript and Python scripting.
openNURBS: Topics related to the openNURBS toolkit.
Grasshopper developer: VB, C#, and Python in Grasshopper components.

Report Bugs

Whenever you encounter something that doesn't work as it should, we'd love it if you could file a bug report. Please report issues or bugs with our APIs or SDKs on the appropriate Discourse category, above.

This website

This website is open source on GitHub. If you find errors or think a page could be improved, just click the “Edit page on GitHub” link at the bottom of any page. If you are a McNeel employee, you should already have permissions to commit to this repository. If you are a Rhino Plugin Developer, you can request permissions to commit. Anyone can clone the repository and submit a pull-request.

This site uses Markdown as the base-format for all content. 

To get started authoring content for this site, please read the following guides:
Contributing (to this website)
Getting Started with Developer Docs
How This Site Works
Developer Docs Style Guide

You may also want to take a look at the Admin page.

Contacts

Who to talk to for what:
Steve Baer (RhinoCommon) - @stevebaer on Discourse
Alain Cormier (Rhino.Python) - @alain on Discourse
Dale Fugier (C/C++ SDK, Zoo, RAP) - @dale on Discourse
Dale Lear (openNURBS) - @dalelear on Discourse
David Rutten (Grasshopper) - David Rutten on the Grasshopper 3D forum
Giulio Piacentino (GhPython) - @piac on Discourse
Andy le Bihan (RDK) - @andy on Discourse
Curtis W... [truncated]

GUIDES / GENERAL / CREATING-COMMAND-MACROS
------------------------------------------------------------

Index
Source: guides\general\creating-command-macros\index.md
You can create macros in Rhino to automate many tasks, customize your commands, and improve your workflow.

There may be some confusion about the use of the term “scripting” here. Classically, it describes both the process of writing macros (what this section is about), as well as writing more sophisticated scripts in either RhinoScript, Rhino.Python or other programming languages. 

The two things are actually very different. Writing functions in RhinoScript or other programming languages is a lot more complex than creating macros, and requires some programming knowledge and skills. We don't cover that here.

I use the term “Macro” here exclusively to describe the putting together of strings of ordinary Rhino commands and their options to create an automated function. This is scripting on its simplest of levels, and is easily accessible to any ordinary Rhino user, even if they have no knowledge of programming. All You need is a reasonable understanding of Rhino commands and their structure, as well as a logical mind and a taste for a little experimentation and debugging.

The tools you need
Your brain.
The Rhino Help file - lists all Rhino commands and their sub-options. This is your most important reference.
The Rhino MacroEditor, to easily run and debug your macros.

You've already used a macro or two...
First, if you are a user of Rhino, you are already a macro user even though you may not know it. Many of the commands in Rhino are already “macroed” for you. When you click a toolbar button or call a command from the menu, it is often a preset macro. To see, Shift+right-click on the button Extrude Straight:

!Extrude

This is an example of the simplest macro, which sets a series of options within a single command so that you don’t have to specify each one every time you use it. ExtrudeCrv has several buttons with preset options, Tapered, AlongCurve, ToPoint, Cap=Yes (solid) etc. Check out the macros under all the ExtrudeCrv buttons to see how they are laid out.

... [truncated]

GUIDES / GENERAL / DEVELOPER-DOCS-STYLE-GUIDE
------------------------------------------------------------

Index
Source: guides\general\developer-docs-style-guide\index.md
Below are examples of nearly all the available syntax using Markdown, the table-of-contents UI widget, etc.

Conventions

Site file naming

The naming convention for files - guides, samples, etc - is lowercase with - used as spaces. This leads to more consistent and legible URLs. In addition, Google recommends one construct compound URL names with - and not underbars (). For example, consider the name of this guide: "Style Guide". The file name for this guide is developer-docs-style-guide. Google treats a hyphen as a word separator, but does not treat an underscore that way. Google treats and underscore as a word joiner — so "redsneakers" is the same as "redsneakers."

In general, when considering new file names for guides, please imagine you are saying "Guide to __". This often leads to verbs ending in "-ing", the progressive or continuous verb tense. Obviously, this is not a hard-and-fast rule, but rather a convention.

In general, when considering new file names for samples, please imagine you are saying "_ sample". As with guides, this is not a hard-and-fast rule, but rather a general convention.

Division of content

Title become H1 headers and are reserved for the title of the page only.

Header become H2 headers and are reserved for major sections within the page.

Sub Header become H3 headers and are reserved for sub-sections within a major section.

Fonts

{{}}
This fonts section needs to be updated.
{{}}

On Windows, this site attempts to use Segoe UI (font size: 16 px, font weight: 400, line height: 1.6) and falls back to Frutiger Linotype, Dejavu Sans, Helvetica Neue, Helvetica, Arial, in that order. On macOS, the site will (almost) certainly use Helvetica Neue or Helvetica (font size: 16 px, font weight: 300, line height: 1.6). The operating system-specific font weight is set in the footer using javascript.

Paths & Filenames

Italics are used to denote filenames, paths, and file extensions. For example:

Navigate to C:\Program Files\Rhinoceros 5 (64-bi... [truncated]

Essential Code:

produces:

{{< figure src="/images/developing-software-in-public-01.png" caption="Developing Software in Public"  caption-align="left" >}}

Optionally, you can also use the [gallery](#gallery) and [load-photoswipe](#load-photoswipe) shortcodes to embed figures in a gallery and pop-up an image overlay when users click or tap on the image.

Image (shortcode)

There is a basic  shortcode for doing simple sizing (this is an html resizing, not an actual image process - see  below)...

Here is an example that changes the width of an image


produces

{{< image url="logo.png" width="250px" >}}

Image Processing (imgproc)

Hugo comes with [a number of useful image processing routines like resizing and cropping](https://gohugo.io/content-management/image-processing/).  It's important to understand that these are not just css styles, but actual processes the generate entirely new derivative files based on the image you use as your input.  This is especially useful for generating thumbnails from large images so that a smaller (in kb) image is delivered in those situations where a larger one would cause slow pageloads.  Think of these image processing routines as the equivalent of opening up your file in a program like Photoshop and performing resizing, format, or cropping operations on them.

{{< call-out info "This only works on page-bundle images" >}}
Currently, this shortcode only works on page-bundle images and not on images in the static folder (the main images folder).  You will have to use GitHub to upload these into the proper spot.
{{< /call-out >}}

To use the Image Processing routines on the page, use the  shortcode.

Here is an example that resizes an image:


GUIDES / GENERAL / DEVELOPING-SOFTWARE-IN-PUBLIC
------------------------------------------------------------

Index
Source: guides\general\developing-software-in-public\index.md
Overview

Over the last 20 years we've put together a process that helps us build customer delight. There are eight pieces to this process, and they are all equally important. For years, we built our own proprietary tools to support most of the parts of this process. But now, there are great commercially available tools - tools we encourage you to use, too.

Our Software Development process, just like the other processes, is a cycle. So we can start anywhere.

!Rhino Development Cycle

The Cycle

Since this is a developer guide, let's start with writing code.

Code

This is what we as software developers spend a lot of our time doing. We’ve got our favorite IDE open, we write code, we debug, we solve problems. We don’t know a software developer that doesn’t love solving problems.

When we’ve got something, we commit it to our version control system...

Commit

We commit code to a Version Control System. In our case, we use git with GitHub. There are many other version control systems out there. We used to use Subversion, but now we use GitHub. GitHub plays nicely with so many other tools and has such a rich API. But there are others worth considering: BitBucket, Mercurial, etc.

If you don’t use any version control, we beg you: please start. It’s so easy now. It lets you get back to other versions of your software before you introduced a problem. It helps you collaborate as a team. It is required for any kind of build automation. Did we mention it's easy?

As developers, we use a modified version of GitHub Flow to create and merge pull requests into our master branch.

After we commit our code, we build it...

Compile

In addition to compiling at our desks, we have dedicated TeamCity servers that constantly build our code, and verify that it works with our master branch on GitHub. This makes sure that we don’t break each other’s ability to get the latest code and compile.

These TeamCity servers verify every commit and also build our daily releases - many of them - ... [truncated]

GUIDES / GENERAL / ESSENTIAL-MATHEMATICS / MATRICES-TRANSFORMATIONS
------------------------------------------------------------

Index
Source: guides\general\essential-mathematics\matrices-transformations\index.md
Transformations refer to operations such as moving (also called translating), rotating, and scaling objects. They are stored in 3 D programming using matrices, which are nothing but rectangular arrays of numbers. Multiple transformations can be performed very quickly using matrices. It turns out that a [4x4] matrix can represent all transformations. Having a unified matrix dimension for all transformations saves calculation time.

{{}}$$\begin{array}{rcc} \mbox{matrix}&\begin{array}{cccc} c1& c2&c3&c4\end{array}\\\begin{array}{c}row(1)\\row(2)\\row(3)\\row(4)\end{array}& \left[\begin{array}{cr} +&+&+&+\\ +&+&+&+\\ +&+&+&+\\ +&+&+&+\end{array}\right] \end{array}$${{}}

2.1 Matrix operations

The one operation that is most relevant in computer graphics is matrix multiplication. We will explain it with some detail.

Matrix multiplication

Matrix multiplication is used to apply transformations to geometry. For example if we have a point and would like to rotate it around some axis, we use a rotation matrix and multiply it by the point to get the new rotated location.

{{}}$$\begin{array}{ccc} \text{rotate matrix} & \text{input point} & \text{rotate point}\\\begin{bmatrix}a & b & c & d \\e & f & g & h \\i & j & k & l \\0 & 0 & 0 & 1 \\\end{bmatrix}& \cdot\begin{bmatrix}x \\y\\z\\1 \\\end{bmatrix}&= \begin{bmatrix}x' \\y'\\z'\\1 \\\end{bmatrix}\end{array}$${{}} 

Most of the time, we need to perform multiple transformations on the same geometry. For example, if we need to move and rotate a thousand points, we can use either of the following methods.

Method 1 
Multiply the move matrix by 1000 points to move the points.
Multiply the rotate matrix by the resulting 1000 points to rotate the moved points. 

Number of operations = 2000. 

Method 2 
Multiply the rotate and move matrices to create a combined transformation matrix.
Multiply the combined matrix by 1000 points to move and rotate in one step.

Number of operations = 1001.

Notice that method 1 takes almost twice the... [truncated]

GUIDES / GENERAL / ESSENTIAL-MATHEMATICS / PARAMETRIC-CURVES-SURFACES
------------------------------------------------------------

Index
Source: guides\general\essential-mathematics\parametric-curves-surfaces\index.md
Suppose you travel every weekday from your house to your work. You leave at 8:00 in the morning and arrive at 9:00. At each point in time between 8:00 and 9:00, you would be at some location along the way. If you plot your location every minute during your trip, you can define the path between home and work by connecting the 60 points you plotted. Assuming you travel the exact same speed every day, at 8:00 you would be at home (start location), at 9:00 you would be at work (end location) and at 8:40 you would at the exact same location on the path as the 40th plot point. Congratulations, you have just defined your first parametric curve! You have used time as a parameter to define your path, and hence you can call your path curve a parametric curve. The time interval you spend from start to end (8 to 9) is called the curve domain or interval.

{{}} 

In general, we can describe the {{}}$$x$${{}}, {{}}$$y$${{}}, and {{}}$$z$${{}} location of a parametric curve in terms of some parameter {{}}$$t$${{}} as follows: 
&nbsp; {{}}$$x = x(t)$${{}} 
&nbsp; {{}}$$y = y(t)$${{}} 
&nbsp; {{}}$$z = z(t)$${{}} 
Where: 
&nbsp; {{}}$$t$${{}} is a range of real numbers 

{{}} 

We saw earlier that the parametric equation of a line in terms of parameter {{}}$$t$${{}} is defined as:

&nbsp; {{}}$$x = x’ + t a$${{}} 
&nbsp; {{}}$$y = y’ + t b$${{}} 
&nbsp; {{}}$$z = z’ + t c$${{}} 

Where:

&nbsp; {{}}$$x$${{}}, {{}}$$y$${{}}, and {{}}$$z$${{}} are functions of t where t represents a range of real numbers.
&nbsp; {{}}$$x’$${{}}, {{}}$$y’$${{}}, and {{}}$$z’$${{}} are the coordinates of a point on the line segment.
&nbsp; {{}}$$a$${{}}, {{}}$$b$${{}}, and {{}}$$c$${{}} define the slope of the line, such that the vector {{}}$$\mathbf{\vec v} $${{}} is parallel to the line.

{{}} 

We can therefore write the parametric equation of a line segment using a {{}}$$t$${{}} parameter that ranges between two real number values {{}}$$t0$${{}}, {{}}$$t1$${{}} and a unit vector {{}}$$\mathbf{\vec v}... [truncated]

Essential Code:
Private Sub RunScript(ByVal c1 As Curve, ByVal c2 As Curve, ByRef A As Object)

  'declare variables
  Dim continuity As New String("")
  Dim t1, t2 As Double
  Dim v_c1, v_c2, c_c1, c_c2 As Vector3d

  'extract start and end points
  Dim end_c1 = c1.PointAtEnd
  Dim start_c2 = c2.PointAtStart

  'check G0 continuity
  If end_c1.DistanceTo(start_c2) = 0 Then
    continuity = "G0"
  End If

  'check G1 continuity
  If continuity = "G0" Then
    'calculate tangents
    v_c1 = c1.TangentAtEnd
...
Private Sub RunScript(ByVal c1 As Curve, ByVal c2 As Curve, ByRef A As Object)

    //decalre variables
    string continuity = ("");
    double t1, t2;
    Vector3d v_c1, v_c2, c_c1, c_c2;

    //extract start and end points
    Point3d end_c1 = c1.PointAtEnd;
    Point3d start_c2 = c2.PointAtStart;

    //check G0 continuity
    if( end_c1.DistanceTo(start_c2) == 0){
      continuity = "G0";
    }

    //check G1 continuity
    if( continuity == "G0")
    {
      //calculate tangents
...

GUIDES / GENERAL / ESSENTIAL-MATHEMATICS / REFERENCES
------------------------------------------------------------

Index
Source: guides\general\essential-mathematics\references\index.md
References
Edward Angel, "InteractiveComputer Graphics with OpenGL,” Addison Wesley Longman, Inc., 2000.
James D Foley, Steven K Feiner, John FHughes, "Introduction to Computer Graphics" Addison-WesleyPublishing Company, Inc., 1997.
James Stewart, "Calculus,"Wadsworth, Inc., 1991.
Kenneth Hoffman, Ray Kunze, “LinearAlgebra”, Prentice-Hall, Inc., 1971
Rhinoceros® help document, RobertMcNeel and Associates, 2009.

Footnotes
Wikipedia: Projection (linear algebra)) 
Wikipedia: Cubic Hermite spline. 
Wikipedia: Bézier curve. 
Wikipedia: Non-uniform rational B-spline. 
Wikipedia: De Casteljau's algorithm. 
Wikipedia: NURBS. 
Wikipedia: De Boor's algorithm. 
MichiganTech, Department of Computer Science, De Boor's algorithm.

GUIDES / GENERAL / ESSENTIAL-MATHEMATICS / VECTOR-MATHEMATICS
------------------------------------------------------------

Index
Source: guides\general\essential-mathematics\vector-mathematics\index.md
A vector indicates a quantity, such as velocity or force, that has direction and length. Vectors in 3D coordinate systems are represented with an ordered set of three real numbers and look like:

{{}}$$\mathbf{\vec v} = $${{}}

{{}}

1.1 Vector representation

In this document, lower case bold letters with arrow on top will notate vectors. Vector components are also enclosed in angle brackets. Upper case letters will notate points. Point coordinates will always be enclosed by parentheses.

Using a coordinate system and any set of anchor points in that system, we can represent or visualize these vectors using a line-segment representation. An arrowhead shows the vector direction.

For example, if we have a vector that has a direction parallel to the x-axis of a given 3D coordinate system and a length of 5 units, we can write the vector as follows:

{{}}$$\mathbf{\vec v} = $${{}} 

To represent that vector, we need an anchor point in the coordinate system. For example, all of the arrows in the following figure are equal representations of the same vector despite the fact that they are anchored at different locations. 

 Figure (1): Vector representation in the 3-D coordinate system.

{{}}

Given a 3D vector {{}}$$\vec v = $${{}} , all vector components {{}}$$a1$${{}}, {{}}$$a2$${{}}, {{}}$$a3$${{}} are real numbers. Also all line segments from a point {{}}$$A(x,y,z)$${{}} to point {{}}$$B(x+a1, y+a2, z+a3)$${{}} are equivalent representations of vector {{}}$$\vec v$${{}}.

{{}} 

So, how do we define the end points of a line segment that represents a given vector?
Let us define an anchor point (A) so that:

{{}}$$A = (1, 2, 3)$${{}}

And a vector:

{{}}$$\mathbf{\vec v} = $${{}}

The tip point {{}}$$(B)$${{}} of the vector is calculated by adding the corresponding components from anchor point and vector {{}}$$\vec v$${{}}: 

{{}}$$B = A + \mathbf{\vec v}$${{}} 
{{}}$$B = (1+5, 2+6, 3+7) $${{}} 
{{}}$$B = (6, 8, 10)$${{}} 

 Figure (2): The relationship between a vecto... [truncated]

Essential Code:
Private Sub RunScript(ByVal pt As Point3d, ByVal srf As Surface, ByRef A As Object)

  'Declare variables
  Dim u, v As Double
  Dim closest_pt As Point3d

  'get closest point u, v
  srf.ClosestPoint(pt, u, v)

  'get closest point
  closest_pt = srf.PointAt(u, v)

  'calculate direction from closest point to test point
  Dim dir As New Vector3d(pt - closest_pt)

  'calculate surface normal
  Dim normal = srf.NormalAt(u, v)

  'compare the two directions using the dot product
  A = dir * normal
...
private void RunScript(Point3d pt, Surface srf, ref object A)
{
  //Declare variables
  double u, v;
  Point3d closest_pt;

  //get closest point u, v
  srf.ClosestPoint(pt, out u, out v);

  //get closest point
  closest_pt = srf.PointAt(u, v);

  //calculate direction from closest point to test point
  Vector3d dir = pt - closest_pt;

  //calculate surface normal
  Vector3d normal = srf.NormalAt(u, v);

  //compare the two directions using the dot product
  A = dir * normal;
...

GUIDES / GENERAL / FREQUENTLY-ASKED-QUESTIONS
------------------------------------------------------------

Index
Source: guides\general\frequently-asked-questions\index.md
Which SDK is right for me?

It all depends on what you want to do. If you are looking to automate repetitive tasks in Rhino, writing a Python script is the way to go. If you are looking to write a full-fledged plugin or Grasshopper component, we strongly suggest the RhinoCommon SDK. If you are very proficient with C/C++, you should consider the native C/C++ SDK (only supported on Rhino for Windows).

Can I write plugins that run on both Windows and Mac?

Yes...even using the same code.

What are Macros?

Macros are string of Rhino commands and command options that allow you to create an automated sequence of operations. This macro (sequence) can then be repeated at the push of a toolbar button or by typing an alias.

What are Scripts?

For more complex tasks, macros are insufficient. They lack the ability to make complex calculations, store and retrieve data, analyze that data and make conditional decisions, or reach deep into the inner workings of Rhino. For this, one needs a real programming tool. The simplest and most accessible of these is Python, which also includes its version of RhinoScript syntax. When we talk about scripts we are usually referring to functions written with RhinoScript or Python.

What are Plugins?

Plugins are even more sophisticated tools: these are compiled computer programs that can be integrated into Rhino. These can range from simple script-like functions to complex, full blown programs for doing rendering, animation, machining, etc.

What is your release schedule?

Weekly! (if all goes well) but - for most users - the answer is monthly. See our Release Schedule 

GUIDES / GENERAL / HOW-THIS-SITE-WORKS
------------------------------------------------------------

Index
Source: guides\general\how-this-site-works\index.md
Every time a commit is pushed to this git repository's main branch, a static site-generator called Hugo churns through all the markdown content to generate html for the site.

Workflow

The best way to understand how this site works is to make a change to it. Follow these steps:
If you have not already, read the README's Getting Started section. This will get you setup building the entire site locally on your computer so you can preview changes before making them live (by committing and pushing).
With the site up and running on your localhost, make a change to one of the pages (find a typo...there are many). A good editor for Markdown is the Visual Studio Code. Once you save your changes to the .md file, Hugo will automatically refresh the page with your changes.
If you are satisfied with your change, use git to commit your change to the GitHub repository (or submit a pull-request for review).
Wait a minute or two (If you issued a pull-request, your change won't be live until a git administrator accepts it).
On the live developer.rhino3d.com, you should see your change.

Frontmatter

The top of each file in the /contents/en folder - "content" for short - contains metadata called "frontmatter." This frontmatter is in the toml format between the first +++ and the second +++. For example, this guide's source has:




This toml metadata determines how this piece of content is organized and presented in lists. Hugo has some default frontmatter entries (like title = "Something something"), but the key/value pairs can be customized to our liking. This frontmatter is used - at the time the site is built - to determine how the page renders.

Markdown

Nearly all content on this site uses Markdown as the base format. We are using the Goldmark markdown parser, which is the default parser with Hugo. A complete guide to Markdown is beyond the scope of this guide. For markdown syntax, refer to the Hugo Markdown Guide or use other files on this site as examples. Everything ... [truncated]

GUIDES / GENERAL / OSCAR-QUICK-START
------------------------------------------------------------

Index
Source: guides\general\oscar-quick-start\index.md
No matter. Try again. Fail again. Fail better. -Beckett

Steps to Success
Grind enough coffee to just about fill two "wedges" in the doser.
{{}}
Get some into the basket, maybe half, and then optionally lightly tap the PortaFilter on the table once or twice to "declump" a bit and settle the grounds:
!Clumpy and settled and less clumpy
Fill to about level with, or a bit below, the rim. If you’ve tapped & settled, you’ll want the level lower before you start to tamp; if not, even with the rim is OK, as there will be more compression on tamping:
{{}}
Tamp...firmly but, especially, levelly. The tradition says ~30 lbs. of pressure, but the geeks will tell you consistency is more important than the exact pressure. The sweet spot with our setup seems to be to get the tamper shoulder at, or just slightly below, the rim of the basket.
{{}}
If in doubt about the amount, lock the PortaFilter in and then take it out - if there is an imprint from the shower screen screw, there is too much coffee.
!The Imprint
Scratch off a mm or two and polish with the tamper.
When you’re ready to go, lock in the PortaFilter and push the left hand button to start the pump - it will ramp up and then be steady - push again to stop the pump and have your shot. Ideally, on starting the pump, there will be a few seconds pause before a thin trickle starts and you’ll get a double shot in 20-30 seconds.
Unlock the PortaFilter and knock out the puck, rinse the PortaFilter. Use the brush to get grounds off of the shower screen and group gasket, then give it a last burst of clear water from the pump to rinse. Put the PortaFilter back so it stays hot.
Check the water level and fill it with the pitcher from the filtered water at the sink, if needed. Oscar misbehaves if it runs out of water.

Extra Credit
Heat Exchange machines like Oscar tend to super-heat the water that is waiting to go into the group when you start the shot well above boiling due to pressure in the boiler. Since the ideal temperature is so... [truncated]

GUIDES / GENERAL / RHINO-DEVELOPER-PREREQUISITES
------------------------------------------------------------

Index
Source: guides\general\rhino-developer-prerequisites\index.md
There are a number of prerequisites required to do Rhino development. Broadly speaking, these can be divided into three categories, ranked in ascending order of difficulty:
Hardware prerequisites
Software prerequisites
Programming Knowledge

Hardware

If you are reading this guide, you likely already have a computer that can run Rhino. (If not, Rhino has some minimum System Requirements that you should review before acquiring any hardware). Generally speaking, any computer that can run Rhino ought to be able to run the developer tools outlined in the Software section.

If you are a Windows user and wish to develop plugins for Rhino for Mac, you will need an Apple Mac computer. Conversely, if you are an macOS user and you wish to develop for Rhino for Windows, you will need a computer that can run Rhino for Windows (however, virtual machines running Windows under macOS can potentially work just fine).

Software

Depending on what you want to do, the software prerequisites vary. However, in general, you will need:
Rhinoceros
A code editor. There are many options...here are a few:
Visual Studio for Windows: Microsoft's flagship Integrated Development Environment (IDE) for Windows.
Visual Studio Code: The best free cross-platform editor

See the SDK-specific guides for the software prerequisites...normally found in the "Installing Tools" guides.

Programming Knowledge

Acquiring programming knowledge is the most labor intensive prerequisite. However, learning to program - even trying out a new language - is fun and enriching. Learning to program using Rhino is a great way to begin...

Learning C# .NET

If you wish to write plugins with RhinoCommon, you will need to understand a .NET compatible programming language like C# (or VB). We recommend C#) (C Sharp) because it is modern, safe, and easy to learn - and you can develop in C# on both Windows and macOS.

Watch...
Beginning C# Programming By Eric Lippert - Published by O'Reilly Media
C# Fundamentals for Absolute Begin... [truncated]

GUIDES / GENERAL / RHINO-INSTALLER-ENGINE
------------------------------------------------------------

Index
Source: guides\general\rhino-installer-engine\index.md
{{}}
⚠️ This technology is obsolete as of Rhino 7 and has been replaced by the yak format along with the PackageManager.
{{}}

Overview (Windows)

The Rhino Installer Engine simplifies distribution, installation and updating of plug-ins for Rhino for Windows.

How It Works

File and folder structure

A Rhino Installer package is a zip file with an .rhi extension. The package can include more than one version of a plug-in however all versions must share the same GUID (i.e. they're different versions of the same plug-in).

There are no file structure or naming requirements. For example the two packages below are functionally equivalent. Both contain versions of "Marmoset" – a fictitious C++ plug-in compiled for Rhino 5 (32-bit and 64-bit) and Rhino 6[^1].


Marmosettree.rhi/
├── Rhino 6/
│ ├── Marmoset.rhp
│ ├── Marmoset.dll
│ └── Marmoset.rui
└── Rhino 5.0/
 ├── x86/
 │ ├── Marmoset.rhp
 │ └── ...
 └── x64/
 ├── Marmoset.rhp
 └── ...



Marmosetflat.rhi/
├── Marmosetrhino6.rhp
├── Marmosetrhino5x86.rhp
├── Marmosetrhino5x64.rhp
├── Marmosetrhino6.dll
├── ...
└── Marmoset.rui


You can include anything you want in the .rhi package – supporting DLLs, help files, documentation, toolbar (.rui) files, etc. The entire contents are unzipped to a directory on the user's machine.

Installation and compatibility

The Rhino Installer Engine examines each .rhp file and extracts the plugin GUID, Title, Version, the SDK used (e.g. RhinoCommon, C++) and the SDK version. This information is used to determine which version of the plug-in will be installed for which installed version of Rhino for Windows; the newest compatible plugin is registered with the corresponding version of Rhino. RhinoCommon plug-ins compiled as AnyCPU will be installed for both 32- and 64-bit Rhino 5[^1].

{{}}
Since Rhino 6: Where a RhinoCommon plug-in is found that has been compiled against an earlier major version of Rhino than is installed, an in-depth compatibility check will be performed to determ... [truncated]

GUIDES / GENERAL / RHINO-TECHNOLOGY-OVERVIEW
------------------------------------------------------------

Index
Source: guides\general\rhino-technology-overview\index.md
Overview

Rhinoceros is composed of many layers - written in many languages - all stacked on top of each other. The most foundational are on the bottom, but the top layers should by no means be considered superficial...

!The Rhino Stack

Let's discuss each of the layers in turn, starting on the bottom with the...

Foundation

C++ Rhino Core

The C++ Core of Rhino is the oldest and broadest set of code. We use Microsoft’s MFC in places, including the SDK. This is where the runtime document is managed, where all the OpenGL viewport drawing code exists, and it’s where the computational geometry code written by our mathematicians lives. Many of Rhino's commands are here.

Lots of user interface - the command line, the application mainframe, status bar, and the dialog boxes for many commands in the Rhino core.

openNURBS

openNURBS is free C++ source code that lets you read and write Rhino 3dm files - all the way back to version 1. openNURBS was our first open-source project.

The code compiles on Windows, macOS, Linux, iOS, and Android. It's used in various third-party applications like ArchiCAD, SolidWorks, Inventor, SketchUp and many other products to read or write 3dm files directly.

openNURBS is what Rhino uses natively to read/write 3dm files. This toolkit is released before Rhino, so any product, including our competitors, can be compatible with the latest 3dm files. There is no difference between the 3dm files Rhino writes and those of other applications using openNURBS to read and write 3dm.


C++ SDK

On top of all of this is our C++ SDK, available only on Windows.

Compiling against the C++ SDK requires a specific version of Microsoft Visual Studio and the Microsoft C-Runtime. You have to recompile for every major version of Rhino.

Virtually everything Rhino can do is exposed through the C++ SDK. Some commands and features haven’t been exposed yet, but this SDK is very broad and rich.

U... [truncated]

GUIDES / GENERAL / RHINO-UI-SYSTEM
------------------------------------------------------------

Index
Source: guides\general\rhino-ui-system\index.md
This guide proves an overview of Rhino's User Interface (UI) system, and it compares the new system found in Rhino 8 with the previous system found in Rhino 7 and earlier.

Rhino 8 UI System

The goals of the new Rhino 8 UI system were to:
Display panels and toolbars in the same container.
Reference toolbars and macros from multiple sources without having to copy definitions from one RUI file to another.
Deliver Rhino User Interface (RUI) changes without overwriting or replacing existing files in Rhino or plug-in service releases. (In prior Rhino versions, replacing the RUI file to deliver updated toolbars and macros caused user changes to RUI files to be overwritten.)
Quickly change the Rhino UI to display task-orientated tools.
Share UI layouts amongst users.
Allow users to arbitrarily modify the UI without having to be aware of the location or source of a UI component and to automatically track changes.
Provide unified Windows and Mac UI.

The major changes in the new Rhino 8 UI system are:
Toolbar Groups have been replaced by Containers. Containers can display both panels and toolbars.
RUI files are used to provide toolbar and macro libraries, and they are no longer modified directly. Rhino tracks RUI changes and applies them when loading. Doing this allows Rhino to deliver updated RUI files without losing user changes to a toolbar or macro.
Window Layouts have been added and can be used to quickly switch between different UI configurations. They can be exported as files and will include modifications to toolbars and macros and user RUI files
Importing a Window Layout will extract user RUI files as necessary and apply RUI modifications.

The new Rhino 8 UI System is designed to allow for the referencing UI components from many sources: including panels, toolbars, and macros, defined by any RUI file or plug-in. When Rhino closes, changes to the UI are saved and original RUI files are never modified unless specifically requested. Configurations of UI layouts can b... [truncated]

GUIDES / GENERAL / WHAT-IS-A-RHINO-PLUGIN
------------------------------------------------------------

Index
Source: guides\general\what-is-a-rhino-plugin\index.md
A Rhino plugin is a software module that extends the functionality of Rhino or Grasshopper by adding commands, features, or capabilities. A Rhino plugin is a Dynamic Link Library, or DLL.

On Windows, a Rhino plugin built with the C/C++ SDK is a regular DLL using shared MFC DLL.

On Windows and Mac, a Rhino plugin built with the RhinoCommon SDK is a .NET assembly.

Examples of Rhino plugins include Grasshopper, Brazil, Flamingo, and Bongo. See food4rhino.com for more.

Types of Plugins

Rhino supports five different types of plugins:
General Utility: A general purpose utility that can contain one or more commands.
File Import: Imports data from other file formats into Rhino; can support more that one format.
File Export: Exports data from Rhino to other file formats; can support more than one format.
Custom Rendering: Applies materials, textures, and lights to a scene to produce rendered images.
3D Digitizing: Interfaces with 3D digitizing devices, such as those made by MicroScribe, Faro, & Romer.

 Thus, all plugin types can contain one or more commands.

Plugin Compatibility

For Rhino to successfully load and run your plugin, several conditions must be met:
The "RhinoSdkVersion" number of your plugin must match the "RhinoSdkVersion" of Rhino.
The "RhinoSdkServiceRelease" number of Rhino must be greater than or equal to the "RhinoSdkServiceRelease" of your plugin.

We occasionally make changes to our SDKs. When we do, we change the "RhinoSdkServiceRelease" number. 

As a plugin developer you are unlikely to encounter a problem with the first condition. This would occur, for instance, if a user tried to load a plugin built for Rhino 6 in Rhino 4.

You may however, occassionally encounter problems with the second condition. If you compiled your plugin using the 6.2 (RhinoSdkVersion.RhinoSdkServiceRelease) SDK and a user running a ... [truncated]

GUIDES / GRASSHOPPER / COMPONENTS-WITH-VARIABLE-NUMBER-OF-PARAMETERS
------------------------------------------------------------

Index
Source: guides\grasshopper\components-with-variable-number-of-parameters\index.md
{{}}
This guide has yet to be ported to this site. Please check back soon for updates.
{{}}

GUIDES / GRASSHOPPER / CSHARP-ESSENTIALS / 1-GRASSHOPPER-CSHARP-COMPONENT
------------------------------------------------------------

Index
Source: guides\grasshopper\csharp-essentials\1-grasshopper-csharp-component\index.md
1.1 Introduction

Grasshopper supports multiple scripting languages such as C#, Python, and VB.NET to help develop custom components using the Rhino and Grasshopper SDKs (software development kit). Rhino publishes a cross-platform SDK for .NET languages called RhinoCommon. The documentation of the SDK and other developer resources are available at Rhino Developer Documentation.

1.2 C# Component Interface

The scripting components are integrated within Grasshopper and have a similar interface to that of other typical components. They can read input & produce output, and they have an editor to write custom code with access to RhinoCommon. They are used to create specialized code and workflows not supported by other Grasshopper components. You can also use them to simplify, optimize, and streamline your definitions by combining multiple functions.

To add an instance of the C# script component to the canvas, drag & drop the component from the Script panel under the Maths tab. The default script component has two inputs and two outputs. The user can change the names of input and output, set the input data type and data structure, and also add more inputs and outputs parameters or remove them. We will explain how to do all that shortly.

 Figure(1): The C# component and its location in the toolbar. x: first input parameter. y: second input parameter. out: output string with compiling messages. a: Returned output of type object.

Alternatively, you can use the generic Script component, then click on the C# at the margin.

 Figure(2): The default Script component in Grasshopper

1.3 The Input Parameters

By default, there are two input parameters named x and y. It is possible to edit the parameters’ names, delete them or add new ones. If you zoom in, you will notice a few “+” and “-” signs appearing. You can click on those to add or remove parameters. You can also right-click on a parameter to change its name. Note that the names of the parameters and their types are pass... [truncated]

GUIDES / GRASSHOPPER / CSHARP-ESSENTIALS / 2-CSHARP-BASICS
------------------------------------------------------------

Index
Source: guides\grasshopper\csharp-essentials\2-csharp-basics\index.md
2.1 Introduction

This chapter covers basic C# programming concepts. It serves as an introduction and quick reference to C#'s language syntax. It is not meant to be complete by any measure, so please refer to the C# resources available online and in print. All examples in this chapter are implemented using the Grasshopper C# component. For additional documentation The Microsoft CSharp Programming Guide is a good resource.

2.2 Comments

Comments are very useful to describe your code in plain language. They are useful as a reminder for you and also for others to help them understand your code. To add a comment, you can use two forward slashes // to signal that the rest of the line is a comment and the compiler should ignore it. In the Grasshopper C# code editor, comments are displayed in green. You should enclose a multi-line comment between / and / as in the following example.

C#
// The compiler ignores this line 
/
 The compiler ignores all lines enclosed 
 within this area
/


2.3 Variables

You can think of variables as labeled containers in your computer’s memory where you can store and retrieve data. Your script can define any number of variables and label them with the names of your choice, as long as you do not use spaces, special characters, or reserved words by the programming language. Try to always use variable names that are descriptive of the data you intend to store. This will make it easier for you to remember what kind of information is stored in each variable.

 Figure(16): How variables are stored in a computer's memory

Your script uses variable names to access the value stored in them. In general, you can assign new values to any variable at any point in your program, but each new value wipes out the old one. When you come to retrieve the value of your variable, you will only get the last one stored. For example, let’s define a variable and name it x. Suppose we want x to be of type integer. Also, suppose we would like to assign it an initial... [truncated]

Essential Code:

Let us dissect all the different parts of the above statement:

<table class="multiline">
<tr>
<td><b>int</b></td>
<td>The type of your data. int is a special keyword in <b>C#</b> that means the type of the variable is a signed integer (can be a positive or negative whole number)</td>
</tr>
<tr>
<td><b>x</b></td>
<td><i>The name of the variable</i></td>
</tr>
<tr>
<td><b>=</b></td>
<td>Used for assignment and it means the value that follows will be stored in the variable x</td>
</tr>
<tr>
<td><b>10</b></td>
<td>The initial value stored in the <b>x</b> variable</td>
</tr>
...

Notice how you use the namespace followed by “.” to access the classes within that namespace. If you do not want to type the namespace each time you need to access one of the classes within that namespace, then you can use the **using** keyword as in the following:


GUIDES / GRASSHOPPER / CSHARP-ESSENTIALS / 3-RHINOCOMMON-GEOMETRY
------------------------------------------------------------

Index
Source: guides\grasshopper\csharp-essentials\3-rhinocommon-geometry\index.md
3.1 Overview

RhinoCommon is the .NET SDK for Rhino. It is used by Rhino plug-in developers to write .NET plug-ins for Rhino and Grasshopper. All Grasshopper scripting components can access RhinoCommon including all geometry objects and functions. For the whole namespace, see the RhinoCommon documentation.

In this chapter, we will focus on the part of the SDK dealing with Rhino geometry. We will show examples of how to create and manipulate geometry using the Grasshopper C# component.

The use of the geometry classes in the SDK requires basic knowledge in vector mathematics, transformations, and NURBS geometry. If you need to review or refresh your knowledge in these topics, then refer to the Essential Mathematics for Computational Design

If you recall from Chapter 2, we worked with value types such as int and double. Those are system built-in types provided by the programming language, C# in this case. We also learned that you can pass the value types to a function without changing the original variables (unless passed by reference using the ref keyword). We also learned that some types, such as objects, are always passed by reference. That means changes inside the function also changes the original value.

The system built-in types, whether they are value or reference types, are often very limiting in specialized programming applications. For example, in computer graphics, we commonly deal with points, lines, curves, or matrices. These types need to be defined by the SDK to ease the creation, storage, and manipulation of geometry data. Programming languages offer the ability to define new types using structures (value types) and classes (reference types). The RhinoCommon SDK defines many new types as we will see in this chapter.

3.2 Geometry Structures

RhinoCommon defines basic geometry types using structures. We will dissect the Point3d structure, show how to read in the documentation, and use it in a script. This should help you navigate and use other struct... [truncated]

Essential Code:

Point3d Properties

Properties are mostly used to “get” and/or “set” the fields of the structure. For example, there are the “X”, “Y”, and “Z” properties to get & set the coordinates of an instance of **Point3d**. Properties can be **static** to get specific points, such as the origin of the coordinate system (0,0,0). The following are **Point3d** properties as they appear in the documentation:

<img src="properties.png">
 
Here are two GH examples to show how to get & set the coordinates of a **Point3d**. 

<img src="set_point3d.png">


Static properties get or set a generic data of that type. The above example uses the static **Point3d** method **Unset** to unset the new point. Another example that is commonly used is the **origin** property in **Point3d** to get the origin of the coordinate system, which is (0,0,0) as in the following example.

<img src="get_origin_point.png">


GUIDES / GRASSHOPPER / CSHARP-ESSENTIALS / 4-DESIGN-ALGORITHMS
------------------------------------------------------------

Index
Source: guides\grasshopper\csharp-essentials\4-design-algorithms\index.md
4.1 Introduction

In this chapter we will implement a few examples to create mathematical curves & surfaces and solve a few generative algorithms using C# in Grasshopper. Many of the examples involve using loops & recursions, which are not supported in regular Grasshopper components.

4.2 Geometry Algorithms

It is relatively easy to create curves & surfaces that follow certain mathematical equations when you use scripting. You can generate control points to create smooth NURBS or interpolate points to create the geometry.

4.2.1 Sine Curves & Surface

The following example shows how to create NurbsCurves, NurbsSurfaces, and a lofted Brep using the sine of an angle:

Create curves & surface using the sine equation

C#
private void RunScript(int num, ref object OutCurves, ref object OutSurface, ref object OutLoft)
{
 // List of all points
 List allPoints = new List();
 // List of curves
 List curves = new List();

 for(int y = 0; y crvPoints= new List();
 for(int x = 0; x 

C#
private void RunScript(Point3d pt0, Point3d pt1, Point3d pt2, Point3d pt3, int segments, ref object BezierCrv)
{
 if(segments bezierPts = new List();
 bezierPts.Add(pt0);
 bezierPts.Add(pt1);
 bezierPts.Add(pt2);
 bezierPts.Add(pt3);

 List evalPts = new List();
 double step = 1 / (double) segments;
 for(int i = 0; i points, double t, ref Point3d evalPt)
{
 // Stopping condition - point at parameter t is found
 if(points.Count tPoints = new List();
 for(int i = 1; i 

C#
private void RunScript(Surface srf, List inPolylines, int degree, ref object OutPolylines, ref object OutMesh)
{
 // Instantiate the collection of all panels
 List outPanels = new List();
 // Limit to 6 subdivisions
 if( degree > 6)
 degree = 6;
 for(int i = 0; i plines = new List();
 // Mid polylines
 List midPlines = new List();
 // Generate subdivided panels
 bool result = SubPanelOnSurface(srf, inPolylines, ref plines, ref midPlines);
 if( result == false)
 break;
 // Add outer panels
 outPanels.AddRange(plines);
 // Ad... [truncated]

Essential Code:

4.2.2 De Casteljau Algorithm to Interpolate a Bezier Curve

You can create a cubic Bezier curve from four input points. The De Casteljau algorithm is used in computer graphics to evaluate the Bezier curve at any parameter. If evaluated at multiple parameters, then the points can be connected to draw the curve. The following example shows a recursive function implementation to interpolate through a Bezier curve:

The De Casteljau algorithm to draw a Bezier curve with 2, 4, 8, and 16 segments

<img src="de_casteljau.png">


4.3 Generative Algorithms

Most of the generative algorithms require recursive functions that are only possible through scripting in Grasshopper. The following are four examples of generative solutions to generate the dragon curve, fractals, penrose tiling, and game of life:

4.3.1 Dragon Curve

<table>
<tr>
<td>
<img src="dragon_var.png" class="float_left" width="325">
</td>
<td>
<img src="dragon_curve.png">
</td>
</tr>
</table>


GUIDES / GRASSHOPPER / CUSTOM-ATTRIBUTES
------------------------------------------------------------

Index
Source: guides\grasshopper\custom-attributes\index.md
Overview

Objects on the Grasshopper canvas consist of two parts. The most important piece is the class that implements the IGHDocumentObject interface. This interface provides the basic plumbing needed to make objects work within a Grasshopper node network. The interface part of objects however is handled separately. Every IGHDocumentObject carries around an instance of a class that implements the IGHAttributes interface (indeed, every IGHDocumentObject knows how to create its own stand-alone attributes) and it is this class that takes care of display, mouse interactions, popup menus, tooltips and so forth.

In this guide we'll see how you can create your own attributes object. Since it's not possible to have an IGHAttributes instance work on its own, we need an IGHDocumentObject to tie it to. For this guide we'll assume we have a custom simple parameter (i.e. without persistent data) that holds integers.

Attributes Object

 C#
 VB.NET


public class MySimpleIntegerParameter : GHParam
{
 public MySimpleIntegerParameter() :
 base(new GHInstanceDescription("Integer with stats", "Int(stats)",
 "Integer with basic statistics",
 "Params", "Primitive")) { }

 public override System.Guid ComponentGuid
 {
 get { return new Guid("{33D07726-8298-4104-9EBC-5398D8AD5421}"); }
 }
}




Public Class MySimpleIntegerParameter
 Inherits GHParam(Of Types.GHInteger)

 Public Sub New()
 MyBase.New(New GHInstanceDescription("Integer with stats", "Int(stats)", "Integer with basic statistics", "Params", "Primitive"))
 End Sub

 Public Overrides ReadOnly Property ComponentGuid() As System.Guid
 Get
 Return New Guid("{33D07726-8298-4104-9EBC-5398D8AD5420}")
 End Get
 End Property
End Class


What we'll do is create a special attributes object for this parameter which also displays the median and mean values of the collection of all integers. We want to put this information below the parameter name, but inside the parameter box. The first step here is to override the CreateAttr... [truncated]

Essential Code:
public class MySimpleIntegerParameter : GH_Param<Types.GH_Integer>
{
  public MySimpleIntegerParameter() :
    base(new GH_InstanceDescription("Integer with stats", "Int(stats)",
                                    "Integer with basic statistics",
                                    "Params", "Primitive")) { }

  public override System.Guid ComponentGuid
  {
    get { return new Guid("{33D07726-8298-4104-9EBC-5398D8AD5421}"); }
  }
}


Public Class MySimpleIntegerParameter
  Inherits GH_Param(Of Types.GH_Integer)

  Public Sub New()
    MyBase.New(New GH_InstanceDescription("Integer with stats", "Int(stats)", "Integer with basic statistics", "Params", "Primitive"))
  End Sub

  Public Overrides ReadOnly Property ComponentGuid() As System.Guid
    Get
      Return New Guid("{33D07726-8298-4104-9EBC-5398D8AD5420}")
    End Get
  End Property
End Class


GUIDES / GRASSHOPPER / CUSTOM-COMPONENT-OPTIONS
------------------------------------------------------------

Index
Source: guides\grasshopper\custom-component-options\index.md
It skips over some portions of Component design which have already been handled in previous guides, so do not read this guide before familiarizing yourself with the Simple Component guide.

Overview

The component we'll create in this article will sort a list of numbers and have the custom option to convert those numbers to absolute values prior to sorting. However, rather than providing this option as a boolean input parameter, we'll allow people to set it via the Component context menu. We'll need to do four special things to achieve this, to wit:
Declare a class level variable/property.
Provide access to the variable from within the Component menu.
Include the variable in (de)serialization.
Record undo events when changing the value.

Example Component

Before you start with this guide, create a new class that derives from GHComponent, as outlined in the Simple Component guide.

This component will require one input parameter and one output parameter, both of type Number with list access:

 C#
 VB.NET


...
 protected override void RegisterInputParams(Kernel.GHComponent.GHInputParamManager pManager)
 {
 pManager.AddNumberParameter("Values", "V", "Values to sort", GHParamAccess.list);
 }
 protected override void RegisterOutputParams(Kernel.GHComponent.GHOutputParamManager pManager)
 {
 pManager.AddNumberParameter("Values", "V", "Sorted values", GHParamAccess.list);
 }
...




...
Protected Overrides Sub RegisterInputParams(ByVal pManager As GHComponent.GHInputParamManager)
 pManager.AddNumberParameter("Values", "V", "Values to sort", GHParamAccess.list)
End Sub
Protected Overrides Sub RegisterOutputParams(ByVal pManager As Kernel.GHComponent.GHOutputParamManager)
 pManager.AddNumberParameter("Values", "V", "Sorted values", GHParamAccess.list)
End Sub
...


Assuming for now we'll have a local property called Absolute() which gets a single boolean, we can also already write the SolveInstance() method:

 C#
 VB.NET


...
 protected override void SolveI... [truncated]

Essential Code:
...
  protected override void RegisterInputParams(Kernel.GH_Component.GH_InputParamManager pManager)
  {
    pManager.AddNumberParameter("Values", "V", "Values to sort", GH_ParamAccess.list);
  }
  protected override void RegisterOutputParams(Kernel.GH_Component.GH_OutputParamManager pManager)
  {
    pManager.AddNumberParameter("Values", "V", "Sorted values", GH_ParamAccess.list);
  }
...


...
  protected override void SolveInstance(Kernel.IGH_DataAccess DA)
  {
    List<double> values = new List<double>();
    if ((!DA.GetDataList(0, values)))
      return;
    if ((values.Count == 0))
      return;

    // Don't worry about where the Absolute property comes from, we'll get to it soon.
    if ((Absolute))
    {
      for (Int32 i = 0; i < values.Count; i++)
      {
        values(i) = Math.Abs(values(i));
      }
    }

    values.Sort();
    DA.SetDataList(0, values);
...

GUIDES / GRASSHOPPER / EXTENDING-THE-GUI
------------------------------------------------------------

Index
Source: guides\grasshopper\extending-the-gui\index.md
We'll focus on components as you should be familiar with those from earlier topics, but the same logic also applies to Parameters and custom objects.

Default Functionality and GUI

When you derive a class from GHComponent or GHParam(T) you get a lot of functionality and GUI for free. It is quite important that all the objects in Grasshopper behave in a consistent and predictable fashion so you typically don't need to override this default behaviour. However there can be cases where changing the default Grasshopper GUI is the best solution. Overriding the GUI is not exactly a trivial task, there are a lot of different facets to this and I'll discuss the most important ones in this topic.

There are three common ways in which the default GUI can be altered:
Menus
Interaction
Display

Menus

It is possible to insert items into the default pop-up menus of objects, or even to completely alter the menu layout. If your component for example can run in two different modes, you can choose to expose an additional GUI option instead of an input parameter. These modes can then be toggled via the component pop-up menu.

At the lowest level, pop-up menus are generated by the canvas when a right mouse button click is detected over a component or parameter. The menu by default contains no items and it is the responsibility of said component or parameter to populate the menu. The top-level method which is in charge of this is AppendMenuItems which is defined inside IGHDocumentObject and thus propagates to all objects on the canvas.

The GHDocumentObject abstract class does not create any menu items, so unless this function is overridden, there will be no popup menu for a certain object. However, it is unlikely you derive directly from GHDocumentObject so this should not be a problem. GHActiveObject, which is the base class for all objects on the canvas that actually do something (Sketches and Scribbles don't "do" anything, hence they derive directly from GHDocumentObject), does pro... [truncated]

Essential Code:
public override bool AppendMenuItems(ToolStripDropDown menu)
{
  Menu_AppendGenericMenuItem(menu, "First item");
  Menu_AppendGenericMenuItem(menu, "Second item");
  Menu_AppendGenericMenuItem(menu, "Third item");
  Menu_AppendSeparator(menu);
  Menu_AppendGenericMenuItem(menu, "Fourth item");
  Menu_AppendGenericMenuItem(menu, "Fifth item");
  Menu_AppendGenericMenuItem(menu, "Sixth item");

  // Return true, otherwise the menu won't be shown.
  return true;
}


Public Overrides Function AppendMenuItems(ByVal menu As ToolStripDropDown) As Boolean
  Menu_AppendGenericMenuItem(menu, "First item")
  Menu_AppendGenericMenuItem(menu, "Second item")
  Menu_AppendGenericMenuItem(menu, "Third item")
  Menu_AppendSeparator(menu)
  Menu_AppendGenericMenuItem(menu, "Fourth item")
  Menu_AppendGenericMenuItem(menu, "Fifth item")
  Menu_AppendGenericMenuItem(menu, "Sixth item")

  'Return True, otherwise the menu won't be shown.
  Return True
End Function


GUIDES / GRASSHOPPER / GH-ALGORITHMS-AND-DATA-STRUCTURES / ADVANCED-DATA-STRUCTURES
------------------------------------------------------------

Index
Source: guides\grasshopper\gh-algorithms-and-data-structures\advanced-data-structures\index.md
This chapter is devoted to the advanced data structure in GH, namely the data trees, and different ways to generate and manage them. The aim is to start to appreciate when and how to use tree structures, and best practices to effectively use and manipulate them.

3.1 The Grasshopper data structure

3.1.1 Introduction
{{}} Introduction to data trees

In programming, there are many data structures to govern how data is stored and accessed. The most common data structures are variables, arrays, and nested arrays. There are other data structures that are optimised for specific purposes such as data sorting or mining. In Grasshopper, there is only one structure to store data, and that is the data tree. Hold on, what about what we have learned so far: single item and list of items? Well, in GH, those are nothing but simple trees. A single item is a tree with one branch, that has one element, and a list is a tree with one branch that has a number of elements. It is actually pretty elegant to be able to fit all data in one unifying data structure, but at the same time, this requires the user to be aware and vigilant about how their data structure changes between operations, and how that can affect intended results. This chapter attempts to demystify the data tree of Grasshopper.

3.1.2 Processing data trees

We used the Panel and Parameter Viewer components to view the data structure. We will use both extensively to show how data is stored. Let’s start with a single item input. The Parameter Viewer has two display modes, one with text and one that is graphical. You can see that the single item input is stored in one branch that has only one item.

 Figure(51): Different ways to preview the data structure in Grasshopper

The Parameter Viewer shows each branch address (called “Path”), and the number of elements in that branch as shown in Figure (52).

 Figure(51): The Parameter Viewer indicates the path address and the number of elements in each branch

A list of items is typ... [truncated]

GUIDES / GRASSHOPPER / GH-ALGORITHMS-AND-DATA-STRUCTURES / ALGORITHMS-DATA
------------------------------------------------------------

Index
Source: guides\grasshopper\gh-algorithms-and-data-structures\algorithms-data\index.md
1.1 Algorithmic design
{{}} Algorithmic design

We can define algorithmic design as a design method where the output is achieved through well-defined steps. In that sense, many human activities are algorithmic. Take, for example, baking a cake. You get the cake (output) by using a recipe (well-defined steps). Any change in the ingredients (input) or the baking process results in a different cake. We will analyze the parts of typical algorithms, and identify a strategy to build algorithmic solutions from scratch.

Regardless of its complexity, all algorithmic solutions have 3 building blocks: input, key process, and output. Note that the key process may require additional input and processes.

 Figure(1): The building blocks of algorithmic solutions

Throughout this text, we will organize and label the solutions to identify the three blocks clearly. We will also use consistent color coding to visually distinguish between the parts. This will help us become more comfortable with reading algorithms and quickly identify input, key processing steps, and properly collect and display output. Visual cues are important to develop fluency in algorithmic thinking.

In general, reading existing algorithmic solutions is relatively easy, but building new ones from scratch is much harder and requires a new set of skills. While it is useful to know how to read and modify existing solutions, it is essential to develop algorithmic design skills to build new solutions from scratch.

1.2 Algorithms parts

In Grasshopper, a solution flows from left to right. At the far left are input values and parameters, and the far right has the output. In between are one or more key processes, and sometimes additional input and output. Let’s take a simple example to help identify the three parts of any algorithm (input, key process, output). The simple addition algorithm includes two numbers (input), the sum (output) and one key process that takes the numbers and gives the result. We will use purple... [truncated]

GUIDES / GRASSHOPPER / GH-ALGORITHMS-AND-DATA-STRUCTURES / DATA-STRUCTURES
------------------------------------------------------------

Index
Source: guides\grasshopper\gh-algorithms-and-data-structures\data-structures\index.md
All algorithms involve processing input data to generate a new set of data as output. Data is stored in well-defined structures to help access and manipulate efficiently. Understanding these structures is the key for successful algorithmic designs. This chapter includes an in-depth review of the basic data structures in Grasshopper.

2.1 Overview
{{}} Overview of data structures in Grasshopper

Grasshopper has three distinct data structures: single item, list of items and tree of items. GH components execute differently based on input data structures, and hence it is essential to be fully aware of the data structure before using. There are tools in GH to help identify the data structure. Those are Panel and Param Viewer.

 Figure(34): Data structures in Grasshopper

Processes in GH execute differently based on the data structure. For example, the Mass Addition component adds all the numbers in a list and produces a single number, but when operating on a tree, it produces a list of numbers representing the sum of each branch.

 Figure(35): Components execute differently based on the data structures. Result of adding numbers from Figure(34)

The wires connecting the data with components in GH offer additional visual reference to the data structure. The wire from a single item is a simple line, while the wire connecting a list is drawn as a double line. A wire output from a tree data structure is a dashed double line. This is very useful to quickly identify the structure of your data.

 Display the data structure
 Example

 Item: single branch with single item
 Wire display: single line

 List: single branch with multiple items
 Wire display: double line

 Tree: multiple branches with any number of items per branch
 Wire display: double dashed line

2.2 Generating lists
{{}} Generate lists in Grasshopper

There are many ways to generate lists of data in GH. So far we have seen how to directly embed a list of values inside a parameter or a panel (with multiline data). T... [truncated]

GUIDES / GRASSHOPPER / GRASSHOPPER-DATA-TYPES
------------------------------------------------------------

Index
Source: guides\grasshopper\grasshopper-data-types\index.md
Overview

Grasshopper is an application that deals with a lot of different types of data. These data types can come from 6 different sources and some of them will not be known when Grasshopper is written and compiled. The six potential sources are:
Primitive types such as Booleans, Integers, Colors, Strings, etc. Grasshopper uses these types itself a lot.
Other .NET Framework types such as System.Drawing.PointF or System.Collections.Generic.HashSet. Grasshopper does not use these types to during component-to-component communication, but someone else might.
RhinoCommon types such as Point3d, Circle, Plane, Brep, Curve etc. Many of these are used natively, but certainly not all of them.
Types defined in Grasshopper itself.
Types defined in components for Grasshopper.
Types defined in VB/C#/Python scripts that run inside Grasshopper.

What to do with unknowns?

Although clearly some of these are known to the developer during the time of writing, not all of them can be. Yet Grasshopper still needs to be able to interpret and use types it may know nothing about. Some of the things Grasshopper needs to be able to do with data of any type are:
Convert it to text so tooltips and panels can be populated with useful descriptions of data.
Convert it to and from other types.
Duplicate data so we can change it without affecting the original.
Test data for validity.
Save types to \.gh files and load them back in. ()
Preview geometric types in the viewport.
Bake geometric types to the Rhino document.
Transform geometric types.
Calculate bounding boxes of geometric types.
Be able to store null states of each type.

To overcome the problem of (A) needing to do so many things while (B) knowing nothing about the types in advance an interface is defined in the Grasshopper SDK and all data which is stored inside parameters must implement this interface. This allows Grasshopper to do the things from the second list to all the types from th... [truncated]

GUIDES / GRASSHOPPER / GRASSHOPPER-ICONS
------------------------------------------------------------

Index
Source: guides\grasshopper\grasshopper-icons\index.md
Vector Source

{{}} GrasshopperIconSet.zip

The files were written with Xara Designer Pro 6, but Xara is pretty good at file compatibility so you can probably open them on many versions.

You are free to use and modify these vector graphics for any project, document or webpage that is associated with Grasshopper. You do not need to credit me, though it is not allowed to pass the work off as your own without modifications.

Graphics Style

There are no fast and hard rules when it comes to the graphics style of Grasshopper icons, but I suggest you try and mimic line-weights, contrast, saturation and arrow and point symbols when designing your own icons.

Note that all icons must be 24x24 pixels and most icons in the original set leave a 2-pixel empty border around all edges. All icons with such an empty border have a drop-shadow with the following properties:

Blur = 2 pixels
Colour = black
Transparency = 65 out of 255 (roughly 25%)
Horizontal offset = 1 pixel to the right
Vertical offset = 1 pixel downwards

I apply drop-shadows as a post-process effect in a pixel-editor, as Xara is not good at pixel effects on very small images.

Related Topics
On Icons (ieatbugsforbreakfast)

GUIDES / GRASSHOPPER / INSTALLING-TOOLS-MAC
------------------------------------------------------------

Index
Source: guides\grasshopper\installing-tools-mac\index.md
By the end of this guide, you should have all the tools installed necessary for authoring, building, and debugging Grasshopper components using RhinoCommon in Rhino for Mac.

Prerequisites

This guide presumes you have an:
Apple Mac running macOS Monterey (12) or later.
Rhino for Mac

Install Visual Studio Code

{{}}
Visual Studio for Mac has been retired by Microsoft.
{{}}

Step-by-Step
Download Visual Studio Code.
Once you have downloaded the VSCode-darwin-universal.zip, double-click it to unzip.
Drag Visual Studio Code to the /Applications folder.
Open Visual Studio Code, you will need to click "Open" the first time you open it.
You will need to install some packages before starting, luckily all the required pacakges are bundled together. These can be found by clicking "Extensions" on the left side bar:
Intellicode for C# Dev Kit
NuGet Gallery Plugin (Recommended)
Restart Visual Studio Code.
Visual Studio Code is installed in your /Applications folder. You will want to drag its icon to your Dock for future use or - if it's running - right/option-click the icon in the Dock and select Keep in Dock.

Next Steps

Congratulations! You have all the tools necessary to build a Grasshopper component on macOS. Now what?

Check out the Your First Component (Mac) guide for instructions building - your guessed it - your first component.

GUIDES / GRASSHOPPER / INSTALLING-TOOLS-WINDOWS
------------------------------------------------------------

Index
Source: guides\grasshopper\installing-tools-windows\index.md
By the end of this guide, you should have all the tools installed necessary for authoring, building, and debugging custom Grasshopper components in Rhino for Windows.

Prerequisites

This guide presumes you have an:
A PC running Microsoft Windows 10 or later.
Rhino 7 for Windows

Install Visual Studio

Visual Studio is Microsoft's flagship development platform and Integrated Development Environment (IDE). Visual Studio now comes in three major "streams": Visual Studio Code[^1], Visual Studio Online[^2], and Visual Studio "proper"[^3]. In order to author custom Grasshopper components, you will need Visual Studio "proper" (Visual Studio Code and Visual Studio Online are not supported).

{{}}
For the purposes of this guide, we will presume you are using Visual Studio 2022 Community Edition.
{{}}

Step-by-Step
Visual Studio Community Edition is free from Microsoft for students, open-source contributors, and small teams. Details here. Click the Community button to download the installer.
Run the Visual Studio installer you downloaded from Microsoft, in this case VisualStudioSetup.exe.
Follow the onscreen prompts to install Visual Studio. You will need the ".NET desktop development" workload for RhinoCommon based plug-in development. When successfully installed, click the Launch button.

Grasshopper Templates

The RhinoCommon and Grasshopper templates for Rhino 7 contains wizards to get you started creating components quickly.

Step-by-Step
Launch Visual Studio.
Navigate to Extensions > Manage Extensions
In the left-hand sidebar, expand the Online section, then select the Visual Studio Marketplace entry...
!Extensions and Updates
In the Search field, search for RhinoCommon. This filters the gallery list below.
Find RhinoCommon and Grasshopper templates for Rhino 7 and select it.
Click the Download button. The extension installation should begin.
You must Accept the license agreement by clicking on the Install button.
Press the Close button and Quit Visual Studio.
The exte... [truncated]

GUIDES / GRASSHOPPER / LIST-COMPONENTS
------------------------------------------------------------

Index
Source: guides\grasshopper\list-components\index.md
Overview

So far the example components have all operated on individual data items. This is known as One-In-One-Out. But what if you want to operate on more than one item at a time; One-In-Many-Out, Many-In-One-Out or Many-In-Many-Out? This requires that input or output parameters have a non-standard Grasshopper.Kernel.GHParamAccess flag.

List Parameters

Input and Output parameters that are part of Grasshopper components have an access flag that affects how the component treats data stored in these parameters. Take for example the Polyline component. It creates a single polyline object from a collection of corner-points. This is a Many-In-One-Out kind of logic. The Divide component creates a whole bunch of division points from a single curve. This is an example of One-In-Many-Out. The Cull components remove certain items from lists, this is an example of Many-In-Many-Out.

Most components treat their inputs and outputs as parameters that provide individual instances of data, rather than related collections of data. This is indicated by all parameters having an GHParamAccess.item access flag. You can however assign different access flags to parameters. Preferably this flag should be assigned only once, namely in the RegisterInputParams or RegisterOutputParams method overrides. It is legal to modify an access flag as long as a solution is not currently in progress, but it is not recommended.

In this guide, we'll be writing a component that removes (culls) the bottom-most N objects in a collection of geometric shapes. As inputs we'll need a collection of geometry and an integer indicating how many objects the user wants to remove, and as output we'll provide the same collection of geometry, but with the bottom-most objects missing. This is therefore a Many-In-Many-Out case.

The Component code (without the RegisterInputParams, RegisterOutputParams and SolveInstance methods) may look like this:

 C#
 VB.NET


public class ComponentCullByElevation : GHComponent
{
... [truncated]

Essential Code:
public class Component_CullByElevation : GH_Component
{
  public Component_CullByElevation()
    : base("Cull Elevation", "CullZ", "Cull objects by relative elevation", "Sets", "Sequence")
  { }

  public override Kernel.GH_Exposure Exposure
  {
    get { return GH_Exposure.primary | GH_Exposure.obscure; }
  }
  public override System.Guid ComponentGuid
  {
    get { return new Guid("{A8FF9CBA-0837-4cd6-9198-0D17325D3F8F}"); }
  }

  //...additional component code will go here..
}


Public Class Component_CullByElevation
  Inherits GH_Component

  Public Sub New()
    MyBase.New("Cull Elevation", "CullZ", "Cull objects by relative elevation", "Sets", "Sequence")
  End Sub

  Protected Overrides ReadOnly Property Icon() As System.Drawing.Bitmap
    Get
      Return My.Resources.TheIconNameForThisComponent
    End Get
  End Property
  Public Overrides ReadOnly Property Exposure() As Kernel.GH_Exposure
    Get
      Return GH_Exposure.primary Or GH_Exposure.obscure
    End Get
  End Property
  Public Overrides ReadOnly Property ComponentGuid() As System.Guid
    Get
      Return New Guid("{A8FF9CBA-0837-4cd6-9198-0D17325D3F8F}")
...

GUIDES / GRASSHOPPER / MULTI-TREADED-COMPONENTS
------------------------------------------------------------

Index
Source: guides\grasshopper\multi-treaded-components\index.md
Overview

Grasshopper for Rhino 6 provides multi-threaded solving in specific components. Benchmarks have shown that Grasshopper can be up to 20% faster when using multi-threaded components. Results may vary as there are only specific components that can compute in parallel.

The following components have been modified to perform calculations using multiple threads.

 Curve Plane Intersection
 Project Curve
 Pull Curve
 Split with Brep
 Shatter
 Split with Breps
 Trim with Brep
 Trim with Breps
 Area
 Area Moments
 Volume
 Volume Moments
 Brep Closest Point
 Mesh Plane Intersection
 Brep Line Intersection
 Brep Brep Intersection
 Brep Plane Intersection
 Curve Curve Intersection
 Curve Curves Intersection
 Point in Brep
 Point in Breps
 Curve Self-Intersection 
 Contour
 Dash Pattern
 Divide Curve
 Boundary Surface

Multi-threaded components are decorated with small dots in the upper left corner to help you understand the component’s capabilities and current ‘mode’ of operation.

{{}}

 No dots : the component does not currently support multi-threaded calculations
 One dot: the component does support multi-threaded calculations, but is currently calculating with a single thread (i.e. legacy mode)
Two dots: the component does support multi-threaded calculations and is solving using multiple threads.

For components that support multi-threaded calculations, the feature can be enabled/disabled using the right click context menu on the component itself.

We continue to look for components that would be useful to have multi-threaded. Join the Multi-threaded Grasshopper component discussion to participate.

Creating you own multi-threaded components in Grasshopper

Custom multi-threaded components are also possible by programmer your own components in C# or Python. for details on this read the Making Task Capable Components in Grasshopper guide

GUIDES / GRASSHOPPER / PROGRAMMING-TASK-CAPABLE-COMPONENT
------------------------------------------------------------

Index
Source: guides\grasshopper\programming-task-capable-component\index.md
Overview

Grasshopper for Rhino allows you to develop multi-threaded components by way of the new IGHTaskCapableComponent interface. Benchmarks have shown that Grasshopper can run significantly faster when using multi-threaded components. Results may vary, as not all solutions can be computed in parallel.

The Interface

When a component implements the IGHTaskCapableComponent interface, Grasshopper will notice and potentially call a full enumeration of SolveInstance for the component twice in consecutive passes:
The first pass is for collecting data and starting tasks to compute results
The second pass is for using the results from the tasks to set outputs.

Example

In this guide, we will convert a standard component into a task capable component. In our example, the initial component code looks like this:


public class FibonacciComponent : GHComponent
{
 ...
 protected override void SolveInstance(IGHDataAccess data)
 {
 const int maxsteps = 46;

 int steps = 0;
 data.GetData(0, ref steps);
 if (steps = 0.");
 return;
 }
 if (steps > maxsteps) // Prevent overflow...
 {
 AddRuntimeMessage(GHRuntimeMessageLevel.Error, $"Steps must be . In this example, modify the component from this:

public class FibonacciComponent : GHComponent

to this:

public class FibonacciComponent : GHTaskCapableComponent

Finally, modify SolveInstance to use tasks:


protected override void SolveInstance(IGHDataAccess data)
{
 const int maxsteps = 46;

 if (InPreSolve)
 {
 // First pass; collect input data
 int steps = 0;
 data.GetData(0, ref steps);
 if (steps = 0.");
 return;
 }
 if (steps > maxsteps) // Prevent overflow...
 {
 AddRuntimeMessage(GHRuntimeMessageLevel.Error, $"Steps must be task = Task.Run(() => ComputeFibonacci(steps), CancelToken);
 TaskList.Add(task);
 return;
 }

 if (!GetSolveResults(data, out SolveResults result))
 {
 // Compute right here; collect input data
 int steps = 0;
 data.GetData(0, ref steps);
 if (steps = 0.");
 return;
 }
 if (steps > maxsteps) //... [truncated]

Essential Code:
public class FibonacciComponent : GH_Component
{
  ...
  protected override void SolveInstance(IGH_DataAccess data)
  {
    const int max_steps = 46;

    int steps = 0;
    data.GetData(0, ref steps);
    if (steps < 0)
    {
      AddRuntimeMessage(GH_RuntimeMessageLevel.Error, "Steps must be >= 0.");
      return;
    }
    if (steps > max_steps) // Prevent overflow...
    {
      AddRuntimeMessage(GH_RuntimeMessageLevel.Error, $"Steps must be <= {max_steps}.");
      return;
    }

...
public class SolveResults
{
  public int Value { get; set; }
}


GUIDES / GRASSHOPPER / SIMPLE-COMPONENT
------------------------------------------------------------

Index
Source: guides\grasshopper\simple-component\index.md
Prerequisites

This guide presumes you have all the necessary tools installed and have managed to debug a simple boilerplate component. If you are not there yet, please read Installing Tools (Windows) and Your First Component (Windows)

This guide will skip over any complicated issues (such as mathematics, geometry and data handling) in order to reduce the totality of new concepts. You will however need to have a good understanding of basic OOP concepts such as classes, types and inheritance. If you do not understand these essentials, we recommend you start with some other reading material first.

Kernel.GHComponent

The Grasshopper component wizards (in both Visual Studio for Windows and Visual Studio for Mac) include an empty Grasshopper component template. For the moment, let's ignore this and construct a simple component "from scratch." This guide presumes that you already have a component library setup or are continuing from in the HelloGrasshopper solution from the Your First Component (Windows) guide.

Add an empty class to your solution, call it MyFirstComponent. At this point a new file should be created (MyFirstComponent). At this point a new file should be created with (something close to) the following content:

 C#
 VB.NET


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HelloGrasshopper
{
 class MyFirstComponent
 {
 }
}




Class MyFirstComponent

End Class


Since we'll be using primarily types from the Grasshopper.Kernel namespace. We'll import this namespace so that we have easy access to all types contained within it (unless otherwise specified, all further types discussed in this topic belong to Grasshopper.Kernel). In C#, we can also remove some unnecessary using statements while we're at it:

 C#
 VB.NET


using System;
using Grasshopper.Kernel;

namespace HelloGrasshopper
{
 class MyFirstComponent
 {
 }
}




Imports Grasshopper.Kernel
Class MyFirstComponent

End Class


T... [truncated]

Essential Code:
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HelloGrasshopper
{
    class MyFirstComponent
    {
    }
}


Class MyFirstComponent

End Class


GUIDES / GRASSHOPPER / SIMPLE-DATA-TYPES
------------------------------------------------------------

Index
Source: guides\grasshopper\simple-data-types\index.md
Overview

It's a rather complicated topic as data is an integral part of the Grasshopper process and GUI. Grasshopper needs to be able to (de)serialize data, display data in tooltips, convert data to other types of data, prompt the user for persistent data, draw geometry preview data in viewports and bake geometric data. In this topic I'll only talk about non-geometric data, we'll get to previews and baking in a later topic.

Practically all native data types in Grasshopper are based either on a .NET Framework type or a RhinoCommon type. For example System.Boolean, System.String, Rhino.Geometry.Point3d and Rhino.Geometry.Brep to name but a few. However, the parameters in Grasshopper don't directly store Booleans, String, Points and Breps as these types can't handle themselves in the cauldron that is Grasshopper.

Prerequisites

We will not be dealing with any of the basics of component development in this guide. Please start with the Your First Component guide and the Simple Component guide before starting this one.

Before you start, create a new class that derives from Grasshopper.Kernel.GHComponent, as outlined in the Simple Component guide.

The IGHGoo interface

In this section I'll briefly discuss all the methods and properties that are defined in IGHGoo. What they're for, who uses them at what time, etc, etc.

All data used in Grasshopper must implement the IGHGoo interface. IGHGoo defines the bare minimum of methods and properties for any kind of data before it is allowed to play ball.

IsValid

 C#
 VB.NET


bool IsValid { get{} }




ReadOnly Property IsValid() As Boolean


Not all data types are valid all the time, and this property allows you to test the current instance of your data. When data is invalid it will often be ignored by components.

TypeName

 C#
 VB.NET


string TypeName { get{} }




ReadOnly Property TypeName() As String


This property must return a human-readable name for your data type.

TypeDescription

 C#
 VB.... [truncated]

Essential Code:
Function Duplicate() As IGH_Goo

Function ToString() As String


GUIDES / GRASSHOPPER / SIMPLE-GEOMETRY-COMPONENT
------------------------------------------------------------

Index
Source: guides\grasshopper\simple-geometry-component\index.md
We'll discuss how to deal with different access levels of input data and invalid Structs vs. invalid and null Classes.

Overview

This component will perform a simple Circle-Line Split operation. We'll retrieve a single Circle and a single Line input, make sure the data is valid, project the line onto the circle plane, determine whether or not the Split operation is valid and then output the two arcs on either side of the slicing line.

Prerequisites

We will not be dealing with any of the basics of component development. Please make sure you have read the Your First Component, Simple Component, and Simple Mathematics Component guides before starting this one.

Before you start, create a new class that derives from Grasshopper.Kernel.GHComponent, as outlined in the Simple Component guide.

Input Parameters

This part of the component is very similar to the Simple Mathematics Component, except this time there will be no default values.

 C#
 VB.NET


...
protected override void RegisterInputParams(GHComponent.GHInputParamManager pManager)
{
 pManager.AddCircleParameter("Circle", "C", "The circle to slice", GHParamAccess.item);
 pManager.AddLineParameter("Line", "L", "Slicing line", GHParamAccess.item);
}
...




...
Protected Overrides Sub RegisterInputParams(ByVal pManager As GHComponent.GHInputParamManager)
 pManager.AddCircleParameter("Circle", "C", "The circle to slice", GHParamAccess.item)
 pManager.AddLineParameter("Line", "L", "Slicing line", GHParamAccess.item)
End Sub
...


The first parameter is of type ParamCircle and the data it contains will consist solely of GHCircle. GHCircle is a class that wraps the Rhino.Geometry.Circle structure. It provides methods that allow Grasshopper to incorporate RhinoCommon circles into the default GUI. These methods include Archiving, Previewing, Baking and Casting (Converting) functions. However, when accessing data inside a ParamCircle parameter, you are not limited to the GHCircle type, as we shall see.

The... [truncated]

Essential Code:
...
protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
{
  pManager.AddCircleParameter("Circle", "C", "The circle to slice", GH_ParamAccess.item);
  pManager.AddLineParameter("Line", "L", "Slicing line", GH_ParamAccess.item);
}
...


...
protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)
{
  pManager.AddArcParameter("Arc A", "A", "First Split result.", GH_ParamAccess.item);
  pManager.AddArcParameter("Arc B", "B", "Second Split result.", GH_ParamAccess.item);
}
...


GUIDES / GRASSHOPPER / SIMPLE-MATHEMATICS-COMPONENT
------------------------------------------------------------

Index
Source: guides\grasshopper\simple-mathematics-component\index.md
Overview

We'll discuss parameter order, legacy support for changing component layouts and default values for input parameters.

For this component we'll bundle the Sine(), Cosine() and Tangent() trigonometry functions while allowing inputs to be specified in either Radians or Degrees. We'll need to define two input parameter (one of which will have a default value) and three output parameters.

Prerequisites

We will not be dealing with any of the basics of component development. Please start with the Your First Component guide and the Simple Component guide before starting this one.

Before you start, create a new class that derives from Grasshopper.Kernel.GHComponent, as outlined in the Simple Component guide.

Input parameters

This component will require two input parameters, one of which has a default value. We'll need to register these parameters inside the RegisterInputParams() method:

 C#
 VB.NET


...
protected override void RegisterInputParams(GHComponent.GHInputParamManager pManager)
{
 pManager.AddNumberParameter("Angle", "A", "The angle to measure", GHParamAccess.item);
 pManager.AddBooleanParameter("Radians", "R", "Work in Radians", GHParamAccess.item, true); // The default value is 'true'
}
...




...
Protected Overrides Sub RegisterInputParams(ByVal pManager As GHComponent.GHInputParamManager)
 pManager.AddNumberParameter("Angle", "A", "The angle to measure", GHParamAccess.item)
 pManager.AddBooleanParameter("Radians", "R", "Work in Radians", GHParamAccess.item, True) 'The default value is 'True'
End Sub
...


The first parameter is of type Double meaning it accepts floating point values. It only has a name, abbreviation, description and access level defined. The second parameter is of type bool and it will accept true and false values. The pManager object allows us to specify a single default value for many parameter types.

The order in which we register the parameters is also the order in which they'll appear on the component. We sh... [truncated]

Essential Code:
...
protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
{
  pManager.AddNumberParameter("Angle", "A", "The angle to measure", GH_ParamAccess.item);
  pManager.AddBooleanParameter("Radians", "R", "Work in Radians", GH_ParamAccess.item, true); // The default value is 'true'
}
...


public override Grasshopper.Kernel.GH_Exposure Exposure
{
  get { return GH_Exposure.hidden; }
}


GUIDES / GRASSHOPPER / SIMPLE-PARAMETERS
------------------------------------------------------------

Index
Source: guides\grasshopper\simple-parameters\index.md
Overview

Parameters are a vital part of Grasshopper (the other being components). However, unlike components, it is far less likely that you'll need to make your own parameters. Most components require only the native data types available inside Grasshopper. In those odd cases where you need to work with custom data, you'll also need to create custom parameters that store that data. In this topic, we'll create a parameter which can handle the TriStateType we discussed in the Simple Data Types guide.

Parameters are responsible for storing and distributing data. Components use them to collect existing data and output new data. Parameters can also be used to convert data from one type into another, even though on the atomic level the conversion is actually performed by the CastTo(T) and CastFrom methods on IGHGoo. Most objects in the Special subcategory on the Grasshopper toolbar are basically parameters with extended GUIs. Parameters can also be used by themselves to store constant data or to redirect data into multiple streams.

Prerequisites

We will not be dealing with any of the basics of component development in this guide. Please start with the Your First Component guide and the Simple Component guide before starting this one.

Before you start, create a new class that derives from Grasshopper.Kernel.GHComponent, as outlined in the Simple Component guide.

Grasshopper.Kernel.IGHParam

All parameters in Grasshopper must implement the IGHParam interface. IGHParam defines the bare minimum of what a parameter must be able to do. There are some interfaces that extend on IGHParam, and also some abstract classes that partially implement the interface. Note that IGHParam already inherits from IGHActiveObject, so it comes with a lot of baggage.

IGHParam is quite an extensive interface, it defines nearly thirty properties and methods, some of which are quite tricky to implement. It is highly recommended that you do not directly implement IGHParam, but derive from the a... [truncated]

Essential Code:
public class TriStateParameter : GH_PersistentParam<TriStateType>
{

  // We need to supply a constructor without arguments that calls the base class constructor.
  public TriStateParameter() :
    base("TriState", "Tri", "Represents a collection of TriState values", "Params", "Primitive") { }

  public override System.Guid ComponentGuid
  {
    // Always generate a new Guid, but never change it once
    // you've released this parameter to the public.
    get { return new Guid("{2FEEF1A2-A764-431d-8C78-9BF92C78BAE1}"); }
  }

  protected override Kernel.GH_GetterResult Prompt_Singular(ref TriStateType value)
  {
    // Todo, impement this function.
  }
  protected override Kernel.GH_GetterResult Prompt_Plural(ref List<TriStateType> values)
    // Todo, impement this function.
...
Public Class TriStateParameter
  Inherits GH_PersistentParam(Of TriStateType)

  'We need to supply a constructor without arguments that calls the base class constructor.
  Public Sub New()
    'This is where we specify the name, description, tab and panel of this parameter.
    MyBase.New("TriState", "Tri", "Represents a collection of TriState values", "Params", "Primitive")
  End Sub

  Public Overrides ReadOnly Property ComponentGuid() As System.Guid
    Get
      'Always generate a new Guid, but never change it once you've released this parameter to the public.
      Return New Guid("{2FEEF1A2-A764-431d-8C78-9BF92C78BAE1}")
    End Get
  End Property

  Protected Overrides Function Prompt_Singular(ByRef value As TriStateType) As Kernel.GH_GetterResult
    'Todo, impement this function.
  End Function
  Protected Overrides Function Prompt_Plural(ByRef values As System.Collections.Generic.List(Of TriStateType)) As Kernel.GH_GetterResult
...

GUIDES / GRASSHOPPER / THE-WHY-AND-HOW-OF-DATA-TREES
------------------------------------------------------------

Index
Source: guides\grasshopper\the-why-and-how-of-data-trees\index.md
Data storage in general programming

One of the key aspects of programming is deciding how and where to store your data. If you're writing textual code using any one of a huge number of programming languages there are a lot of different options, each with its own benefits and drawbacks. Sometimes you just need to store a single data point. At other times you may need a list of exactly one hundred data points. At other times still circumstances may demand a list of a variable number of data points.

In programming jargon, lists.aspx) and arrays.aspx) are typically used to store an ordered collection of data points, where each item is directly accessible. Bags.aspx) and hash sets.aspx) are examples of unordered data storage. These storage mechanisms do not have a concept of which data comes first and which next, but they are much better at searching the data set for specific values. Stacks.aspx) and queues.aspx) are ordered data structures where only the youngest or oldest data points are accessible respectively. These are popular structures for code designed to create and execute schedules. Linked lists.aspx) are chains of consecutive data points, where each point knows only about its direct neighbours. As a result, it's a lot of work to find the one-millionth point in a linked list, but it's incredibly efficient to insert or remove points from the middle of the chain. Dictionaries.aspx) store data in the form of key-value pairs, allowing one to index complicated data points using simple lookup codes.

The above is a just a small sampling of popular data storage mechanisms, there are many, many others. From multidimensional arrays to SQL databases. From readonly collections.aspx) to concurrent k-dTrees. It takes a fair amount of knowledge and practice to be able to navigate this bewildering sea of options and pick the best suited storage mechanism for any particular problem. We did not wish to confront our users with this plethora of programmatic principles, and inst... [truncated]

GUIDES / GRASSHOPPER / WHAT-IS-A-GRASSHOPPER-COMPONENT
------------------------------------------------------------

Index
Source: guides\grasshopper\what-is-a-grasshopper-component\index.md
This guide also explains the hierarchy of all assemblies involved with the Grasshopper plugin. This is important for component developers so they know which Assembly References they need to have in order to compile a Grasshopper Component Library. It also provides some background information which is useful when communicating with other developers.

Rhino Plugin Architecture

Grasshopper is a .NET (RhinoCommon) plugin for Rhino 6 for Windows and later (a version for Rhino 5 for Mac is currently in beta). It was written using Microsoft Visual Studio Professional using both VB.NET and C# source compiled against the .NET Framework. It is recommended, though not required, that you target the same framework when developing Grasshopper Component Libraries.

Our aim is to keep Grasshopper dependencies as conservative as possible. However, it is possible that we will switch to a higher version number of Rhino or .NET if this new version fixes crucial bugs or exposes useful functions.

.NET Component Library

The Grasshopper project type is Class Library, meaning it cannot be run as a stand-alone application. Grasshopper.dll is loaded by a Rhino plugin called GrasshopperPlugin.rhp.

Assembly References

As a Class Library, Grasshopper references namespaces in addition to RhinoCommon.dll, some of these are standard namespaces provided by the .NET Framework, others are 3rd-party assemblies and others still are written by McNeel developers but are shipped separately for technical reasons. Some of these assemblies need to be referenced by Component developers, while others can be safely ignored. The following table lists all assemblies referenced by Grasshopper.dll:

 Assembly
 Author
 Purpose
 Required

 RhinoCommon.dll
 McNeel
 Rhinoceros .NET SDK
 Yes

 GHIO.dll
 McNeel
 Grasshopper Input/Output library required to read and write Grasshopper files.
 Yes

 GHUtil.dll
 McNeel
 Grasshopper utility library containing some peripheral algorithms.
 Optional

 QWhale.*.dll
 Quantum W... [truncated]

GUIDES / GRASSHOPPER / YOUR-FIRST-COMPONENT-MAC
------------------------------------------------------------

Index
Source: guides\grasshopper\your-first-component-mac\index.md
Prerequisites

It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Mac).

HelloGrasshopper

We will use Visual Studio Code and the dotnet Rhino Grasshopper template to create a new, basic, Grasshopper component called HelloGrasshopper.

If you are familiar with Visual Studio Code, these step-by-step instructions may be overly detailed for you. The executive summary: create a new Solution using the Grasshopper Component dotnet template, build and run, and then make a change.

We are presuming you have never used Visual Studio Code before, so we'll go through this one step at a time.

Download the required template
Launch Visual Studio Code.
Open Visual Studio Code's Terminal via Terminal (menu entry) > New Terminal, or using the command palette (⌘ ⇧ P) and search for "Terminal".
Inside Terminal, run:
 
 dotnet new install Rhino.Templates
 

Starting the Project
Create a folder on your mac where you would like your project to live. Name the folder HelloGrasshopper.
If you have not done so already, launch Visual Studio Code.
Now we can open our new folder, navigate to File > Open Folder and choose the folder we just created.
Open Terminal via Terminal > New Terminal, or using the command palette (⌘ ⇧ P) and search for "Terminal".
Enter the following command into the Terminal:
 
 dotnet new grasshopper --version 8 -sample
 
In our Folder explorer, we should see the project appear as Visual Studio Code discovers the files.
Expand the Solution Explorer, this is the best way to interact with C# projects on Mac in Visual Studio Code.

Boilerplate Build

{{}}
Older Rhino Templates do not have System.Drawing.Common referenced.
To add them to your project run the command dotnet add package System.Drawing.Common -v 7.0.0 in the terminal.
{{}}
Before we do anything, let's Run and Debug HelloGrasshopper to make sure everything is working as expected. We'll just build the boilerplate Plugin... [truncated]

GUIDES / GRASSHOPPER / YOUR-FIRST-COMPONENT-WINDOWS
------------------------------------------------------------

Index
Source: guides\grasshopper\your-first-component-windows\index.md
It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows).

HelloGrasshopper

We will use the Grasshopper Assembly templates to create a new, basic, component library called HelloGrasshopper.

If you are familiar with Visual Studio, these step-by-step instructions may be overly detailed for you. The executive summary: create a new project using the Grasshopper Assembly template, build and run, and then make a change.

We are presuming you have never used Visual Studio before, so we'll go through this one step at a time.

File New
If you have not done so already, launch Visual Studio (for the purposes of this guide, we are using Visual Studio Community Edition and C#).
Navigate to File > New > Project...
 !File New Project
A Create a new project wizard should appear. In the Search for templates area, search for Grasshopper to filter the results. Find and select the Grasshopper Assembly for Rhino (C\#) entry and click Next.
For the purposes of this Guide, we will name our demo plugin HelloGrasshopper. In the Configure your new project dialog, fill in the Project name field. Browse and select a location for this project on your disk, then click Next
The New Grasshopper Add-On dialog appears. Check the Provide sample code checkbox.
 !New Grasshopper Assembly
This is where you fill out information about your first component:
Add-on display name: the name of component library itself.
Name: the name of the component as displayed in the ribbon bar and search menus.
Nickname: the default name of the component when inserted into the canvas.
Category: name of tab where component icon will be shown.
Subcategory: name of group inside tab where icon will be shown.
Description: description shown in tooltip when mouse is over the component icon in the menu.
For the purposes of this guide, let's chek the "Provide Sample Code", and then click Finish...
A new solution called HelloGrasshopper should open.... [truncated]

Essential Code:
protected override void RegisterInputParams(GH_Component.GH_InputParamManager pManager)
...
protected override void RegisterOutputParams(GH_Component.GH_OutputParamManager pManager)

protected override void SolveInstance(IGH_DataAccess DA)


GUIDES / GRASSHOPPER2 / YOUR-FIRST-COMPONENT-MAC
------------------------------------------------------------

Index
Source: guides\grasshopper2\your-first-component-mac\index.md
Prerequisites

It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Mac).

HelloGrasshopper 2

We will use Visual Studio Code and the dotnet Rhino Grasshopper template to create a new, basic, Grasshopper 2 component called HelloGrasshopper 2.

If you are familiar with Visual Studio Code, these step-by-step instructions may be overly detailed for you. The executive summary: create a new Solution using the Grasshopper 2 Component dotnet template, build and run, and then make a change.

We are presuming you have never used Visual Studio Code before, so we'll go through this one step at a time.

Download the required template
Launch Visual Studio Code.
Open Visual Studio Code's Terminal via Terminal (menu entry) > New Terminal, or using the command palette (⌘ ⇧ P) and search for "Terminal".
Inside Terminal, run:
 
 dotnet new install Rhino.Templates
 

Starting the Project
Create a folder on your mac where you would like your project to live. Name the folder HelloGrasshopper2.
If you have not done so already, launch Visual Studio Code.
Now we can open our new folder, navigate to File > Open Folder and choose the folder we just created.
Open Terminal via Terminal > New Terminal, or using the command palette (⌘ ⇧ P) and search for "Terminal".
Enter the following command into the Terminal:
 
 dotnet new gh2 --version 8 -sample
 
In our Folder explorer, we should see the project appear as Visual Studio Code discovers the files.
Expand the Solution Explorer, this is the best way to interact with C# projects on Mac in Visual Studio Code.

Boilerplate Build
Before we do anything, let's Run and Debug HelloGrasshopper 2 to make sure everything is working as expected. We'll just build the boilerplate Plugin template. Click the Run and Debug button on the left hand side of Visual Studio Code and then the green play button in the newly opened panel.

 !New Project
Rhinoceros and Grasshopper 2... [truncated]

GUIDES / GRASSHOPPER2 / YOUR-FIRST-COMPONENT-WINDOWS
------------------------------------------------------------

Index
Source: guides\grasshopper2\your-first-component-windows\index.md
It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows).

HelloGrasshopper 2

We will use the Grasshopper 2 Assembly templates to create a new, basic, component library called HelloGrasshopper2.

If you are familiar with Visual Studio, these step-by-step instructions may be overly detailed for you. The executive summary: create a new project using the Grasshopper 2 Assembly template, build and run, and then make a change.

We are presuming you have never used Visual Studio before, so we'll go through this one step at a time.

File New
If you have not done so already, launch Visual Studio (for the purposes of this guide, we are using Visual Studio Community Edition and C#). Click Create New Project.

!Create New Project
A Create a new project wizard should appear. In the Search for templates area, search for Grasshopper2 to filter the results. Find and select the Grasshopper 2 Plug-In for Rhino (C\#) entry and click Next.

!Choose a Template
For the purposes of this Guide, we will name our demo plugin HelloGrasshopper 2. In the Configure your new project dialog, fill in the Project name field. Browse and select a location for this project on your disk, then click Create

!Configure Your New Project
For the purposes of this guide, let's check the Provide Sample Code

!New Plugin Wizard
This is where you fill out information about your first component:
Plug-In display name: the name of the plugin itself.
Component class name: the name of the component class.
Name: the name of the component as displayed in the ribbon bar and search menus.
Chapter: name of tab where component icon will be shown.
Section: name of group inside tab where icon will be shown.
Description: description shown in tooltip when mouse is over the component icon in the menu.
Click Finish
A new solution called HelloGrasshopper 2 should open...
 !HelloGrasshopper 2 Solution

Boilerplate Build
Before we do anything, let'... [truncated]

Essential Code:
protected override void AddInputs(InputAdder inputs)
...
protected override void AddOutputs(OutputAdder outputs)

protected override void Process(IDataAccess access)


GUIDES / OPENNURBS / ACCESSING-RENDERING-ASSETS
------------------------------------------------------------

Index
Source: guides\opennurbs\accessing-rendering-assets\index.md
OpenNURBS and Rhino3dm now provide direct access to rendering information without the need for Rhino. (Prior to this, the only way to access this information outside of Rhino was by getting the data as XML and parsing it.)

This guide outlines classes used to access these rendering assets and provides examples.

Overview

In C++, the following objects are accessible through the use of ONXModel. In C# the equivalent functionality is provided by File3dm which under the hood is a wrapper around ONXModel.

 C/C++
 C# Equivalent
 Purpose

 ONRenderContent
 File3dmRenderContent
 Provides access to generic render content settings.

 ONRenderMaterial
 File3dmRenderMaterial
 Provides access to settings specific to render materials.

 ONRenderEnvironment
 File3dmRenderEnvironment
 Provides access to settings specific to render environments.

 ONRenderTexture
 File3dmRenderTexture
 Provides access to settings specific to render textures.

 ONDecals
 Rhino.Render.Decals
 Provides access to a collection of decals stored on object attributes.

 ONDecal
 Rhino.Render.Decal
 Provides access to settings for an individual decal in the collection.

 ONDithering
 Rhino.Render.Dithering
 Provides access to dithering settings.

 ONEmbeddedFile
 File3dmEmbeddedFile
 Provides access to embedded texture files.

 ONGroundPlane
 Rhino.Render.GroundPlane
 Provides access to ground plane settings.

 ONLinearWorkflow
 Rhino.Render.LinearWorkflow
 Provides access to gamma and linear workflow settings.

 ONRenderChannels
 Rhino.Render.RenderChannels
 Provides access to render channels settings.

 ONSafeFrame
 Rhino.Render.SafeFrame
 Provides access to safe frame settings.

 ONSkylight
 Rhino.Render.Skylight
 Provides access to skylighting settings.

 ONSun
 Rhino.Render.Sun
 Provides access to sun settings and sun position calculations.

 ONPostEffects
 Rhino.Render.PostEffects.PostEffectCollection
 Provides access to the list of post effects.

 ONPostEffect
 Rhino.Render.PostEffects.PostEffectDat... [truncated]

Essential Code:
ONX_Model model;
model.Read(filename_in);

ONX_ModelComponentIterator it(model, ON_ModelComponent::Type::RenderContent);
auto* component = it.FirstComponent();
while (nullptr != component)
{
  const auto* mat = ON_RenderMaterial::Cast(component);
  if (nullptr != mat)
  {
    const auto typeName = mat->TypeName();
    wprintf(L"Type: %s\n", static_cast<const wchar_t*>(typeName));

    const auto v = mat->GetParameter(ON_MATERIAL_IOR);
    if (!v.IsNull())
    {
      wprintf(L"Setting IOR and transparency\n");
      auto* mat_write = const_cast<ON_RenderMaterial*>(mat);
      mat_write->SetParameter(ON_MATERIAL_IOR, 2.5);
      mat_write->SetParameter(ON_MATERIAL_TRANSPARENCY_AMOUNT, 0.5);
...

GUIDES / OPENNURBS / BREP-LOOP-EDGE-DIRECTIONS
------------------------------------------------------------

Index
Source: guides\opennurbs\brep-loop-edge-directions\index.md
Question

Is there a function to query if a loop ONBrepLoop is reversed on the face ONBrepFace? In other words, whether the boundary of the face agrees with or opposes that of the corresponding loop?

Also, is there a way to query if the edge ONBrepEdge direction is reversed? Or, whether an edge curve agrees with the start and end vertices?

Answer

Loops are always oriented so that the active region of the face is to the left of the 2D curve. Thus, outer loops are oriented counter-clockwise and inner loops are oriented clockwise.

Also, to determine whether or not an edge is reversed, use ONBrepEdge::ProxyCurveIsReversed(). See opennurbs_curveproxy.h for details.

GUIDES / OPENNURBS / CREATING-LINEAR-DIMENSIONS
------------------------------------------------------------

Index
Source: guides\opennurbs\creating-linear-dimensions\index.md
Question

The annotation classes are different in openNURBS 6. A sample on how to create a linear dimension would be really helpful.

Answer

The annotation classes have been overhauled in Rhino 6. For an overview of what's new and what's changed, see the following:

Annotation Objects

Every annotation object needs a plane, dimension style, location, and text content. In addition, each specific type of annotation needs its specific information.

Example

The following example code can be used to create linear dimensions using the openNURBS toolkit:


/
Description:
 Add an aligned linear dimension to the model. The dimension line is
 parallel to the segment connecting the dimension points.
Parameters:
 model - [in] 
 The model object.
 point0 - [in]
 point1 - [in]
 Locations of one of the points being dimensioned.
 The dimension line will be parallel to the segment
 connecting these points.
 linepoint - [in]
 A point on the linear dimension line.
 planenormal - [in]
 A vector perpendcular to the line between the extension points
 that defines the orientation of the dimension's plane.
 dimstyle - [in]
 nullptr, model dimension style, or a valid override style.
 If invalid, then the current dimension style will be used.
 attributes - [in]
 nullptr or object attributes.
/
static bool AddDimLinear(
 ONXModel& model,
 ON3dPoint point0,
 ON3dPoint point1,
 ON3dPoint linepoint,
 ON3dVector planenormal,
 const ONDimStyle dimstyle,
 const ON3dmObjectAttributes attributes
)
{
 if (nullptr == dimstyle)
 {
 const ONModelComponentReference& dimstyleref = model.CurrentDimensionStyle();
 dimstyle = ONDimStyle::Cast(dimstyleref.ModelComponent());
 }

 if (nullptr == dimstyle)
 return false;

 const ONUUID parentid
 = dimstyle->ParentIdIsNotNil()
 ? dimstyle->ParentId()
 : dimstyle->Id();

 const ONModelComponentReference& parentdimstyleref = model.DimensionStyleFromId(parentid);
 const ONDimStyle parentdimstyle = ONDimStyle::Cast(parentdimstyleref.ModelComponent());
 if (null... [truncated]

Essential Code:
/*
Description:
  Add an aligned linear dimension to the model. The dimension line is
  parallel to the segment connecting the dimension points.
Parameters:
  model - [in] 
    The model object.
  point0 - [in]
  point1 - [in]
    Locations of one of the points being dimensioned.
    The dimension line will be parallel to the segment
    connecting these points.
  line_point - [in]
    A point on the linear dimension line.
  plane_normal - [in]
    A vector perpendcular to the line between the extension points
    that defines the orientation of the dimension's plane.
  dim_style - [in]
    nullptr, model dimension style, or a valid override style.
    If invalid, then the current dimension style will be used.
...

GUIDES / OPENNURBS / DATA-FROM-ELLIPSES
------------------------------------------------------------

Index
Source: guides\opennurbs\data-from-ellipses\index.md
Problem

You have drawn an ellipse in Rhino, using the Ellipse command. While reading the .3dm file, using openNURBS, the ellipse is classified as as ON::curveobject. How does one get the ellipse's construction data, such as center point, major and minor axes, etc?

Solution

Unlike some curve types (e.g. Lines, Arcs, Polylines, etc.) which have their own ONCurve-derived classes, there is no special class that is used to represent elliptical curves. Ellipses and elliptical arcs are simply NURBS, or ONNurbsCurve, curves.

To test to see if a curve is an ellipse or an elliptical arc, first try to cast the ONCurve object as an ONNurbsCurve object. If successful, then use ONNurbsCurve::IsEllipse() to verify the NURBS curve is an ellipse and to obtain its construction data.

Sample


ONXModel model = ...

ONXModelComponentIterator it(model, ONModelComponent::Type::ModelGeometry);
const ONModelComponent modelcomponent = nullptr;
for (modelcomponent = it.FirstComponent(); nullptr != modelcomponent; modelcomponent = it.NextComponent())
{
 const ONModelGeometryComponent modelgeometry = ONModelGeometryComponent::Cast(modelcomponent);
 if (nullptr != modelgeometry)
 {
 // Test for NURBS curve object
 const ONNurbsCurve nurb = ONNurbsCurve::Cast(modelgeometry->Geometry(nullptr));
 if (nullptr != nurb)
 {
 ONEllipse ellipse;
 double tolerance = model.msettings.mModelUnitsAndTolerances.mabsolutetolerance;
 bool rc = nurb->IsEllipse(nullptr, &ellipse, tolerance);
 if (rc)
 {
 // Center
 ON3dPoint origin = ellipse.plane.origin;

 // Major and minor axes
 ON3dVector xaxis = ellipse.radius[0] ellipse.plane.xaxis;
 ON3dVector yaxis = ellipse.radius[1] * ellipse.plane.yaxis;

 // Quad points
 ON3dPoint p0(origin - xaxis);
 ON3dPoint p1(origin + xaxis);
 ON3dPoint p2(origin - yaxis);
 ON3dPoint p3(origin + yaxis);

 // Foci
 ON_3dPoint f1, f2;
 ellipse.GetFoci(f1, f2);

 // TODO: do something with ellipse
 }
 }
 }
}


GUIDES / OPENNURBS / FINDING-ANNOTATION-FONT
------------------------------------------------------------

Index
Source: guides\opennurbs\finding-annotation-font\index.md
Question

There are many changes to ONXModel in openNURBS. In prior versions, I was getting the font and its id information for ONLeader2 with:


ONXModel model = ...
const ONLeader2 leader = ...
const ONFont& font = model.mfonttable[leader->Index()];


How can I do this with the current openNURBS?

Answer

In openNURBS, the the dimension style, or ONDimStyle, specifies all appearance properties like the text font, size, and alignment, arrow head shape, and so on. To obtain the font used by an Annotation object, such as an ONLeader, you just need to query the object's effective dimension style.

Example

The following example code can be used to get the ONFont used by an ONLeader using the openNURBS toolkit:


ONXModel model = ...

// Create a model geometry interator
ONXModelComponentIterator it(model, ONModelComponent::Type::ModelGeometry);
const ONModelComponent modelcomponent = nullptr;
for (modelcomponent = it.FirstComponent(); nullptr != modelcomponent; modelcomponent = it.NextComponent())
{
 // Get the model geometry
 const ONModelGeometryComponent modelgeometry = ONModelGeometryComponent::Cast(modelcomponent);
 if (nullptr == modelgeometry)
 continue;

 // Try getting an annotation leader
 const ONLeader leader = ONLeader::Cast(modelgeometry->Geometry(nullptr));
 if (nullptr == leader)
 continue;

 // Get the parent dimension style
 const ONModelComponentReference& parentdimstyleref = model.DimensionStyleFromId(leader->DimensionStyleId());
 const ONDimStyle parentdimstyle = ONDimStyle::Cast(parentdimstyleref.ModelComponent());
 if (nullptr == parentdimstyle)
 continue;

 // Get the effective dimension style
 const ONDimStyle& dimstyle = leader->DimensionStyle(parentdimstyle);

 // Get the font
 const ONFont& font = dimstyle.Font();

 // TODO...
}


GUIDES / OPENNURBS / GETTING-OBJECT-ATTRIBUTES
------------------------------------------------------------

Index
Source: guides\opennurbs\getting-object-attributes\index.md
Question

With prior version of openNURBS, it was easy to find the properties associated to geometry objects, such layer, material and groups, once the reference of the objects were available using ONXModelobject.

What is the correct way of finding the layer, material and groups, when we have a ONModelGeometryComponent object?

Answer

In order to lookup referenced components, such as Layers, Materials, Groups, etc., you first must obtain the model geometry attributes, or ON3dmObjectAttributes object. 

If you are referencing the Exampleread sample included with the openNURBS toolkit, then after the 3DM file has been read, you can query an object’s render material as follows:


ONXModel model = ...

for (modelcomponent = it.FirstComponent(); nullptr != modelcomponent; modelcomponent = it.NextComponent())
{
 const ONModelGeometryComponent modelgeometry = ONModelGeometryComponent::Cast(modelcomponent);
 if (nullptr != modelgeometry)
 {
 const ON3dmObjectAttributes attributes = modelgeometry->Attributes(nullptr);
 if (nullptr != attributes)
 {
 // TODO
 }
 } 
}


Now that you have the attributes, you can use the helper functions on ONXModel to access these components.

Here are a couple of helper functions you might find useful:


/
Description:
 Returns a pointer to an ONLayer object, given an object's attributes.
/
static const ONLayer ONLayerFromAttributes(
 const ONXModel& model, 
 const ON3dmObjectAttributes& attributes
)
{
 const ONLayer layer = nullptr;
 const ONModelComponentReference& modelcomponentref = model.LayerFromAttributes(attributes);
 if (!modelcomponentref.IsEmpty())
 layer = ONLayer::Cast(modelcomponentref.ModelComponent());
 return layer;
}

/
Description:
 Returns a pointer to an ONMaterial object, given an object's attributes.
/
static const ONMaterial ONMaterialFromAttributes(
 const ONXModel& model, 
 const ON3dmObjectAttributes& attributes
)
{
 const ONMaterial material = nullptr;
 const ONModelComponentReference& modelcom... [truncated]

Essential Code:
/*
Description:
  Returns a pointer to an ON_Layer object, given an object's attributes.
*/
static const ON_Layer* ON_LayerFromAttributes(
  const ONX_Model& model, 
  const ON_3dmObjectAttributes& attributes
)
{
  const ON_Layer* layer = nullptr;
  const ON_ModelComponentReference& model_component_ref = model.LayerFromAttributes(attributes);
  if (!model_component_ref.IsEmpty())
    layer = ON_Layer::Cast(model_component_ref.ModelComponent());
  return layer;
}

/*
Description:
  Returns a pointer to an ON_Material object, given an object's attributes.
*/
...

GUIDES / OPENNURBS / GETTING-STARTED
------------------------------------------------------------

Index
Source: guides\opennurbs\getting-started\index.md
Prerequisites

openNURBS is intended for skilled C++ developers. Please read What is openNURBS? if you have not already. It is also presumed that you have an application that wishes to access 3DM files outside of Rhinoceros.

openNURBS public SDK

To download the public C++ SDK and example 3DM files, visit https://www.rhino3d.com/opennurbs.

Supported C++ Compilers

The openNURBS C++ toolkit has been successfully used with the following compilers:
A version of Microsoft Visual Studio that includes the Visual Studio 2019 (v142) platform toolset. Thus, you can use either Visual Studio 2022 or Visual Studio 2019. To build openNURBS and the examples with Microsoft Visual Studio, use the solution opennurbspublic.sln.

 To use C++ opennurbs in your Visual Studio project:
Open opennurbspublic.sln in Visual Studio, select the platform and configuration, and rebuild all.
In your project's stdafx.h, put the following lines. This will include all the header files you need to call C++ opennurbs and automatically link in the correct libraries:

 
 // defining OPENNURBSPUBLICINSTALLDIR enables automatic linking using pragmas
 #define OPENNURBSPUBLICINSTALLDIR ""
 // uncomment the next line if you want to use opennurbs as a DLL
 //#define OPENNURBSIMPORTS
 #include "/opennurbspublic.h"
 
Apple Xcode 9.2 (9C40b): To build openNURBS and the examples with Xcode 9.2 (or later), use the workspace opennurbspublic.xcworkspace.
Other C++ compilers The compiler must support the C++14 standard. A makefile is provided as a starting point. The openNURBS C++ source code is clean and simple. If you are using a C++ compiler that supports the C++14 standard and run into some toolkit code that causes problems, please let us know. We'll attempt to change the code to accommodate the compiler.

Read and Write

Use ONXModel::Read() and ONXModel::Write() to add support for reading and writing 3DM files to your application. See exampleread.cpp and examplewrite.cpp for more details. 
Compile the op... [truncated]

Essential Code:
  // defining OPENNURBS_PUBLIC_INSTALL_DIR enables automatic linking using pragmas
  #define OPENNURBS_PUBLIC_INSTALL_DIR "<MY_INSTALLPATH>"
  // uncomment the next line if you want to use opennurbs as a DLL
  //#define OPENNURBS_IMPORTS
  #include "<MY_INSTALLPATH>/opennurbs_public.h"
  

GUIDES / OPENNURBS / IMPORTING-LIGHTWEIGHT-EXTRUSIONS
------------------------------------------------------------

Index
Source: guides\opennurbs\importing-lightweight-extrusions\index.md
Question

I was try to add some code for handling the ON::extrusionobject type object. But, I don't now know which API I could use to get data from extrusion object. I know there was a new class ONExtrusion in opennurbsbeam.cpp. But I did not know how to use it. Can you give me some suggestion or some sample code? I would like know how should I import extrusion object?

Answer

In most cases, you will want to convert the extrusion object to a Brep and then just pass the Brep to the Brep handling code that you've already written, for example:


ONXModel model = ...

ONXModelComponentIterator it(model, ONModelComponent::Type::ModelGeometry);
const ONModelComponent modelcomponent = nullptr;
for (modelcomponent = it.FirstComponent(); nullptr != modelcomponent; modelcomponent = it.NextComponent())
{
 const ONModelGeometryComponent modelgeometry = ONModelGeometryComponent::Cast(modelcomponent);
 if (nullptr != modelgeometry)
 {
 // Test for extrusion object
 const ONExtrusion extrusion = ONExtrusion::Cast(modelgeometry->Geometry(nullptr));
 if (nullptr != extrusion)
 {
 ONBrep brep = ON_Brep::New();
 if (brep != extrusion->BrepForm(brep, true))
 {
 delete brep; // don't leak...
 continue;
 }

 // TODO: do something with Brep here...

 delete brep; // don't leak...
 }
 }
}


GUIDES / OPENNURBS / INSTANCE-REFERENCES-WITH-NON-UNIFORM-SCALES
------------------------------------------------------------

Index
Source: guides\opennurbs\instance-references-with-non-uniform-scales\index.md
Problem

In Rhino, you can insert an instance of a block and give it a non-uniform scale (transformation). But, when you read the model, using the openNURBS toolkit, and try to explode the block into its geometric form, the geometry is no longer non-uniformly scaled.

Solution

Not all ONGeometry-derived classes can be accurately modified with transformations like projections, shears, and non-uniform scaling. For example, if you were to apply a non-uniform scale to a circle, which is represented by an ONArcCurve curve, the resulting geometry is no longer a circle.

When exploding an instance reference into its geometric form, first test to see if the instance reference's transformation is a similarity transformation. This can be done by using ONXForm::IsSimilarity(). See opennurbsxform.h 

If the transformation is not a similarity, then convert the geometry into a form that can be accurately modified. This can be done by using the ON_Geometry::MakeDeformable() override on the geometric object...


if (bNeedXform)
{
 // If not a similarity transformation, make sure geometry
 // can be deformed. Generally, this involves convert non-NURBS
 // geometry into NURBS geometry.
 if (0 == xform.IsSimilarity() )
 geometry->MakeDeformable();

 // Do the transformation
 geometry->Transform(xform);
}


GUIDES / OPENNURBS / LINKING-WITH-OPENNURBS
------------------------------------------------------------

Index
Source: guides\opennurbs\linking-with-opennurbs\index.md
Problem

You are trying to write a simple console application like the examplewrite sample included with the openNURBS toolkit. However, you are having problems linking. You are using the opennurbsstaticliblinkingpragmas.h header included with openNURBS, but it does not seem to work.

Solution

The opennurbsstaticliblinkingpragmas.h header, included with openNURBS, is only designed to help build the example projects included with the toolkit. That is, it only works if your project is inside the openNURBS folder.

Unlike the #include statement, #pragma statements, used in this header, are not very path smart. The library paths used by #pragma statement must be relative to the project, not the #include file in which it is used.

You certainly d... [compressed]JSON

All payload to and from endpoints happens in JSON format. To make this explicit, every response to an endpoint will have the header Content-Type: application/json present in the HTTPS response.

Authentication

All endpoints in Cloud Zoo or on the issuer use Basic Authentication. To receive a successful response from an endpoint, you must include an Authorization header like so:


Authorization: Basic BASE64ENCODEDSTRING


where BASE64ENCODEDSTRING is a base64 encoded string containing your issuer id and your issuer secret: 


 BASE64ENCODEDSTRING = b64.encode(issuerid + ":" + issuersecret)


Non-successful responses

All unsuccessful responses from endpoints will have an HTTP status code greater or equal to 400. If the status code is also less than 500, the payload will include the following JSON:

 {
 "Error": "SomeErrorCode"
 "Description": "A description about the error message",
 "Details": "More details about the error"
 }
The Error field contains a specific error code that can be used by the issuer to recognize a specific error, such as incorrect credentials. 
The Description field contains a description of the error.
The Details field contains details of the error, possibly suggesting how to fix it.

If the status code is greater or equal to 500, the response may not be JSON and may be empty.

Endpoints

POST /product

Adds a product to Cloud Zoo registered under the authenticating issuer.

Example Request

 POST /product

 {
 "id": "06bb1e79-5456-47a1-ad6d-104518cd894b",
 "version": "12",
 "platforms": [
 "Windows"
 ],
 "picture": "https://elisapi.mcneel.com/media/2",
 "downloadUrl": "https://www.rhino3d.com/download/newproduct",
 "titles": {
 "en": "New Product Name",
 "es": "Nuevo Producto",
 "ja... [truncated]

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-IMPLEMENT-HTTP-CALLBACKS
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-implement-http-callbacks\index.md
As an issuer, you must implement four HTTPS endpoints to answer basic questions Cloud Zoo requires to function. We provide a ready-to-deploy solution in our Github repository you can use as a template to implement these callbacks, or if you're experienced with HTTP rest APIs, you can roll your own from scratch. Regardless of the path you choose, the issuer must answer the following questions:
Can a license be added to an entity? The issuer is asked this question when a user tries to add a license to their account or a team. You may request further information from the user, accept the request, or deny the request.
Can a license be removed from an entity? The issuer is asked this question when a user tries to remove a license from their account or a team.
What are the details of a specific license key? This is used... [compressed]JSON

All payload to and from callbacks happens in JSON format. To make this explicit, every request to a callback will have the header Content-Type: application/json present in the HTTPS request.

Localization

In some circumstances, such as when additional input is required from a user when adding a license to an account, a localized response SHOULD be returned by the issuer in the user's locale. To make this possible, every request to a callback will have an Accept... [truncated]

Essential Code:
		
Non-successful responses

If returning a response with an HTTP status code greater or equal to 400, the issuer SHOULD include the following JSON in the payload as well:


 - The  field is user facing, and SHOULD be localized.  In addition, the description string may have markdown style links as in the example above. The links can be used to help the user navigate and solve the issue.
 - The  field is not user-facing, but may be logged for troubleshooting purposes. You MUST NOT include sensitive data in the details string.

Callbacks

GET /get_license

Return information about a specific license so users can see details about the license.

Example Request


GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-ISSUER
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-issuer\index.md
In Cloud Zoo, an issuer represents a vendor of products with license keys. If you want your plugin to use Cloud Zoo, you must register to be an issuer by emailing support@mcneel.com with the subject "Cloud Zoo issuer registration for NAME" (replace NAME with your name\) or clicking on the link below.

{{}}Send us a registration email{{}}

\ Please provide the name (organization or individual) that you would like the issuer to be registered under, e.g. "Acme Inc" or "Jolyn Bloggs".

You will be provided with an issuer id and a secret that will uniquely identify you as a product vendor and will allow you to implement the required HTTPS callbacks.

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-LICENSE
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-license\index.md
Structure


{
 "id": "6-32403404-3434340-343432",
 "key": "RH60-ABCD-EFGZ-HIJK-LMNO",
 "aud": "4ed9ebbe-c43e-4d4a-9642-e555d727df9f",
 "iss": "mcneel",
 "exp": null,
 "numberOfSeats": 1,
 "editions": {
 "en": "Commercial",
 "es": "Comercial"
 },
 "metadata": OPTIONAL JSON OBJECT SMALLER THAN 10K
}


Description
id - A string that uniquely describes each license. This string must be unique for all licenses of the same product type. It is also known as the license's serial number.
key - A string that uniquely describes each license. This string must be unique for all licenses of the same product type. Normally, this string is used to add a license to Cloud Zoo by users.
aud - A GUID denoting the product id of the plugin. This is how Cloud Zoo knows that this license can be used for your product.
iss - The id of the issuer as registered with Cloud Zoo.
exp - The expiration date of the license, expressed in a JSON numeric value representing the number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time, ignoring leap seconds. For example, for midnight on March 31, 2019, the value would be 1553990400. Cloud Zoo will not honor the license as valid for issuing leases after the expiration date has passed. If null, the license is considered perpetual (i.e. never expires).
numberOfSeats - Denotes how many seats can be concurrently issued, barring any advanced heuristics, for the license. This number must be at least 1. For example, a lab license with a value of 30 would allow 30 team members to use your software concurrently. 
editions - A dictionary of localized product editions. Each key represents an ISO 639-1 language code. You may specify a two letter country code after the language with a dash or an underscore (i.e. such as zh-tw, case insensitive). If that exact language id is not available for a particular task in the system, the system will attempt to use a more generic language id (i.e. for example, if es-CO is not available, then the s... [truncated]

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-LICENSECLUSTER
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-licensecluster\index.md
Structure

 {
 "licenses": [ONE OR MORE LICENSE OBJECTS]
 }

Description
licenses - An array of one or more License objects.

When should I cluster licenses?

Under normal circumstances, a License Cluster contains a single License object in its licenses array. However, particularly when dealing with upgrades, clustering multiple related licenses may be useful. 

For example, consider a hypothetical Plug-In called 3D Donuts. There are licenses for 3D Donuts version 1, and licenses for 3D Donuts version 2. 

The Donuts software license agreement can describe one of the following three scenarios:
After upgrading to version 2, users can run version 1 and version 2, but not concurrently.

 In this scenario, it makes sense to cluster the version 1 license and the version 2 license. To do this, simply return a license cluster with both License objects. Cloud Zoo will automatically replace the existing version 1 license cluster with the new one passed. Users now have a single seat (Unless numberOfSeats is greater than 1) to share between version 1 and version 2. If the licenses in the cluster have an expiration date, the exp field of the first license in the array will be assumed to be the expiration date for all licenses. Similarly, the numberOfSeats field of the first license will apply to all licenses in the cluster, regardless of the value of their numberOfSeats field.
After upgrading to version 2, users can run version 1 and
 version 2 concurrently. 

 In this scenario, it is advisable not to cluster licenses, but to treat them independent of each other--even if the version 1 license is required initially to add the version 2 license. Users will be able to run version 1 and version 2 concurrently.
After upgrading to version 2, users can no longer run
 version 1.

 This scenario is similar to scenario #2, but after adding a license, the issuer must manually call the DELETE endpoint to remove version 1 from an entity.

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-LICENSEFORMAT
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-licenseformat\index.md
 If your license keys have a format that cannot be accurately defined in the fields below, we might be able to help. Please contact aj@mcneel.com for details.

Structure

 "format": {
 "length": {
 "min": 24,
 "max": 48
 },
 "prefix": "RMA7-",
 "example": "RMA7-XXXX-XXXX-XXXX-XXXX-XXXX",
 "regexFilter": "[A-Za-z0-9]"
 },

Description
length - A range of min and max integers representing the minimum and maximum characters--inclusive--a license key is expected to contain. To avoid conflicts with other formats, this number should be as specific as possible. Note that the length is for the overall license key and includes the characters in the prefix.
prefix - A string representing the common prefix a license key is expected to begin with. The prefix should be as specific as possible to avoid conflicts with other formats.
example - An example license key that may be shown to the user when entering a license. It should begin with the prefix specified.
regexFilter- (optional) - A regular expression defining the allowed characters in the license key. By default, only characters A-Z (both lowercase and uppercase) and numbers 0-9 are allowed. Whitespace, dashes, and slashes will not be considered for a pattern match.

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-MODIFY-PLUGIN-LICENSING-CODE
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-modify-plugin-licensing-code\index.md
Important Information

Supporting Cloud Zoo within your plugin's code is easy, but it is important to understand that Cloud Zoo licensing behaves differently from other licensing methods in Rhino. With Cloud Zoo, your plugin (and Rhino itself) will not receive a license key entered by the user or a local Zoo server, but rather a cryptographic... [compressed]JSON

All payload to and from endpoints happens in JSON format. To make this explicit, every response to an endpoint will have the header Content-Type: application/json present in the HTTPS response.

Authentication

All endpoints in Cloud Zoo or on the issuer use Basic Authentication. To receive a successful response from an endpoint, you must include an Authorization header like so:


Authorization: Basic BASE64ENCODEDSTRING


where BASE64ENCODEDSTRING is a base64 encoded string containing your issuer id and your issuer secret: 


 BASE64ENCODEDSTRING = b64.encode(issuerid + ":" + issuersecret)


Non-successful responses

All unsuccessful responses from endpoints will have an HTTP status code greater or equal to 400. If the status code is also less than 500, the payload will include the following JSON:

 {
 "Error": "SomeErrorCode"
 "Description": "A description about the error message",
 "Details": "More details about the error"
 }
The Error field contains a specific error code that can be used by the issuer to recognize a specific error, such as incorrect credentials. 
The Description field contains a description of the error.
The Details field contains details of the error, possibly suggesting how to fix it.

If the status code is greater or equal to 500, the response may not be in JSON format and may be empty.

Endpoints

DELETE /license

Removes a license from Cloud Zoo. This method deletes the entire License Cluster object the license is in. If the License Cluster the license belongs to contains additional licenses, they will be removed as well.

{{}}
This endpoint expects the arguments to be passed as a query string.
{{}}

Example Request

 DELETE /license?licenseId=LICENSEID&productId=PRODUCTID&entityId=ENTITYID
entityId: The id of... [truncated]

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-OVERVIEW
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-overview\index.md
Overview

Add Cloud Zoo support to your Plug-In by following the steps below. Cloud Zoo allows Rhino users to add their license keys to their personal Rhino account or to a team composed of multiple Rhino accounts. The users may then login from any computer that has Rhino installed and run Rhino. Cloud Zoo enforces license restrictions by making sure that users can only run concurrently in as many computers as there are licenses for a specific product. This allows individual users to run Rhino and other Plug-Ins on any machine. In a team scenario, members can be anywhere in the world and have access to a license. 

Cloud Zoo does not require users to have a constant internet connection—only an occasional one every couple of weeks. This is possible because Cloud Zoo employs license lease mechanism wherein a lease--not a license itself--is issued by Cloud Zoo to a client running Rhino. A lease usually expires within a few weeks, but a new lease is frequently issued between Rhino and Cloud Zoo while a client is online. This allows for a buffer of a few weeks in case the computer is offline for extended periods of time. This design allows Rhino and other Plug-Ins to run reliably even in environments with poor internet connections. Cloud Zoo can also void a lease at any point in time. For example, when a license is removed by a user or by the developer (Such as when a customer returns a license for a refund), Cloud Zoo immediately voids all related leases, effectively ending the user's ability to use the software the license is intended for.

Under certain scenarios, such as when adding or removing a license, Cloud Zoo will contact your server to make sure you allow such operations to succeed. Your server is not required to interact with the license lease process.

!Cloud Zoo Overview

Required Steps

To have your Plug-In support Cloud Zoo, you must:
Register as an Issuer in Cloud Zoo.
Add products to Cloud Zoo.
Implement the required HTTPS callbacks.
Modify Plug-In lice... [truncated]

GUIDES / RHINOCOMMON / CLOUDZOO / CLOUDZOO-PRODUCT
------------------------------------------------------------

Index
Source: guides\rhinocommon\cloudzoo\cloudzoo-product\index.md
Structure

 {
 "id": "06eb1079-5a56-47a1-aw6d-0b4518fd894b",
 "creationDate": 1559928168,
 "iss": "mcneel",
 "format": {
 "length": {
 "min": 24,
 "max": 24
 },
 "prefix": "RMA7-",
 "example": "RMA7-XXXX-XXXX-XXXX-XXXX-XXXX",
 "regexFilter": "[A-Za-z0-9]"
 },
 "version": "6",
 "platforms": [
 "Windows"
 ],
 "picture": "https://elisapi.mcneel.com/media/2",
 "downloadUrl": "https://www.rhino3d.com/download/rhino-for-mac/6/wip",
 "titles": {
 "en": "Rhino WIP"
 },
 }

Description
id (readonly) - A lowercase GUID that uniquely describes each product. This GUID must be unique in the entire system.
creationDate (readonly) - A unix timestamp in seconds representing the date the product was added to Cloud Zoo. 
iss (readonly) - The id of the issuer as registered with Cloud Zoo.
format - A License Format object. Cloud Zoo will send all requests to add a license to the system to the issuer of the product whose license format matches the given license key.
version - The version of the product that this license represents. This string is user facing and will be used in Rhino as well as in the Licenses Portal.
platforms - An array of supported platforms for this license. Currently, only Windows and Mac are supported.
picture - A url where an icon for this product may be found. The icon must not be larger than 1MP.
downloadUrl - A url where the actual software the product represents may be downloaded. This link will be publicly available to users.
titles - A dictionary of localized product names. Each key represents an ISO 639-1 language code. You may specify a two letter country code after the language with a dash or an underscore (i.e. such as zh-tw, case insensitive). If that exact language id is not available for a particular task in the system, the system will attempt to use a more generic language id (i.e. for example, if es-CO is not available, then the system will try to use es). If the region agnostic language id is also not available, en (English) will be used. At least... [truncated]

GUIDES / RHINOCOMMON / CODE-DRIVEN-FILE-IO
------------------------------------------------------------

Index
Source: guides\rhinocommon\code-driven-file-io\index.md
Prior to Rhino 8, code-driven exporting was done by using the active document and scripting the export command. This was both inefficient and painful to write.

Rhino 8 introduces the abililty to read and write files of any format that Rhino supports entirely through code. This includes support for options that need to be applied to properly read or write different files.

How does it work?

Import and export plug-ins are provided an optional dictionary at read and write time. When the dictionary is present, instead of asking for user input, the importers and exporters pay attention to keys and values in the dictionary to make decisions on options for I/O. RhinoCommon provides classes for these options that can be converted into a dictionary that the import and export plug-ins can interpret. Look in the Rhino.FileIO namespace for format specific option classes.

Example: Write an AutoCAD dwg from Rhino

This example shows how to write the active RhinoDoc to an AutoCAD dwg with options:

 C#
 Python


var doc = Rhino.RhinoDoc.ActiveDoc;
if (doc != null)
{
 // create/set options for exporting to DWG file
 var options = new Rhino.FileIO.FileDwgWriteOptions();
 options.UseLWPolylines = true;
 options.Version = Rhino.FileIO.FileDwgWriteOptions.AutocadVersion.Acad2000;
 // convert options into a dictionary
 var optionsDictionary = options.ToDictionary();

 var path = System.Environment.GetFolderPath(System.Environment.SpecialFolder.Desktop);
 path = System.IO.Path.Combine(path, "sample.dwg");

 // export to a file with our options dictionary
 bool success = doc.Export(path, optionsDictionary);
 if (success)
 System.Console.WriteLine("Successfully exported sample.dwg");
 else
 System.Console.WriteLine("Error while trying to export sample.dwg");
}



import scriptcontext
import Rhino
import os

if scriptcontext.doc is not None:
 options = Rhino.FileIO.FileDwgWriteOptions()
 options.UseLWPolylines = True
 options.Version = Rhino.FileIO.FileDwgWriteOptions.AutocadVers... [truncated]

GUIDES / RHINOCOMMON / COMMAS-AND-PERIODS
------------------------------------------------------------

Index
Source: guides\rhinocommon\commas-and-periods\index.md
English Culture

Depending on the user's culture settings, their computer may be set up to use commas instead of periods for decimal separators. This can cause problems when writing numbers into xml files and reading these xml files on a different culture setting.

An easy way around this problem is to temporarily adjust the application's culture settings when reading/writing files to always use a single culture...

 C#
 VB.NET


// save current culture
System.Globalization.CultureInfo currentculture = System.Threading.Thread.CurrentThread.CurrentCulture;

// create and set english-us culture
System.Globalization.CultureInfo usculture = new System.Globalization.CultureInfo("en-us");
System.Threading.Thread.CurrentThread.CurrentCulture = usculture;

int rc = WriteMyFile( filename );

// restore the saved culture
System.Threading.Thread.CurrentThread.CurrentCulture = currentculture;




' save current culture
Dim currentculture As System.Globalization.CultureInfo = System.Threading.Thread.CurrentThread.CurrentCulture

' create and set english-us culture
Dim usculture As new System.Globalization.CultureInfo("en-us")
System.Threading.Thread.CurrentThread.CurrentCulture = usculture

Dim rc As Integer = WriteMyFile( filename )

' restore the saved culture
System.Threading.Thread.CurrentThread.CurrentCulture = currentculture


GUIDES / RHINOCOMMON / CREATE-DEPLOY-PLUGIN-TOOLBAR
------------------------------------------------------------

Index
Source: guides\rhinocommon\create-deploy-plugin-toolbar\index.md
Question

How can I create one or more toolbars for my plugin, and how can I deploy these toolbars with my plugin?

Answer

If you want to create Rhino-style toolbars, then use Rhino's Toolbar command. You can save your custom toolbars in your own Rhino User Interface (RUI) file. For details on creating toolbars, see the Rhino help file.

If you give your custom RUI file the exact same name as the plugin RHP file and install it in the folder containing the RHP file, then Rhino will automatically open it the first time your plugin loads.

GUIDES / RHINOCOMMON / CREATING-A-SKIN
------------------------------------------------------------

Index
Source: guides\rhinocommon\creating-a-skin\index.md
Overview

Rhino allows developers to customize most of Rhino's interface so that the application appears to be their own. We call this a custom Skin. With a custom Skin, you can change the application icon, splash screen, the application name etc.

Creating a custom Skin for Rhino involves creating a custom skin assembly:

skin name.rhs This is a regular .NET Assembly (.DLL) that implements the skin's icon, splash screen, application name, etc. In this guide, we will refer this to the Skin DLL. See a full list of methods and properties on the Skin class documentation.

Create the Skin DLL

To create the Skin DLL:
Launch Visual Studio and add a new Class Library project to your solution.
In the new Class Library project, add a reference to RhinoCommon.dll, which is found in Rhino's System folder. 
Create a new class that inherits from Rhino.Runtime.Skin.
Add a post build event to the project to rename the assembly from .dll to .rhs:

Copy "$(TargetPath)" "$(TargetDir)$(ProjectName).rhs"
Erase "$(TargetPath)"


Skin Class

The skin class can override basic properties, like the ApplicationName:

 C#
 VB.NET


namespace MySkin
{
 public class MyHippoSkin : Rhino.Runtime.Skin
 {
 protected override string ApplicationName
 {
 get
 {
 return "Hippopotamus";
 }
 }
 }
 // You can override more methods and properties here
}




Namespace MySkin
 Public Class MyHippoSkin
 Inherits Rhino.Runtime.Skin
 Protected Overrides ReadOnly Property ApplicationName() As String
 Get
 Return "Hippopotamus"
 End Get
 End Property
 End Class
 ' You can override more methods and properties here
End Namespace


Installation

 WARNING
 Modifying the regist... [compressed]WARNING
 This guide is deprecated. You can debug in the RhinoWIP using the RhinoCommon Visual Studio for Mac extension. See the Installing Tools (Mac) guide 

By the end of this guide, you should understand how to modify your plugin's C# project file in order to target and debug using RhinoWIP.

Prerequisites

This guide presumes you have installed all the necessary tools and know how to build and debug a plugin using RhinoCommon with Rhinoceros. 

It also presumes you have downloaded and installed the latest RhinoWIP.

Edit References

Your plugin requires references to RhinoCommon dlls that are contained within the Rhino application bundle. The default RhinoCommon Plugin template that comes with the Rhino Xamarin Studio AddIn references Eto, Rhino.UI, and RhinoCommon:

!Bundle References

...which are all contained within the Rhinoceros.app bundle.

We want to target those found in the RhinoWIP.app bundle. Unfortunately, Visual Studio for Mac does not allow you to browse to references that are contained within an application bundle. We will have to "manually" change these references so that they target the appropriate versions contained in RhinoWIP.

Step-by-Step
In Visual Studio for Mac, right/option-click on the project name and select Tools > Edit File... 
!Visual Studio for Mac Edit File
Use Visual Studio for Mac's Search > Replace function to find \Applications\Rhinoceros.app and replace it with \Applications\RhinoWIP.app...
!Search and Replace
Verify that these changes are only happening with the  that contains  entries. Accept your \Applications\RhinoWIP.app replacements to make the change. If you are not using Nuget packages, you will also need to add some changes to the default hint paths so they search the proper location within the app bundle:

 ..\..\Applications\RhinoWIP.app\Contents\Frameworks\RhCore.framework\Resources\RhinoCommon.dll
 False

 ..\..\Applications\RhinoWIP.app\Contents\Frameworks\RhCore.framework\Resources\Rhino... [truncated]

GUIDES / RHINOCOMMON / DIGITALLY-SIGNING-PLUGINS-FOR-ZOO
------------------------------------------------------------

Index
Source: guides\rhinocommon\digitally-signing-plugins-for-zoo\index.md
Overview

To add plugins to the LAN Zoo, and to call the license functions from within your Rhino plugin, you must digitally sign your plugins using a certificate signed by the Robert McNeel & Associates Code Signing Authority.

Generate Private Key & Certificate Signing Request

Follow these steps to generate the necessary info to forward to Robert McNeel & Associates Code Signing Authority...
Download and install the latest OpenSSL. Note, downloading and installing the "light" version (smaller download) is sufficient.
After installation, use Windows Explorer to navigate to the OpenSSL installation folder and double-click on start.bat found in the Bin folder.
From the Windows command prompt that opens, navigate to your plug-in's project folder.
Save the contents of {{}} mcneelcodesigning.zip to your plug-in's project folder.
From the command prompt, run CreateRequest.bat , where filename is the name (without an extension) that will be used to save your private key (.key), certificate signing request (.csr), and final signed digital certificate (.crt).
You will be prompted to answer some questions. Be sure to answer them correctly...


C:\Dev\Zoo> CreateRequest.bat TestZooPluginKey
Loading 'screen' into random state - done
Generating RSA private key, 4096 bit long modulus
................................................................................
e is 65537 (0x10001)
Loading 'screen' into random state - done
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.

Country Name (2 letter code) []: 
State or Province Name (full name) []: 
Locality Name (eg, city) []: 
Organization Name (eg, company) []: 
Organizational Unit Name (eg, section) []: 
Common Name (eg, your websites domain n... [truncated]

Essential Code:
C:\Dev\Zoo> CreateRequest.bat TestZooPluginKey
Loading 'screen' into random state - done
Generating RSA private key, 4096 bit long modulus
................................................................................
e is 65537 (0x10001)
Loading 'screen' into random state - done
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) []: <COUNTRY NAME>
State or Province Name (full name) []: <STATE OR PROVINCE>
Locality Name (eg, city) []: <CITY>
Organization Name (eg, company) []: <ORGANIZATON>
Organizational Unit Name (eg, section) []: <ORGANIZATIONAL UNIT>
Common Name (eg, your websites domain name) []: <DOMAIN NAME>

...

GUIDES / RHINOCOMMON / DISPLAY-CONDUITS
------------------------------------------------------------

Index
Source: guides\rhinocommon\display-conduits\index.md
Rhino lets you define your own display conduits, which provide access to many levels of the display pipeline. They are a bit tricky. This guide cover the concepts and basics of using display conduits.

Conduit Concept

The DisplayPipeline in Rhino is a big and complicated class and we do not recommend you derive your own pipeline. Instead, we've exposed something called a conduit for easy access. The pipeline itself is structured like this (except in reality there are many more channels):

!Rhino Display Pipeline

At one end is the Rhino model, a collection of 3D geometry and data. At the other end is the image we want to display on the screen, a collection of 2D pixels. To get from model to image, the pipeline has to process a lot of information. These steps have been put into channels. When you implement a new conduit, you have to implement at least one of these channels, like so:

!Rhino Display Conduit

Note that the pipeline itself is not bound to the channels. It just executes its code and raises events during specific phases of drawing. During the drawing of a single frame the events are raised in the following order. You hook into the pipeline by extending DisplayConduit and overriding the event handlers that have the same name as the pipeline events:
ObjectCulling: Create a list of all the objects to draw.
CalculateBoundingBox: Determine the extent of the entire scene. Override this function to increase the bounding box of scene so it includes the geometry that you plan to draw.
CalculateBoundingBoxZoomExtents: If you want to participate in the Zoom Extents command with your display conduit, then you need to override ZoomExtentsBoundingBox. Typically you could just call your CalculateBoundingBox override, but you may also want to spend a little more time here and compute a tighter bounding box for your conduit geometry.
PreDrawObjects: Called before objects are drawn. Depth writing and testing are on. Here you could set up the object's display attributes.
P... [truncated]

Essential Code:
class MyConduit : Rhino.Display.DisplayConduit
{
  protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)
  {
    base.CalculateBoundingBox(e);
    // ..
  }

  protected override void PostDrawObjects(DrawEventArgs e)
  {
    base.PreDrawObjects(e);
    // ..
  }
}

class MyConduit : Rhino.Display.DisplayConduit
{
  protected override void CalculateBoundingBox(CalculateBoundingBoxEventArgs e)
  {
    base.CalculateBoundingBox(e);
    var bbox = new BoundingBox();
    bbox.Union(new Point3d(0, 0, 0));
    e.IncludeBoundingBox(bbox);
  }

  protected override void PreDrawObjects(DrawEventArgs e)
  {
    base.PreDrawObjects(e);
    e.Display.DrawPoint(new Point3d(0, 0, 0));
  }
}


GUIDES / RHINOCOMMON / EVENT-WATCHERS
------------------------------------------------------------

Index
Source: guides\rhinocommon\event-watchers\index.md
UI Thread

Applications can not update any user interface controls from any thread other than the main UI thread. Changing a property on a windows control typically causes the control to immediately update its display. But if the call is made from another thread then the UI thread windows will crash the application.

If you are updating a control from inside your event handler, you should check to see if CheckAccess() on the Dispatcher associated with your control evaluates to True. If this is the case, you must invoke a delegate that handles the UI updating and make sure that this delegate is called from the UI thread. This is actually easier than it sounds.

Here is a C# sample of RhinoDoc.AddRhinoObject event handler that handles the thrown exception when called from a thread other than the UI thread...


private void rhinoObjectAdded(Object sender, Rhino.DocObjects.RhinoObjectEventArgs e)
{
 var msg = String.Format("thread id = {0}, obj id = {1}",
 Thread.CurrentThread.ManagedThreadId,
 e.ObjectId.ToString());

 RhinoApp.WriteLine(msg);

 try {
 // when a sphere is added from a secondary thread this line will
 // throw an exception because UI controls can only be accessed from
 // the main UI thread
 label.Content = msg;
 } catch (InvalidOperationException ioe) {RhinoApp.WriteLine(ioe.Message);}
}


Other Threads

But... I really do need to update my control's state, even when in the wrong thread!

This is where Dispatcher.Invoke or Dispatcher.BeginInvoke comes into play. You can force the code that modifies the control to run from the UI thread. Here is a C# sample of how to do this...


private void rhinoObjectAddedSafe(Object sender, Rhino.DocObjects.RhinoObjectEventArgs e)
{
 var msg = String.Format("thread id = {0}, obj id = {1}",
 Thread.CurrentThread.ManagedThreadId,
 e.ObjectId.ToString());

 RhinoApp.WriteLine(msg);

 // checks if the calling thread is the thread the dispatcher is associated with.
 // In other words, checks if the calling thread... [truncated]

Essential Code:
private void rhinoObjectAdded(Object sender, Rhino.DocObjects.RhinoObjectEventArgs e)
{
  var msg = String.Format("thread id = {0}, obj id = {1}",
        Thread.CurrentThread.ManagedThreadId,
        e.ObjectId.ToString());

  RhinoApp.WriteLine(msg);

  try {
    // when a sphere is added from a secondary thread this line will
    // throw an exception because UI controls can only be accessed from
    // the main UI thread
    _label.Content = msg;
  } catch (InvalidOperationException ioe) {RhinoApp.WriteLine(ioe.Message);}
}

private void rhinoObjectAddedSafe(Object sender, Rhino.DocObjects.RhinoObjectEventArgs e)
{
  var msg = String.Format("thread id = {0}, obj id = {1}",
        Thread.CurrentThread.ManagedThreadId,
        e.ObjectId.ToString());

  RhinoApp.WriteLine(msg);

  // checks if the calling thread is the thread the dispatcher is associated with.
  // In other words, checks if the calling thread is the UI thread
  if (_label.Dispatcher.CheckAccess())
    // if we're on the UI thread then just update the component
    _label.Content = msg;
  else
  {
    // invoke the setLabelTextDelegate on the thread the dispatcher is associated with, i.e., the UI thread
    var setLabelTextDelegate = new Action<string>(txt => _label.Content = txt);
    _label.Dispatcher.Invoke(setLabelTextDelegate, new String[] { msg });
  }
}
...

GUIDES / RHINOCOMMON / INSTALLING-TOOLS-MAC
------------------------------------------------------------

Index
Source: guides\rhinocommon\installing-tools-mac\index.md
By the end of this guide, you should have all the tools installed necessary for authoring, building, and debugging C# .NET plugins using RhinoCommon in Rhino for Mac.

Prerequisites

This guide presumes you have an:
Apple Mac running macOS Monterey (12) or later.
Rhino for Mac

Install Visual Studio Code

{{}}
Visual Studio for Mac has been retired by Microsoft.
{{}}

Step-by-Step
Download Visual Studio Code.
Once you have downloaded the VSCode-darwin-universal.zip, double-click it to unzip.
Drag Visual Studio Code to the /Applications folder.
Open Visual Studio Code, you will need to click "Open" the first time you open it.
You will need to install some packages before starting, luckily all the required pacakges are bundled together. These can be found by clicking "Extensions" on the left side bar:
Intellicode for C# Dev Kit
NuGet Gallery Plugin (Recommended)
Restart Visual Studio Code.
Visual Studio Code is installed in your /Applications folder. You will want to drag its icon to your Dock for future use or - if it's running - right/option-click the icon in the Dock and select Keep in Dock.

Next Steps

Congratulations! You have all the tools necessary to build a RhinoCommon plugin for Rhino for Mac. Now what?

Check out the Your First Plugin (Mac) guide for instructions building - your guessed it - your first plugin.

GUIDES / RHINOCOMMON / INSTALLING-TOOLS-WINDOWS
------------------------------------------------------------

Index
Source: guides\rhinocommon\installing-tools-windows\index.md
By the end of this guide, you should have all the tools installed necessary for authoring, building, and debugging .NET plugins using RhinoCommon on Windows.

Prerequisites

This guide presumes you have:

Rhino 8
A PC running Microsoft Windows 10 or later.
Rhino 8 for Windows.

Rhino 7
A PC running Microsoft Windows 8.1 or later.
Rhino 7 for Windows.

Install Visual Studio

To write .NET plugins for Rhino using using RhinoCommon, you will Microsoft Visual Studio. As of this writing, the current version is Visual Studio 2022.
Download Microsoft Visual Studio.
Run the Visual Studio installer you just downloaded.

 !Visual Studio Install
Follow the onscreen prompts to install Visual Studio.
Check the .NET desktop development workload.
Click the Individual components tab.
Scroll to the .NET section and check the following options:
.NET 7.0 Runtime
.NET Framework 4.8 SDK
.NET Framework 4.8 targeting pack
Check any additional features required for your project.
When finished, click Install.
Depending on your internet connection, this can take several minutes to complete.

If you already have Microsoft Visual Studio installed, then you will want to re-run the Visual Studio Installer and verify you have all the the components installed.

Installing Visual Studio Extension

The Rhino Visual Studio Extension contains templates to get you started creating plugin projects quickly.
Download the Rhino Visual Studio Extension (VSIX).
Run the VSIX installer you downloaded.
If the installation is successful, run Visual Studio.

Next Steps

Congratulations! You have the tools to build a RhinoCommon plugin for Rhino for Windows. Now what?

Check out the Your First Plugin (Windows) guide for instructions on how to build your first plugin.

GUIDES / RHINOCOMMON / LOADING-TOOL-PALETTES-MAC
------------------------------------------------------------

Index
Source: guides\rhinocommon\loading-tool-palettes-mac\index.md
{{}}

This guide covers information relevant to Rhino 5-7 for Mac. Rhino {{}} is the current shipping version.

For updated guides see:
The Rhino UI System
Creating and Deploying Plugin Toolbars

{{}}

Prerequisites

This guide presumes that you have a RhinoCommon plugin that has commands that can be run from a tool palette. In Rhino for Windows, this UI is normally stored in an rui file that includes the buttons, the icons, and their associated commands. If you do not yet have a plugin, please begin with the Your First Plugin (Mac) guide.

Overview

There are three steps in creating and loading a tool palette collection for your plugin in Rhino for Mac: 
The first step is to create (or convert) a tool palette collection that calls the appropriate commands - or to convert a Rhino for Windows .rui file - to ToolPaletteCollection.plist file. 
The second step is to add this .plist in your plugin project as a resource. 
The third and final step is to tell Rhino for Mac to load the tool palette from the appropriate file when your plugin is being loaded.

Create or Convert A Tool Palette Collection

If you are familiar with the Command Editor in Rhino for Mac, you are already well on your way to understanding how to create a custom tool palette collection for use in your plugin. If not, don't worry: creating a tool palette collection is relatively easy. 

If you already have an existing rui file from Rhino for Windows, this job is even easier: you can import that rui and convert it to a plist.

Creating from Scratch
Open Rhino - if it is not already open - and start a new modeling window.
Enter the TestEditToolPaletteCollection command. (You will need to type the entire command; it will not autocomplete). This launches a developer tool similar to the Command Editor where tool palette collections can be created, organized, and saved to plist files...
By default, the TestEditToolPaletteCollection editor presumes you have a Rhino for Windows rui file you would like to conver... [truncated]

Essential Code:
<Reference Include="Rhino.UI">
  <HintPath>\Applications\Rhinoceros.app\Contents\Frameworks\RhCore.framework\Versions\Current\Resources\Rhino.UI.dll</HintPath>
  <Private>False</Private>
</Reference>
<Reference Include="RhinoMac">
  <HintPath>\Applications\Rhinoceros.app\Contents\Frameworks\RhCore.framework\Versions\Current\Resources\RhinoMac.dll</HintPath>
  <Private>False</Private>
</Reference>

protected override Rhino.PlugIns.LoadReturnCode OnLoad (ref string errorMessage)
{
  var pluginPath = System.IO.Path.GetDirectoryName(Assembly.Location);
  var resourcesPath = System.IO.Path.Combine (pluginPath, "Resources");
  var plistPath = System.IO.Path.Combine (resourcesPath, "ToolPalette.plist");
  bool didLoad = RhinoMac.Runtime.MacPlatformService.LoadToolPaletteCollection (plistPath);
  if (!didLoad)
    System.Diagnostics.Debug.WriteLine("WARNING: Failed to load tool palette.");

  return base.OnLoad (ref errorMessage);
}


GUIDES / RHINOCOMMON / LOCALIZE-PLUGIN-TOOLBAR
------------------------------------------------------------

Index
Source: guides\rhinocommon\localize-plugin-toolbar\index.md
Question

What is the best way to prepare a Rhino toolbar for multi-language support?

Answer

If you want to create Rhino-style toolbars, then use Rhino's Toolbar command. You can save your custom toolbars in your own Rhino User Interface (RUI) file. For details on creating toolbars, see the Rhino help file.

An RUI file is an XML file that can be viewed and edited in an ordinary text editor.

If you open an RUI file, that contains a toolbar that contains a button, you might see a block of XML that looks similar to the following:



 RenderSettings

 Render settings

 Render

 DocumentPropertiesPage Render



Notice the  tag, which denotes the text used by Rhino when configured for English (United States).

It is possible to add additional locale tags for supported language.



 RenderSettings
 Rendereinstellungen
 RenderizadoOpciones
 ParamètresRendu
 RenderingImpostazioni
 렌더링설정
 渲染设置
 彩現設定

 Render settings
 Rendereinstellungen
 Opciones de renderizado
 Paramètres du rendu
 Impostazioni rendering
 ﾚﾝﾀﾞﾘﾝｸﾞ設定
 렌더링 설정
 渲染设置
 彩現設定

 Render
 Rendern
 Renderizar
 Rendu
 Rendering
 ﾚﾝﾀﾞﾘﾝｸﾞ
 렌더링
 渲染
 彩現

 DocumentPropertiesPage _Render



Note, it is not possible to localize toolbar bitmaps.

GUIDES / RHINOCOMMON / MOVING-TO-DOTNET-CORE
------------------------------------------------------------

Index
Source: guides\rhinocommon\moving-to-dotnet-core\index.md
Rhino 8 now uses the open source .NET Core Runtime for running .NET code on both Windows and Mac.
This brings some performance improvements and aligns the .NET runtimes used across platforms. Previously, Rhino 7 and earlier used the mono runtime on Mac, and .NET Framework exclusively on Windows.

On Windows, you can still optionally run using the .NET Framework runtime in the case of compatibility issues or running inside other software that requires it (e.g. Rhino.Inside Revit).

Most plugins are already compatible when running in .NET Core without any recompilation, but in the case of any incompatibilities you may need to update your plugin.

Advantages of .NET Core for Rhino

Using .NET Core allows Rhino and plugins to take advantage of many performance improvements which will make just about all .NET code execute much faster. This can potentially provide huge productivity gains with computational libraries or large data sets.

Additionally, using .NET Core on Mac eliminates a lot of compatibility issues between the Mac and Windows versions of Rhino making it easier to make plugins work on both platforms.

Choosing the .NET Runtime on Windows

There may be reasons to continue to use .NET Framework on Windows, in particular if you need to use 3rd party plugins that aren't compatible with .NET Core yet. The disadvantage to using .NET Framework is that Rhino may run a little slower in certain use cases. 

Rhino 8 initially shipped with the .NET 7.0.0 runtime. Rhino 8.12 or later has the option to use a manually installed .NET 8 runtime, and Rhino 8.20 installs and defaults to using .NET 8.0.14 or later.

There are a few ways to select the runtime and version that Rhino uses:
Use the SetDotNetRuntime command, then restart Rhino.
Pass either /netcore or /netfx as an argument when launching Rhino.exe. This overrides the SetDotNetRuntime setting.
Pass either /netcore-8 or /netcore-7 to specify a particular .NET Core version. This requires that the chosen version is manu... [truncated]

GUIDES / RHINOCOMMON / OBJECT-SELECTION-OPTIONS
------------------------------------------------------------

Index
Source: guides\rhinocommon\object-selection-options\index.md
GetObject

RhinoCommon's GetObject class has a few properties and methods that you need to use, including:
GetObject.EnableClearObjectsOnEntry
GetObject.EnableUnselectObjectsOnExit
GetObject.DeselectAllBeforePostSelect

Also, after clicking a command line option, turn off pre-selection, using GetObject.EnablePreSelect. Otherwise, GetObject.GetMultiple will return with a GetResult.Object return code.

For example:

 C#
 VB.NET


using System;
using Rhino;
using Rhino.Commands;
using Rhino.DocObjects;
using Rhino.Input;
using Rhino.Input.Custom;

...

protected override Result RunCommand(RhinoDoc doc, RunMode mode)
{
 const ObjectType geometryFilter = ObjectType.Surface ObjectType.PolysrfFilter ObjectType.Mesh;
 int integer1 = 300;
 int integer2 = 300;

 OptionInteger optionInteger1 = new OptionInteger(integer1, 200, 900);
 OptionInteger optionInteger2 = new OptionInteger(integer2, 200, 900);

 GetObject go = new GetObject();
 go.SetCommandPrompt("Select surfaces, polysurfaces, or meshes");
 go.GeometryFilter = geometryFilter;
 go.AddOptionInteger("Option1", ref optionInteger1);
 go.AddOptionInteger("Option2", ref optionInteger2);
 go.GroupSelect = true;
 go.SubObjectSelect = false;
 go.EnableClearObjectsOnEntry(false);
 go.EnableUnselectObjectsOnExit(false);
 go.DeselectAllBeforePostSelect = false;

 bool bHavePreselectedObjects = false;

 for (;;)
 {
 GetResult res = go.GetMultiple(1, 0);

 if (res == GetResult.Option)
 {
 go.EnablePreSelect(false, true);
 continue;
 }

 else if (res != GetResult.Object)
 return Result.Cancel;

 if (go.ObjectsWerePreselected)
 {
 bHavePreselectedObjects = true;
 go.EnablePreSelect(false, true);
 continue;
 }

 break;
 }

 if (bHavePreselectedObjects)
 {
 // Normally, pre-selected objects will remain selected, when a
 // command finishes, and post-selected objects will be unselected.
 // This this way of picking, it is possible to have a combination
 // of pre-selected and post-selected. So, to make sure everything
 // "looks the... [truncated]

Essential Code:
using System;
using Rhino;
using Rhino.Commands;
using Rhino.DocObjects;
using Rhino.Input;
using Rhino.Input.Custom;

...

protected override Result RunCommand(RhinoDoc doc, RunMode mode)
{
  const ObjectType geometryFilter = ObjectType.Surface | ObjectType.PolysrfFilter | ObjectType.Mesh;
  int integer1 = 300;
  int integer2 = 300;

  OptionInteger optionInteger1 = new OptionInteger(integer1, 200, 900);
  OptionInteger optionInteger2 = new OptionInteger(integer2, 200, 900);

  GetObject go = new GetObject();
  go.SetCommandPrompt("Select surfaces, polysurfaces, or meshes");
...
Imports Rhino
Imports Rhino.Commands
Imports Rhino.DocObjects
Imports Rhino.Input
Imports Rhino.Input.Custom

...

Protected Overrides Function RunCommand(doc As RhinoDoc, mode As RunMode) As Result
  Const geometryFilter As ObjectType = ObjectType.Surface Or ObjectType.PolysrfFilter Or ObjectType.Mesh
  Dim integer1 As Integer = 300
  Dim integer2 As Integer = 300

  Dim optionInteger1 As New OptionInteger(integer1, 200, 900)
  Dim optionInteger2 As New OptionInteger(integer2, 200, 900)

  Dim go As New GetObject()
  go.SetCommandPrompt("Select surfaces, polysurfaces, or meshes")
  go.GeometryFilter = geometryFilter
  go.AddOptionInteger("Option1", optionInteger1)
...

GUIDES / RHINOCOMMON / OPTIONS_PAGES_BEST_PRACTICES
------------------------------------------------------------

Index
Source: guides\rhinocommon\options_pages_best_practices\index.md
Overview

One of the things your plug-in may want to do is add options or document property settings pages to Rhino. You can add pages by overriding the PlugIn.OptionsDialogPages and/or PlugIn.DocumentPropertiesDialogPages methods and adding a custom OptionsDialogPage to the provided page list.

You can create options pages in a plug-in using WinForms(Windows), WPF (Windows) or Eto (Windows and Mac).

You can find samples that demonstrate how to create options pages in the Developer Samples repository on GitHub.

Details

When writing options pages, it is important to remember that the page should initialize its content when activated, apply its changes when notified and optionally provide cancel support.

Content Initialization

The OnActivate method is called with  == true when becoming the current, visible page which is the appropriate time to update the page contents.

Applying Changes

It is up to the page author to decide when to apply user changes to the document or runtime environment. If you wish to see the document or Rhino update while making changes, you may apply the changes in real time. It is important to save the original settings prior to making changes if your options page is going to support the cancel mechanism. Typically changes should be queued up and made in the OnApply override, canceling should be performed in the OnCancel override.

Rhino for Windows Behavior

Rhino for Windows contains a single Options/Document Properties dialog box which can be displayed using the Options or DocumentProperties Rhino commands. This dialog box is modal in nature and will call the PlugIn.OptionsDialogPages and PlugIn.DocumentPropertiesDialogPages methods each time it is displayed. It creates the PageControl the first time the page is made current. If your page is never made current, the page control is never created. Rhino will call OnActivate with  == true when a page becomes the active page. When a page is no longer active, the OnActivate ... [truncated]

GUIDES / RHINOCOMMON / PLUGIN-INSTALLERS-MAC
------------------------------------------------------------

Index
Source: guides\rhinocommon\plugin-installers-mac\index.md
{{}}
⚠️ The .macrhi format is no longer in active development. Please see the Package Manager instead.
{{}}

It is presumed you have a plugin that successfully builds and runs already. If you are not there yet, see Your First Plugin (Mac).

Overview

Rhino for Mac does not (yet) have a Plugin Manager. However, installing plugins is very easy. You simply rename your plugin's containing folder with an special extension (.rhp), compress the folder, and change the extension from .rhp.zip to .macrhi. Once this is done, you can double-click the archive and Rhino will launch and install the plugin. You can also drag the .macrhi onto the dock icon of a running instance of Rhino and it will install the plugin as well. You will, in any case, need to Quit an Restart Rhino for the plugin to activate.

Step-by-Step
Locate your plugin folder in Finder. Let's imagine our plugin is called HelloRhinoCommon and we have built it for Release...
!Find Plugin In Finder
Single-click the name your plugin's Release (or Debug) folder to Rename it. The new name should be your plugin assembly with a .rhp suffix. For example, if your plugin is called HelloRhinoCommon, rename the folder that contains this file HelloRhinoCommon.rhp...
You will be prompted to confirm this change. Click the "Add" button:
!Click Add
The icon of the folder[^1] should now look like this...
!New Icon
Archive the plugin folder. Right-click (option-click) the plugin .rhp folder you created in the previous step and select "Compress (your plugin name)." This creates a zip archive of the contents of the folder.
Single-click the name of the new archive you created in step 5. This allows you to rename the archive.
Change the extension from .rhp.zip to .macrhi. 
You will be prompted to confirm this change. Select the "Use .macrhi" button:
!Use rhi Extension
Notice that the icon changes from a zip archive to a Rhino RHI:
!usemacrhiconfirm
If Rhino for Mac is open, drag the .macrhi archive onto Rhino for Mac's icon in the dock; ... [truncated]

GUIDES / RHINOCOMMON / PLUGIN-INSTALLERS-WINDOWS
------------------------------------------------------------

Index
Source: guides\rhinocommon\plugin-installers-windows\index.md
{{}}
⚠️ The Rhino Installer Engine is no longer in active development. Please see the Package Manager instead.
{{}}

{{}}
 You simply add your compiled plugin to a zip archive and change the extension from .zip to .rhi. Once this is done, you can double-click the archive and the Rhino Installer Engine will begin to install your plugin. That's all there is to it!

{{}}
This is intended to be a quickstart guide. For a more general overview please see the Rhino Installer Engine guide.
{{}}

An Example

Imagine you have a plugin and want to support multiple versions of Rhino. For example, you want to:
Install the latest version of the plugin for Rhino WIP
Install an older version of the plugin for 64-bit Rhino 5
Install yet another version of the plugin for 32-bit Rhino 5
Include a custom toolbar file (e.g. MyToolbar.rui)

This is possible. You need to:
Create an "installer image" folder. In this example, the folder is the name of the product – Marmoset. This folder will contain only the files you want to install on the user's system.

 Marmoset/
 ├── Rhino 6/
 │ ├── Marmoset.rhp
 │ └── requiredwip.dll
 ├── Rhino 5.0/
 │ ├── x86/
 │ │ ├── Marmoset.rhp
 │ │ └── requiredv5x86.dll
 │ └── x64/
 │ ├── Marmoset.rhp
 │ └── requiredv5_x86.dll
 ├── Marmoset.rui
 ├── Marmoset.chm
 └── README.txt
Copy the appropriate files into the folders[^1]. Note that all three versions of the plugin can have the same name, so long as they are in different folders.
Add all the files inside the "installer image" folder to a new ZIP[^2] archive
Change the extension from .zip to .rhi

Everything but the kitchen sink

Because the Rhino Plugin Installer Engine unzips your .rhi file into a directory specific to your plugin, you can include anything you want: help files, documentation, etc. These files will end up inside your plugin directory; The Rhino Installer Engine cann... [truncated]

GUIDES / RHINOCOMMON / PLUGIN-USER-DATA
------------------------------------------------------------

Index
Source: guides\rhinocommon\plugin-user-data\index.md
There are two basic ways plugins can store information in Rhino .3dm files:
Document User Data
Object User Data

For example, a rendering plugin might save a scene descriptions as document user data and use object user data to attach rendering material information to individual surfaces.

Document User Data

To save document user data your plugin must override three PlugIn base class functions:


PlugIn.ShouldCallWriteDocument
PlugIn.WriteDocument
PlugIn.ReadDocument


SDK references for these functions can be found here.

When Rhino writes a .3dm file, it goes through all the plugins that are currently loaded. First Rhino calls ShouldCallWriteDocument() to see if the plugin wants to save document user data. If ShouldWriteDocument() returns true, Rhino saves information that identifies the plugin and then calls WriteDocument() when it is time for the plugin to save its “document” user data.

When Rhino reads a .3dm file and it encounters document user data, it uses the plugin identification information to load the plugin and then calls the plugin's ReadDocument() to read the plugin's “document” user data.

Object User Data

Object user data can be attached to things like layers, materials, geometry objects, and object attributes. In fact object user data can be attached to any class derived from CommonObject. This user data is stored in a linked list on CommonObject and can be copied, transformed and saved along with the parent object. For example, you could attach object user data to a mesh. When the mesh is copied the object user data would be copied and attached to the copy. When the mesh is transformed, the transformation would be recored by the object user data. When the mesh is saved in a .3dm file, the object user data will be saved too.

There are three forms of object user data:
User strings
UserDictionary
Custom UserData

It is recommended to typically use the User Strings or the UserDictionary on an object since the data is automatically serialized f... [truncated]

Essential Code:
using System;
using Rhino;
using System.Runtime.InteropServices;

namespace examples_cs
{
  // You must define a Guid attribute for your user data derived class
  // in order to support serialization. Every custom user data class
  // needs a custom Guid
  [Guid("DAAA9791-01DB-4F5F-B89B-4AE46767C783")]
  public class PhysicalData : Rhino.DocObjects.Custom.UserData
  {
    public int Weight{ get; set; }
    public double Density {get; set;}


    // Your UserData class must have a public parameterless constructor
    public PhysicalData(){}

    public PhysicalData(int weight, double density)
...

GUIDES / RHINOCOMMON / PROCEDURALLY-GENERATE-TOOLBARS
------------------------------------------------------------

Index
Source: guides\rhinocommon\procedurally-generate-toolbars\index.md
Question

I am trying to generate a toolbar without using Rhino. Having a toolbar with correct macros is done and working, but the bitmap (icons) part is still problematic

I’m not sure if the issue is with the image generation or the GUID system of Rhino.

For each icon size, the script takes all the icons needed and makes a big one, resulting in a column of icons. Then the image is translated to Base64 format.

Rhino does not recognize these images. They are not displayed. And upon saving the toolbar, all the previous icon data is replaced with a blank image.

Answer

Toolbar bitmaps are stored in a grid with 250 columns and enough rows to accommodate the total item count. New items are added to then end of the last row until the row fills up at which time a new row is added to the bitmap. Rhino writes the bitmap as a PNG file to a stream and then writes the raw bitmap to the RUI file. 

Here is some sample code for writing:

const string NODEBITMAPITEM = "bitmapitem";
const string NODEBITMAP = "bitmap";
...
public void Write(System.Xml.XmlWriter writer, string elementName)
{
 writer.WriteStartElement(elementName);
 {
 writer.WriteAttributeString("itemwidth", mitemsize.Width.ToString());
 writer.WriteAttributeString("itemheight", mitemsize.Height.ToString());
 foreach (KeyValuePair kvp in midlist)
 {
 writer.WriteStartElement(NODEBITMAPITEM);
 {
 writer.WriteAttributeString("guid", kvp.Key.ToString());
 writer.WriteAttributeString("index", kvp.Value.mindex.ToString());
 }
 writer.WriteEndElement();
 }
 writer.WriteStartElement(NODEBITMAP);
 {
 if (null != FullBitmap)
 {
 try
 {
 using (var stream = new MemoryStream())
 {
 FullBitmap.Save(stream, System.Drawing.Imaging.ImageFormat.Png);
 byte[] bytes = stream.GetBuffer();
 if (null != bytes && bytes.Length > 0)
 writer.WriteString(Convert.ToBase64String(bytes, Base64FormattingOptions.InsertLineBreaks));
 }
 }
 catch (Exception ex)
 {
 Rhino.Runtime.HostUtils.ExceptionReport(ex);
 }
 }
 }
 writer.WriteEndElem... [truncated]

GUIDES / RHINOCOMMON / REGISTERING-PLUGINS-WINDOWS
------------------------------------------------------------

Index
Source: guides\rhinocommon\registering-plugins-windows\index.md
Overview

While a Rhino plugin can simply be distributed as a .rhp file, and loaded using Rhino's PlugInManager command, it is often necessary to install the plugin as part of a product installation process. To install plugin from an installer, your installer will be required to access a number of entries in the Windows Registry.

While reading this article, it is helpful to use the standard Windows Registry editing tool, REGEDIT.EXE, to follow along and see how Rhino's Registry entries are structured.

Finding the Rhino Registry Key

Rhino plugins are registered at the following location in the Windows Registry:

HKEYLOCALMACHINE\Software\McNeel\Rhinoceros\MajorVersion.0\Plug-ins

Where MajorVersion is the major version of Rhino (e.g. 6, 7, 8).

Registering Your Plugin

To register your plugin with Rhino, you will need to create a new Registry key at the above location. The name of the Registry key will be your plugin's GUID, formatted as a string. For example:

HKEYLOCALMACHINE\Software\McNeel\Rhinoceros\MajorVersion.0\Plug-ins\

Under this new Registry key, create two new value names, Name and FileName that contain strings that identify your plugin's name and the full path to the .rhp file, respectively. For example, if you had created a new plugin named "MySamplePlugIn", the registry might look something like the following:


HKEYLOCALMACHINE\SOFTWARE\McNeel\Rhinoceros\MajorVersion.0\Plug-Ins\F3CF4A28-EA9E-4E08-BABA-5FC6645A5D72

Value: Name
Type: REGSZ
Data: MySamplePlugIn

Value: FileName
Type: REGSZ
Data: C:\Program Files\My Company\My Sample PlugIn\MySamplePlugIn.rhp


Automatic Loading

Rhino will attempt to load your plugin the next time Rhino launches if the Name and FileName Registry values and data are present in your plugin's Registry key. Rhino will briefly display a "Preparing plugins for first use" dialog if the plugin loads correctly.

When your plugin loads for the first time, the rest of the normal Registry keys/value pairs in your plu... [truncated]

GUIDES / RHINOCOMMON / RENDER-ENGINE-INTEGRATION-CHANGEQUEUE
------------------------------------------------------------

Index
Source: guides\rhinocommon\render-engine-integration-changequeue\index.md
Overview

This is part three in the series on render engine integration in Rhinoceros 3D using RhinoCommon (v6).
Setting up the plug-in
Modal Rendering
ChangeQueue (this guide)
Interactive render - viewport integration
Preview render (forthcoming)

If you have not already read parts one) and two), please do so before proceeding.

Converting the Document

When it comes to converting a 3dm document to a form our render engine understands there are two options: the hard way, or the easy way.

The hard way would be to just take the RhinoDoc given in the Render() function and then iterate over the many different tables with DocObjects and do the conversion then and there. For geometry and render content it probably won't be too hard, but when it comes to Blocks and Block instances it all becomes quite complex very quickly.

Since I don't like complex I'll just go with the easy way.

The code for this plug-in version can be found at the MockingBird Git repository.

ChangeQueue

The ChangeQueue is a central way of getting the 3dm in an already pre-digested format. Among things it will handle Blocks and their instances all for you. The ChangeQueue is also usable for both production (modal) rendering and interactive real-time rendering in the viewport. Even preview scene rendering can be done through the ChangeQueue mechanism, meaning that preview rendering can be easily added without too much hassle. We'll come to that later though.

Setting up the ChangeQueue is pretty straight-forward. A class deriving from Rhino.Render.ChangeQueue.ChangeQueue is needed and a set off Apply-functions need to be implemented.


public class MockingChangeQueue : ChangeQueue
{
 // for a regular rhino document (i.e. currently
 // active)
 // The constructor can look like you want, as long as the plugin ID,
 // document serial number and view info are given, needed for
 // the base class
 public MockingChangeQueue(Guid pluginId, uint docRuntimeSerialNumber, ViewInfo viewinfo)
 : base(pluginI... [truncated]

Essential Code:
public class MockingChangeQueue : ChangeQueue
{
	// for a regular rhino document (i.e. currently
	// active)
	// The constructor can look like you want, as long as the plugin ID,
	// document serial number and view info are given, needed for
	// the base class
	public MockingChangeQueue(Guid pluginId, uint docRuntimeSerialNumber, ViewInfo viewinfo)
		: base(pluginId, docRuntimeSerialNumber, viewinfo)
	{
	}

	/// <summary>
	/// The camera information.
	/// </summary>
	/// <param name="viewInfo">new viewport info</param>
	protected override void ApplyViewChange(ViewInfo viewInfo)
	{
		var vp = viewInfo.Viewport;
		int near, far;
...
public MockingChangeQueue ChangeQueue { get; private set; }

public MockingRenderContext(PlugIn plugIn, RhinoDoc doc)
{
	// set up view info
	ViewInfo viewInfo = new ViewInfo(doc.Views.ActiveView.ActiveViewport);
	ChangeQueue = new MockingChangeQueue(plugIn.Id, doc.RuntimeSerialNumber, viewInfo);
}


GUIDES / RHINOCOMMON / RENDER-ENGINE-INTEGRATION-INTERACTIVE-VIEWPORT
------------------------------------------------------------

Index
Source: guides\rhinocommon\render-engine-integration-interactive-viewport\index.md
Overview

This is part four in the series on render engine integration in Rhinoceros 3D using RhinoCommon.
Setting up the plug-in
Modal Rendering
ChangeQueue
Interactive render - viewport integration (this guide)
Preview render (forthcoming)

If you have not already read the first three parts, please do so before proceeding.

Realtime Display

For this plug-in we are going to do things in a slightly different way. Not because it is a must, but because it gives an interesting possibility for plug-in developers who want to integrate their own render engines, but without exposing it to the Render command. We do that with a generic utility plug-in. There won't be an API to implement for the Render command, instead we'll implement two new classes. One derived from Rhino.Render.RealtimeDisplayMode and one derived from Rhino.Render.RealtimeDisplayModeClassInfo.

Together these will effectively create and register a conduit that is used during the drawing process of a viewport to display the result of the render engine.

For this example a ChangeQueue implementation is used, but as said in earlier articles it is possible to do your data conversion directly from the RhinoDoc. If the render engine to be integrated is one using mesh data for geometry I advise strongly to use the ChangeQueue.

Utility plug-in


public class MockingViewportPlugIn : Rhino.PlugIns.PlugIn
{
 public MockingViewportPlugIn()
 {
 if (Instance == null) Instance = this;
 }

 public static MockingViewportPlugIn Instance { get; private set; }

 protected override LoadReturnCode OnLoad(ref string errorMessage)
 {
 // RealtimeDisplayMode.RegisterDisplayModes(this);
 // call to RegisterDisplayModes no longer necessary, it is automatically called.
 return LoadReturnCode.Success;
 }
}



The plug-in code is very lean, only LoadRetunCode OnLoad() needs to be overridden. With a proper RealtimeDisplayModeClassInfo and RealtimeDisplayMode implementation the new viewport mode will be registered with Rhino. It'l... [truncated]

Essential Code:
public class MockingViewportPlugIn : Rhino.PlugIns.PlugIn
{
	public MockingViewportPlugIn()
	{
		if (Instance == null) Instance = this;
	}

	public static MockingViewportPlugIn Instance { get; private set; }

	protected override LoadReturnCode OnLoad(ref string errorMessage)
	{
		// RealtimeDisplayMode.RegisterDisplayModes(this);
		// call to RegisterDisplayModes no longer necessary, it is automatically called.
		return LoadReturnCode.Success;
	}
}


public class MockingRealtimeDisplayModeInfo : RealtimeDisplayModeClassInfo
{
	public override string Name => "MockingRealtimeMode";

	public override Guid GUID => new Guid("F14A3A24-C2FB-4216-9D2A-9636EF3869FA");

	public override Type RealtimeDisplayModeType => typeof (MockingRealtimeDisplayMode);
}


GUIDES / RHINOCOMMON / RENDER-ENGINE-INTEGRATION-INTRODUCTION
------------------------------------------------------------

Index
Source: guides\rhinocommon\render-engine-integration-introduction\index.md
Overview

If you're a render engine developer and you're thinking of writing an integration plug-in for Rhino, then you definitely should keep reading on.

For this series I'll be looking into how one would go about integrating a render engine using RhinoCommon.

The subject will be broken up into several guides:
Setting up the plug-in (this guide)
Modal Rendering
ChangeQueue
Interactive render - viewport integration
Preview render (forthcoming)

For each guide we'll take a look at relevant parts of the integration plug-in for the Cycles render engine while doing several simple example plug-ins at the same time. The code for the example plug-ins will be stripped of (most) of the comments that are added by the template, so we can focus on the parts that matter. Source code for the sample project, dubbed MockingBird, is available on GitHub.

Creating Render Plug-in project

Install the RhinoCommon template package

To make developing a new plug-in for Rhinoceros 3D easy McNeel has published a template packages. Search for the string rhino and install the relevant package.

!template image

Once the template package is installed we're ready to write amazing plug-ins for Rhino.

Create a new RhinoCommon v6 project

!template image

Lets create a new plug-in now that the wizard is installed. Simply create a new project in Visual Studio, and from the Visual C# section under Templates select Rhinoceros. Pick RhinoCommon Plug-In for Rhinoceros and give a name.

After you click on OK you'll be presented with a wizard dialog where settings can be changed. For our case we select Render plug-in. If the wizard fails to recognize a Rhino installation path one can set the necessary paths before accepting the settings. Click on the Finish button when happy with the settings.

!template image

The plug-in wizard will generate a set of files for the developer.

Adjust assembly configuration

Before diving into the deep it probably is a good idea to change the assembly information and... [truncated]

Essential Code:
using System;
using Rhino;

namespace MockingBird
{
	public class MockingBirdPlugIn : Rhino.PlugIns.RenderPlugIn
	{
		public MockingBirdPlugIn()
		{
			Instance = this;
		}

		public static MockingBirdPlugIn Instance
		{
			get; private set;
		}

		protected override Rhino.Commands.Result Render(RhinoDoc doc, Rhino.Commands.RunMode mode, bool fastPreview)
		{
			throw new NotImplementedException("Render is not implemented in the MockingBird.MockingBirdPlugIn class.");
...
using System;
using Rhino;

namespace MockingBird
{
	public class MockingBirdPlugIn : Rhino.PlugIns.RenderPlugIn
	{
		public MockingBirdPlugIn()
		{
			if(Instance==null) Instance = this;
		}

		public static MockingBirdPlugIn Instance
		{
			get; private set;
		}

		protected override Rhino.Commands.Result Render(RhinoDoc doc, Rhino.Commands.RunMode mode, bool fastPreview)
		{
			return Result.Success;
...

GUIDES / RHINOCOMMON / RENDER-ENGINE-INTEGRATION-MODAL
------------------------------------------------------------

Index
Source: guides\rhinocommon\render-engine-integration-modal\index.md
Overview

This is part two in the series on render engine integration in Rhinoceros 3D using RhinoCommon. 
Setting up the plug-in
Modal Rendering (this guide)
ChangeQueue
Interactive render - viewport integration
Preview render (forthcoming)

If you have not already read part one), please do so before proceeding.

Render

To implement a modal rendering solution for Rhinoceros there are two particular pieces you'll need to create, which will allow you to render into a separate render window: a custom implementation of a Rhino.Render.AsyncRenderContext, and a Rhino.Render.RenderPipeline.

The full source code of this plug-in can be found here.

The rendering will start when giving the Rhino command Render. This will result in a call into the Render() of your Render plug-in implementation.

{{}}

protected override Result Render(RhinoDoc doc, RunMode mode, bool fastPreview)
{
 // initialise our render context
 MockingRenderContext rc = new MockingRenderContext();

 // initialise our pipeline implementation
 RenderPipeline pipeline = new MockingRenderPipeline(doc, mode, this, rc);

 // query for render resolution
 var renderSize = RenderPipeline.RenderSize(doc);

 // set up view info
 ViewInfo viewInfo = new ViewInfo(doc.Views.ActiveView.ActiveViewport);

 // set up render window
 rc.RenderWindow = pipeline.GetRenderWindow();
 // add a wireframe channel for curves/wireframes/annotation etc.
 rc.RenderWindow.AddWireframeChannel(doc, viewInfo.Viewport, renderSize, new Rectangle(0, 0, renderSize.Width, renderSize.Height));
 // set correct size
 rc.RenderWindow.SetSize(renderSize);

 // now fire off render thread.
 var renderCode = pipeline.Render();

 // note that the rendering isn't complete yet, rather the pipeline.Render()
 // call starts a rendering thread. Here we essentially check whether
 // starting that thread went ok.
 if (renderCode != RenderPipeline.RenderReturnCode.Ok)
 {
 RhinoApp.WriteLine("Rendering failed:" + rc.ToString());
 return Result.Failure;
 }
... [truncated]

Essential Code:
protected override Result Render(RhinoDoc doc, RunMode mode, bool fastPreview)
{
	// initialise our render context
	MockingRenderContext rc = new MockingRenderContext();

	// initialise our pipeline implementation
	RenderPipeline pipeline = new MockingRenderPipeline(doc, mode, this, rc);

	// query for render resolution
	var renderSize = RenderPipeline.RenderSize(doc);

	// set up view info
	ViewInfo viewInfo = new ViewInfo(doc.Views.ActiveView.ActiveViewport);

	// set up render window
	rc.RenderWindow = pipeline.GetRenderWindow();
	// add a wireframe channel for curves/wireframes/annotation etc.
	rc.RenderWindow.AddWireframeChannel(doc, viewInfo.Viewport, renderSize, new Rectangle(0, 0, renderSize.Width, renderSize.Height));
	// set correct size
	rc.RenderWindow.SetSize(renderSize);
...
public class MockingRenderPipeline : RenderPipeline
{
	private readonly MockingRenderContext m_rc;
	public MockingRenderPipeline(RhinoDoc doc, RunMode mode, RenderPlugIn plugin, MockingRenderContext rc)
		: base(doc, mode, plugin, RenderSize(doc),
				"MockingBird (modal)", Rhino.Render.RenderWindow.StandardChannels.RGBA, false, false)
	{
		m_rc = rc;
	}

	protected override bool OnRenderBegin()
	{
		m_rc.Thread = new Thread(m_rc.Renderer)
		{
			Name = "MockingBird Modal Rendering thread"
		};
		m_rc.Thread.Start();
		return true;
	}

...

GUIDES / RHINOCOMMON / RHINOACCOUNTS / RA-EXAMPLE
------------------------------------------------------------

Index
Source: guides\rhinocommon\rhinoaccounts\ra-example\index.md
To retrieve an OAuth 2 Token for authorization or an OpenID Connect token to learn about the user's identity, all that is needed is to call one of the different overloads of GetAuthTokensAsync. This method will asynchronously ask the user for permission to obtain the tokens, and return them to you so that you can use them as you wish.

By default, a successful call to GetAuthTokensAsync will cache the tokens you retrieved in a secure persistent store so that they can later be retrieved using TryGetAuthTokens without having to ask the user for permission or wait for potentially lengthy network requests. In most scenarious, it makes sense to call TryGetAuthTokens first to see if there are any cached tokens available. If there aren't, you can then call GetAuthTokensAsync and ask the user for permission.

Important  This is done to make sure that only a valid, signed assembly can retrieve auth tokens. Code inside the protected function should be kept as small as possible for performance and security reasons.

Example:


using Rhino.Runtime.RhinoAccounts;

...

Tuple authTokens = null;

await RhinoAccountsManager.ExecuteProtectedCodeAsync(async (SecretKey secretKey) =>
{
 authTokens = RhinoAccountsManager.TryGetAuthTokens("MYPLUGINID",secretKey);

 if (authTokens == null) 
 {
 authTokens = await RhinoAccountsManager.GetAuthTokensAsync(
 "MYPLUGINID",
 "MYPLUGINSECRET",
 secretKey,
 CancellationToken.None
 );
 }
}); 


For details on all the available options you can specify on the methods described above such as scope and maxage, please see the Rhino Accounts Reference.

GUIDES / RHINOCOMMON / RHINOACCOUNTS / RA-OVERVIEW
------------------------------------------------------------

Index
Source: guides\rhinocommon\rhinoaccounts\ra-overview\index.md
Overview

Rhino Accounts is an authentication and authorization system built and supported by Robert McNeel & Associates. It is built on top of the OpenID Connect protocol. 

As a brief summary, the authentication services of Rhino Accounts enables you, the developer, to verify an individual's identity and access (with the user's permission) account information such as their name, email addresses, profile picture, and more. This allows you to tailor your experience for the user or  about who is using your product.

The authorization services are based on OAuth 2 Tokens. A token allows you to access any services that use Rhino Accounts for authorization, including your own. For example, your web server might accept certain files to be uploaded and downloaded from your plugin that sync accross different machines. An authorization token can be obtained by your plugin and can be presented to your web server when uploading or downloading files. The web server can check with Rhino Accounts that the token is valid and the individual it belongs to.

For a more thourough overview of Rhino Accounts, please see the Rhino Accounts Reference.

OpenID Connect is built on top of HTTP. Since Rhino Accounts is an OpenID Connect provider, you can interact with Rhino Accounts using any HTTP client from .NET, JavaScript, Python, etc. However, making raw HTTP calls to Rhino Accounts can be tedious. Handling all the possible outcomes can be time consuming, and future-proofing your code in case the HTTP endpoints change can be frustrating. More importantly, taking into account all the possible security considerations to avoid leaking sensisive user data requires a rigorous review of your code. For all these reasons, we strongly recommend that you use Rhino's built in capabilities to interact with Rhino Accounts described in this guide. It will also greatly simplify your development and make things easier down the road.

Taking advantage of Rhino Accounts within Rhino is simple, and requir... [truncated]

GUIDES / RHINOCOMMON / RHINOACCOUNTS / RA-REVOKE
------------------------------------------------------------

Index
Source: guides\rhinocommon\rhinoaccounts\ra-revoke\index.md
Once you have obtained an OAuth 2 Token, you can use it in any authentication workflow you wish. There may come a time, however, when the token is no longer needed. In such cases, it is highly recommended that your software has a way of revoking the OAuth 2 token. Revoking a token will generate a network request to the Rhino Accounts server which will invalidate the token so that it can no longer be used.

Important  This is done to make sure that only a valid, signed assembly can retrieve auth tokens. Code inside the protected function should be kept as small as possible for performance and security reasons.


using Rhino.Runtime.RhinoAccounts;

...

await RhinoAccountsManager.ExecuteProtectedCodeAsync(async (SecretKey secretKey) =>
{
 await RhinoAccountsManager.RevokeAuthTokenAsync(oauth2Token, secretKey, CancellationToken.None); 
});


GUIDES / RHINOCOMMON / RHINOCOMMON-ZOO-PLUGINS
------------------------------------------------------------

Index
Source: guides\rhinocommon\rhinocommon-zoo-plugins\index.md
Overview

The LAN Zoo supports 3rd party plugins. RhinoCommon allows developers to write plugins for Rhino that use the Rhino license manager and obtain licenses from LAN Zoo servers.

When a customer attempts to add a product license to the LAN Zoo, the product's plugin is called to validate the user's request. Upon validation, the plugin will return the product's licensing information back to the LAN Zoo. In turn, the LAN Zoo will serialize, maintain, and distribute this license.

Prerequisites

It is presumed you already have the necessary tools installed and are ready to go. If you are not there yet, see Installing Tools (Windows).

Also, all plugins that use the LAN Zoo license system must be signed with an Authenticode certificate issued by McNeel Plugin Security. These certificates are free, but must be requested by each developer. Developers must agree to the Terms of Use before a certificate is issued. 

It is also presumed you have a RhinoCommon plugin you wish to add license support to. See the Your First Plugin (Windows) guide for instructions.

Add License Support

After you have built and tested your basic plugin, you can add licensing support as follows:

Step-by-Step
In your plugin's Rhino.PlugIns.PlugIn inherited class, create a new method with the same signature as the Rhino.PlugIns.ValidateProductKeyDelegate delegate. Rhino will call into this function whenever it needs your plugin to validate a license that is entered by a user, returned by the Rhino license manager (standalone node), or returned from a LAN Zoo server (network node).
In your plugin's Rhino.PlugIns.PlugIn inherited class, create a new method with the same signature as the Rhino.PlugIns.OnLeaseChangedDelegate delegate. Rhino will call into this function if your product supports Rhino Accounts. When Rhino Accounts gets a new lease, this function is called. 
In your plugin's Rhino.PlugIns.PlugIn.OnLoad ... [truncated]

GUIDES / RHINOCOMMON / RUN-RHINO-COMMAND-FROM-PLUGIN
------------------------------------------------------------

Index
Source: guides\rhinocommon\run-rhino-command-from-plugin\index.md
The Problem

One of the most common questions asked by new plugin developers is how to run, or script, existing Rhino commands from a plugin command. Rhino doesn't allow plugin commands to run other commands except under very special circumstances.

Here's the problem: If you have a command that is modifying the Rhino document, and you run another command, problems can happen.

To work around this, the RhinoCommon provides a special kind of command called a script command. You can create a script command as follows...

The Solution

When defining your command class, make sure to add the ScriptRunner command style attribute. In other words, instead of defining your command classes like this:

 C#
 VB.NET


public class TestCommand : Rhino.Commands.Command




Public Class TestCommand
 Inherits Rhino.Commands.Command


Define your command classes like this:

 C#
 VB.NET


[Rhino.Commands.CommandStyle(Rhino.Commands.Style.ScriptRunner)]
public class TestCommand : Rhino.Commands.Command





Public Class TestCommand
 Inherits Rhino.Commands.Command


Then, from within your command class's RunCommand() method, you can call RhinoApp.RunScript() to script the running of a Rhino command. For example...

 C#
 VB.NET


protected override Rhino.Commands.Result RunCommand(Rhino.RhinoDoc doc, Rhino.Commands.RunMode mode)
{
 Rhino.RhinoApp.RunScript("-Line 0,0,0 10,10,10", false);
 return Rhino.Commands.Result.Success;
}




Protected Overrides Function RunCommand(ByVal doc As Rhino.RhinoDoc, ByVal mode As Rhino.Commands.RunMode) As Rhino.Commands.Result
 Rhino.RhinoApp.RunScript("-Line 0,0,0 10,10,10", False)
 Return Rhino.Commands.Result.Success
End Function


Warnings

This kind of command can be very dangerous. Please be sure you understand the following:
If you are not very familiar with how references work, you should only call Rhino.RhinoApp.RunScript() from within a RhinoScriptCommand derived command.
If you are very familiar with referen... [truncated]

Essential Code:
public class TestCommand : Rhino.Commands.Command


Public Class TestCommand
  Inherits Rhino.Commands.Command


GUIDES / RHINOCOMMON / SUPPORTING-HIGH-DPI-DISPLAYS
------------------------------------------------------------

Index
Source: guides\rhinocommon\supporting-high-dpi-displays\index.md
Overview

Super high resolution displays are now common on Windows-based systems, and those using Rhino expect it and 3rd party plugins to display correctly on them. Plugin developers need to make sure their applications are DPI–aware. DPI-aware plugins adjust UI elements to scale appropriately to the system DPI. Plugins that are not DPI–aware, but are running on a high-DPI display setting, can suffer from many visual artifacts, including incorrect scaling of UI elements, clipped text, and blurry images.

Plugin developers should run Rhino on high-DPI displays so they can find and fix display issues. Here is how you can configure Windows for high-DPI display:

Windows 10
Right-click on your desktop and click Display settings.
Use the slider to select the text scaling and click Apply.
Logout of Windows and log back in.

Windows 8/8.1
Right-click on your desktop and click Screen resolution.
Click the Make text and other items larger or smaller.
Use the slider to select the text scaling and click Apply.
Logout of Windows and log back in.

Windows 7
Right-click on your desktop and click Screen resolution.
Click Make text and other items larger or smaller.
Select the text scaling and click Apply.
Logout of Windows and log back in.

Common WinForms Issues

Most high DPI issues that plugins will encounter are due to owner-drawn control. Here, developers have hard-coded sizes or locations, assuming the standard DPI setting. In these cases, custom drawn elements don’t appear correctly, or custom controls don’t work properly.

Other issues have to do with the use of bitmaps or icons that are too small at higher DPI settings or that don’t scale well.

But WinForms has other challenges too. One observation is that if you spend too much time using the Forms designer, hard-coding font sizes and other values, will have DPI display issues.

General

WinForms has its own scaling mechanism which calculates the scaling difference between the system that the form has been designed on a... [truncated]

Essential Code:
/// <summary>
/// MainWindow Constructor
/// </summary>
public MainWindow()
{
  // This call is required by the Windows Form Designer.
  InitializeComponent();

  var width = RhinoWindows.Forms.Dpi.ScaleInt(m_toolbar.ImageScalingSize.Width);
  var height = RhinoWindows.Forms.Dpi.ScaleInt(m_toolbar.ImageScalingSize.Height);
  m_toolbar.ImageScalingSize = new Size(width, height);

  // ...


GUIDES / RHINOCOMMON / UNINSTALLING-PLUGINS-MAC
------------------------------------------------------------

Index
Source: guides\rhinocommon\uninstalling-plugins-mac\index.md
This guide presumes you have plugins installed that you would like to remove.

Overview

Rhino for Mac does not (yet) have a Plugin Manager. However, uninstalling plugins is very easy. You simply remove the plugin folder from the ~/Library/Application Support/McNeel/Rhinoceros/MacPlugIns/ folder[^1] and then restart Rhino.

Step-by-Step
Quit Rhino, if it is current running.
In Finder, navigate to the ~/Library/Application Support/McNeel/Rhinoceros/MacPlugIns/ folder. If you can't find this folder, you can do the following...
In the Finder toolbar, in the Go menu, select Go to Folder...
!findergo
In the Go to Folder dialog, paste the following path:
 ~/Library/Application Support/McNeel/Rhinoceros/MacPlugIns/
!pastepath
Click Go. A Finder window should open showing the contents of the folder.
Remove (move or delete) the plugin's folder from the MacPlugIns folder...
!dragtotrash
Restart Rhino.

Behind the Scenes

When Rhino for Mac launches, it searches the contents of the:

~/Library/Application Support/McNeel/Rhinoceros/MacPlugIns/

folder scanning the sub-folders recursively looking for .rhp files. When it finds such file, Rhino for Mac attempts to load this plugin. If it cannot find a plugin, it will not load said plugin...it's that simple.

User Library

By default, the User Library folder is hidden from view. 

To make your Library visible in the Finder:
In Finder, navigate to your Home (~) folder. You must be in your Home folder for this to work.
Press Command+J to bring up the Finder View options dialog...
!finderviewoptions
Check the Show Library Folder check box. Now your Library should show up in the view. You may want to drag this folder to your Favorites area of the Finder sidebar for easy access later.

Related topics
Creating a Plugin Installer (Mac)

Footnotes

[^1]: Do not confuse this path with /Library/Application Support/McNeel/Rhinoceros/, which is the system-wide Library location.

GUIDES / RHINOCOMMON / USING-METHODGEN
------------------------------------------------------------

Index
Source: guides\rhinocommon\using-methodgen\index.md
It builds on top of concepts from the Wrapping Native Libraries guide.

Overview

Wrapping a C/C++ library for .NET consumption is a large task. Usually, there is a C/C++ library with every C exported function, that will link to or be itself the content of the exported functionality (we call this libC, in a directory called libCdir), and a C# library that will provide access to the exported functionality (libCS, in libCSdir).

Besides other more high-level restructuring, wrapping usually involves:
Creating a large amount of C functions to be exported for PInvoke,
The definition of some helper enum values that have the only purpose of helping C - C# communication, and
Copying many public C++ enum values to C#

For each of these tasks, we wrote a tool, methodgen.exe, that automatically writes most of the boilerplate code.

methodgen in your project

To run the tool, place it in a folder that is a parent folder to both your C and your C# solutions. Then, add a prebuild event to your project, either using the standard Visual Studio for Window or Visual Studio for Mac interface, of by adding this code to the .csproj solution:



 $(ProjectDir)..\methodgen.exe libCdir libCSdir



Each path can be relative. Every .h and .cpp file in libCdir will be parsed.

A file called AutoNativeMethods.cs, and another one called AutoNativeEnums.cs if required, will be placed in libCSdir at the end of the process. This will happen in the following 3 steps...
Export C functions to C\#

methodgen.exe looks for every line starting with RHCFUNCTION in every .h and .cpp file in cppdir.

We define the RHCFUNCTION macro directive like this:


#define RHCFUNCTION extern "C" declspec(dllexport)


A typical exported C function will look like this:


RHCFUNCTION int ONBrepSplitEdgeAtParameters(ONBrep pBrep, int edgeindex, int count, /ARRAY/const double parameters)
{
 int rc = 0;
 if (pBrep && count>0 && parameters)
 rc = pBrep->SplitEdgeAtParameters(edgeindex, count, parameters);
 retur... [truncated]

Essential Code:
#define RH_C_FUNCTION extern "C" __declspec(dllexport)

RH_C_FUNCTION int ON_Brep_SplitEdgeAtParameters(ON_Brep* pBrep, int edge_index, int count, /*ARRAY*/const double* parameters)
{
  int rc = 0;
  if (pBrep && count>0 && parameters)
    rc = pBrep->SplitEdgeAtParameters(edge_index, count, parameters);
  return rc;
}


GUIDES / RHINOCOMMON / USING-NUGET
------------------------------------------------------------

Index
Source: guides\rhinocommon\using-nuget\index.md
Why NuGet?

In previous guides you’ve seen how to set up a project to develop a RhinoCommon Plugin or Grasshopper component. These guides relied on the Visual Studio Project Wizards that we publish to quickly get you going on plugin development. The wizards automatically reference the necessary assemblies to make RhinoCommon and Grasshopper SDKs available in your Visual Studio project. While this project setup should be fine for a number of cases, there might be some reasons to switch the RhinoCommon and Grasshopper assembly references to those which are published by McNeel on NuGet...

Advantages

There are several potential advantages to using NuGet packages for RhinoCommon SDKs:

 It's great for projects with multiple developers (or developers with multiple computers). No more references to Grasshopper.dll that include C:\Users\\AppData\....
 NuGet runs on Windows and Mac and is baked into Visual Studio (for Windows).
 Are you using Continuous Integration (CI)? Your build servers can automatically download the correct version of the SDK before compiling and publishing your shiny new release.
 You're probably already using it to install packages like Json.NET.
 You can target a lower version of RhinoCommon than you have installed to ensure full compatibility across all Rhino versions

Potential Pitfalls

NuGet makes it easy to compile plug-ins against versions of Rhino other than those installed on your computer. This is handy for backwards-compatible and/or cross-platform development. However, the fact that your Rhino installation and your RhinoCommon/Grasshopper references are "out of sync" can cause problems.

 NuGet packages will need to be updated separately to Rhino
 You may have trouble debugging your plug-in if it was built against a version of RhinoCommon that is newer than the one included with Rhino[^a]

Getting Started


And how to install... [truncated]

GUIDES / RHINOCOMMON / WHAT-IS-A-ZOO-PLUGIN
------------------------------------------------------------

Index
Source: guides\rhinocommon\what-is-a-zoo-plugin\index.md
The LAN Zoo keeps your licenses on your private LAN server and lets you share them among the Rhino users on your network.

A LAN Zoo plugin is a software module, developed by a 3rd party, that extends the functionality of the LAN Zoo by allowing it to validate product licenses.

!zoo with plugins

When Rhino and Rhino-based products are installed as workgroup nodes, instead of standalone nodes, licensing works like this:
When a workgroup node starts, it requests a license from the LAN Zoo.
An unused license is assigned to the node.
When a node shuts down, the license is returned to the LAN Zoo's license pool.

What is required to build a plugin?

LAN Zoo plugins are .NET Framework 4.8 assemblies. Thus, to create a plugin for the LAN Zoo, you will need one of the following development tools:
Microsoft Visual C#
Microsoft Visual Basic .NET

Also, all plugins that use the LAN Zoo license system must be signed with an Authenticode certificate issued by McNeel Plugin Security. These certificates are free, but must be requested by each developer. Developers must agree to the Terms of Use before a certificate is issued. 

Next Steps

Check out the Creating LAN Zoo Plugins guide for instructions building - your guessed it - a LAN Zoo Plugin.

Related Topics
Creating LAN Zoo Plugins
Digitally Signing Plugins for LAN Zoo

GUIDES / RHINOCOMMON / WHAT-IS-RHINOCOMMON
------------------------------------------------------------

Index
Source: guides\rhinocommon\what-is-rhinocommon\index.md
RhinoCommon is the cross-platform .NET plugin SDK available for:
Rhino for Windows
Rhino for Mac
Rhino.Python Scripting
Grasshopper

The term Common is meant to be just that: an SDK that can be used across Rhino platforms. A plugin built with RhinoCommon could potentially run on both Windows and Mac platforms with no changes.

RhinoCommon is available as NuGet package.

Inside RhinoCommon

RhinoCommon is composed of the following components:

 Assembly Description 

 RhinoCommon.dll RhinoCommon is the core .NET assembly that plugins reference in order to interact with Rhino. 
 Eto.dll Eto is a framework can be used to build user interfaces that run across multiple platforms using their native toolkit, with an easy to use API. This will make your plug-in look and work as a native application on all platforms, using a single UI codebase. 
 Rhino.UI.dll Rhino.UI is a utility .NET assembly that contains Rhino-specific user interface and other miscellaneous classes. 

Types of Plugins

RhinoCommon supports five different types of plugins:

 Type Description 

 General Utility A general purpose ut... [compressed]OK
This will run the code, like the Test button. Then will save the code and close the editor, returning you back to the Grasshopper definition.Ctrl + F5

Import From...
Browse for and import a .py file into the editor. 
Ctrl + I

Export As...
Save the code in the editor to a .py file on the disk.
Ctrl + E

Code Window

This is where all the typing goes on and the grand ideas you have come to life.

This is very similar to the Rhino.Python script editor. Simply type in the statements.

Importing modules

Normally... [truncated]

Essential Code:
import rhinoscriptsyntax as rs
import math #Various math functions including Degree, Radian and Hypot
import statistics #Mean and median are here

import rhino #imports the rhinocommon namespace
import cmath #Mathematical functions for complex numbers
import datetime #Basic date and time types
import string #Common string operations
import random #Generate pseudo-random numbers
import pickle #Python object to string for serialization
import system #System-specific parameters and functions
import os.path #Common pathname manipulations
import csv #CSV File Reading and Writing
import htmllib #A parser for HTML documents
import json #JSON encoder and decoder


GUIDES / RHINOPYTHON / 7 / PRIMER-101 / 1-WHATS-IT-ALL-ABOUT
------------------------------------------------------------

Index
Source: guides\rhinopython\7\primer-101\1-whats-it-all-about\index.md
1.1 Macros

Rhinoceros is based on a command-line interface. This means you can control it by using only the keyboard. You type in the commands and the program will execute them. Ever since the advent of the mouse, a user interface which is purely command-line based is considered to be primitive, and rightly so. Instead of typing:


Line 0,0,0 10,0,0

you can also click on the Line button and then twice in the viewport to define the starting and ending points of a line-curve. Because of this second (graphical) interface some people have done away with the
command-line entirely. Emotions run high on the subject; some users are command-line fanatics, others use only toolbars and menus. Programmers have no emotions in this respect, they are all wedded to the command-line. It’s no use programming the mouse to go to a certain coordinate and then simulate a mouse click, that is just plain silly. Programmers pump text into Rhino and they expect to get text in return.

The lowest form of programming in Rhino is using macros. I do not wish to offend those of you who write macros for a living, but it cannot be denied that it is a very primitive way to automate processes. I shall only briefly pause at the subject of macros, partly so we know which is which and partly because we might at some point simulate macros using RhinoScriptSyntax in Python.

A macro is a prerecorded list of orders for Rhino to execute. The Line command at the top of this page is an example of a very simple macro. If your job is to open Rhino files, add a line from 0,0,0 to 10,0,0 to each one and save the file again, you would probably get very tired very quickly from typing Line w0,0,0 w10,0,0 six times a minute. Enter macros. Macros allow you to automate tasks you would normally do by hand but not by brain. Macros cannot be made smart, nor do they react to the things they help create. They’re a bit like traffic wardens in that respect. An example of a more sophisticated macro would be:


SelNone
Po... [truncated]

GUIDES / RHINOPYTHON / 7 / PRIMER-101 / 3-SCRIPT-ANATOMY
------------------------------------------------------------

Index
Source: guides\rhinopython\7\primer-101\3-script-anatomy\index.md
3.1 Programming in Rhino

Rhinoceros offers various ways of programmatic access. We've already met macros and scripts, but the plot thickens. Please invest a few moments of your life into looking at the diagram below, which you will never be asked to reproduce:

{{}}

The above is a complete breakdown of all developer tools that Rhino has to offer. I'll give you a brief introduction as to what this diagram actually represents and although that is not vital information for our primary goal here ("learning how to script" in case you were wondering), you might as well familiarize yourself with it so you have something to talk about on a first date.

At the very core of Rhino are the code libraries. These are essentially collections of procedures and objects which are used to make life easier for the programs that link to them. The most famous one is the openNURBS library which was developed by Robert McNeel & Associates but is completely open source and has been ported by 3rd party programmers to other operating systems such as Unix and Linux. OpenNURBS provides all the required file writing and reading methods as well the basic geometry library. Practically all the 3D applications that support the 3dm file format use the openNURBS library. These code libraries have no knowledge of Rhino at all, they are 'upstream' so to speak.

Rhino itself (the red blob) is tightly wrapped around these core libraries, it both implements and extends them. Apart from this obvious behavior, Rhino also adds the possibility of plugins. Whereas most companies provide plugin support for 3rd party developers, McNeel has taken a rather exotic approach which eliminates several big problems. The technical term for this approach is "eating your own dogfood" and it essentially boils down to McNeel programmers using the same tools as 3rd party programmers. Rather than adding code to Rhino itself, McNeel programmers prefer writing a plugin instead. For one, if they screw up the collateral damage is... [truncated]

Essential Code:
import rhinoscriptsyntax as rs                        # Import Statement
#Script written by Skylar Tibbits on 03-09-2011        # Default comments

strInfo = "This is just a test"                        # Global Variable

def simpleFunction(text):                # Function Declaration
    print(text)                            # Code to Execute Within the Function
                                        # (Note the Indentation)
simpleFunction(strInfo)                    # Calling the Function (After it's created)


GUIDES / RHINOPYTHON / 7 / PYTHON-EDITING-SCRIPTS
------------------------------------------------------------

Index
Source: guides\rhinopython\7\python-editing-scripts\index.md
Editing Scripts

Any simple plain-text editor, such as Notepad, Atom or Notepad++ can be used to create and/or edit script files. When saving your script file, make sure to give the file the default file extension for Python files, which is .py.

You can also create and edit script file from within Rhino by using the EditPythonScript command. The EditPythonScript command can be accessed from either Rhino's Tools menu, or by entering EditPythonScript on Rhino's command line.

Note, there is no scriptable version of the EditPythonScript command.

The RhinoPythonScript Editor

The RhinoPythonScript Editor can be used to edit, run, and debug scripts. It contains standard source code editing feature, such as find and replace (with regular expressions), multiple-document interface, method browser, and an integrated help file.

The Code Editor

The most important item on the RhinoPythonScript Editor is the code editor. It is here that you make your scripts. As you can see, the editor is much more than a simple text editor. It performs automatic syntax parsing meaning you get properly colored keywords, collapsible code groups which encapsulate def function blocks, automatic indenting, auto-completion and error highlighting.

Auto-completion and parameter tips are grouped under the catch-phrase Intellisense. Since Python is not a strongly typed language. Thus, Intellisense in the RhinoPythonScript Editor is limited to RhinoPythonScriptSyntax methods and script scope procedures.

In the RhinoPythonScript Ediotr, type:


import rhinoscriptsyntax as rs


Any line that follows the auto-completion list pops up as soon as rs.. is typed. The list updates when you keep typing to reflect the best possible match with your current text. Once the desired method is highlighted in the pop up list, press [Enter] and the complete method name will be inserted into the script. Once the method name is in place, we have to supply the arguments. Intellisense displays a tooltip showing ... [truncated]

GUIDES / RHINOPYTHON / 7 / PYTHON-TROUBLESHOOTING-INSTALL
------------------------------------------------------------

Index
Source: guides\rhinopython\7\python-troubleshooting-install\index.md
Over the last few months, we received several reports about issues with independent IronPython installations (IIPI) and Rhino.

Problem:

Python 2.7.7 can decompress assemblies into the GAC (Global Assembly Cache). IIPI are installations of IronPython made via MSI files, and they appear in the Control Panel like this:

{{}}

It is possible to install IronPython via folder decompression, and that has no impact on Rhino.

We installed both IronPython 2.7.5 final and IronPython 2.7.7 final from the IronPython website, and checked for compatibility with running the _EditPythonScript editor, and importing the os module.

Here are the results:

 IronPython 2.7.5 IronPython 2.7.7 

 Rhinoceros 5 SR12 or SR13 OK OK only with no GAC 
 Rhinoceros WIP (31 Jan 2017) OK OK 

This is what the GAC options looks like, during installation:

{{}}

Solution:

If you need version 2.7.7, and need Rhinoceros 5 SR12 and SR13 to run Python on the same system, you have a few options:
Reinstall with disabled GAC installation.
Uninstall and reinstall by decompressing the IronPython folder.
Switch to IronPython version 2.7.5, both with or without GAC.
Alternatively, uninstall IronPython.

GUIDES / RHINOPYTHON / 7 / YOUR-FIRST-PYTHON-SCRIPT-IN-GRASSHOPPER
------------------------------------------------------------

Index
Source: guides\rhinopython\7\your-first-python-script-in-grasshopper\index.md
Introduction

Scripting components works as an integrated part of GH. They can get input and produce output from and to other standard GH components. They can be used to create specialized functionality that opens up tremendous potential beyond the standard components.

But there is a cool twist… the GhPython component supports rhinoscriptsyntax functions. The rhinoscriptsyntax functions can be set to generate geometry inside of Grasshopper that does not live in the Rhino document. We are using a concept called “duck typing” to swap the document that the rhinoscriptsyntax functions target: from the Rhino document to a Grasshopper document. This means that the following script:


import rhinoscriptsyntax as rs
for x in range(10):
 rs.AddPoint((x,0,0)


will add 10 points to the Rhino document when run from Rhino’s “RunPythonScript” or “EditPythonScript” commands. The same script will add 10 points to a Grasshopper document that can be passed on to other components when run inside a GhPython component.

Grasshopper supports multiple .NET scripting languages such as VB and C# to help develop custom code. There is also the Python component. Python supports multiple programming paradigms, often used as a scripting language, but is also used in a wide range of advanced programming contexts. The Rhino.Python website directory is a great place to get more information about Python in Rhino in general.

{{}}

The GhPython component brings:
Rhinoscript syntax to Grasshopper
a Python parallel to the C# and Vb.Net scripting components
a dynamic UI with control over the number of inputs and outputs
ability to reference .NET libraries and a huge number of Python packages
integration with the Python editor included in Rhino

Rhino allows access to its algorithms through the Rhino SDK (software development kit). Rhino is written in C++ but it also provides a couple SDKs for scripting and programming languages. The most basic SDK for Python is RhinoScriptSyntax. For more dir... [truncated]

GUIDES / RHINOPYTHON / 7 / YOUR-FIRST-PYTHON-SCRIPT-IN-RHINO-MAC
------------------------------------------------------------

Index
Source: guides\rhinopython\7\your-first-python-script-in-rhino-mac\index.md
Running a Python script

To get acquainted with how Python scripts can help you model first run some of the sample scripts that are provided.
In the Command prompt edit box (top left by default) type the RunPythonScript command.
If it's the first time you run this command the dialog box that comes up will show the files in the samples directory. If it's not then navigate to it. It should be under:
 
 ~/Library/Application Support/McNeel/Rhinoceros/6.0/Scripts/samples
 
 (the beginning tilde (~) character is normally in the far upper left of the keyboard).
Experiment by running HelloPython.py

Editing a Python Script

You can open any of the sample Python scripts in a text editor. From Finder navigate to the samples directory:


/Users/HOME/Library/Application Support/McNeel/Rhinoceros/6.0/Scripts/samples

(replace HOME with your home directory name).

Or in the Finder, use the Go pulldown > Go To Folder... and type:


~/Library/Application Support/McNeel/Rhinoceros/6.0/Scripts/samples


Right-click on any of the scripts and from the context menu that pops up select Open With -> TextEdit.app which is the text editor that comes with macOS. You can try editing and saving the files and then re-run them in Rhino with the RunPythonScript command.

When you're ready start writing more complex scripts you can install the Atom text editor that's been specifically enhanced for rhino-python package to help with scripts that will be run by Rhino.

After you've followed the above links and setup Atom the next step is to get familiar with the different application programming interfaces (API) you'll need to write scripts that interact with Rhino.

Related Topics
What are Python and RhinoScriptSyntax?
Using the Atom.io editor with Rhino.Python
Python Basic Syntax
Rhinoscript Syntax in Python
Rhino.Python Home Page

GUIDES / RHINOPYTHON / 7 / YOUR-FIRST-PYTHON-SCRIPT-IN-RHINO-WINDOWS
------------------------------------------------------------

Index
Source: guides\rhinopython\7\your-first-python-script-in-rhino-windows\index.md
You will learn how to display a message box in Rhino that says "Hello World." It covers the most basic concepts for editing, loading, and running scripts.

The Complete Script


import rhinoscriptsyntax as rs

rs.MessageBox ("Hello World")

To test the Script:
Start Rhino
At the command prompt, type EditPythonScript and press Enter.
The Edit Script dialog box appears.
In the script Code window, type the code sample above.
Click the "Run the script" button.
The Edit Script dialog box disappears, and the message below appears:

The HelloWorld Function

If you were writing a more complex script, and wanted to display "Hello World" at strategic points throughout the script, you could write this code every time you wanted the message to appear.

But if you changed your mind and wanted it to say "Howdy World" instead, you'd have to search for all the places "Hello World" was used, and replace them.

An easier way to solve this problem is to write a Function (def is used to define the function). At several places throughout your script, you call the function. The function handles displaying the message, so you only have to change the message in one place.

Here's what the function definition looks like:


import rhinoscriptsyntax as rs

def HelloWorld():
 rs.MessageBox ("Hello World")


If you click the run button at this time nothing will happen. Nothing happened? That's because the RhinoScript defined the Subroutine but did not actually call it. To call the subroutine, either add this line of code and click Run.

To call this function, simply add this to the bottom of the script:


HelloWorld()


In Python the functions definitions need to come before being called in the code.

Testing HelloWorld
At the command prompt, type EditScript and press Enter.
The Edit Script dialog box appears.
In the script Code window, type


import rhinoscriptsyntax as rs

def HelloWorld():
 rs.MessageBox ("Hello World")

HelloWorld()

Click the Run button.

... [truncated]

Essential Code:
import rhinoscriptsyntax as rs

def HelloWorld():
    rs.MessageBox ("Hello World")

import rhinoscriptsyntax as rs

def HelloWorld():
    rs.MessageBox ("Hello World")

HelloWorld()


GUIDES / RHINOPYTHON / APIS-FOR-PYTHON
------------------------------------------------------------

Index
Source: guides\rhinopython\apis-for-python\index.md
Overview

Python is an extensible programming language with hundreds of additional modules. This allows Python to be used in many situations both inside Rhino and outside Rhino. There are some specific additional models that are specifically of interest related to Rhino and Grasshopper.

These new modules can be accessed in a Python script by including the import method at the top of each Python script:


import rhinoscriptsyntax as rs
import math


RhinoScriptSyntax

The RhinoScriptSyntax methods library contains hundreds of easy-to-use functions that perform a variety of operations on Rhino. The library allows Python to be aware of the Rhino's:

 Geometry
 Commands
 Document objects
 Application methods

To make these methods easy-to-use, all RhinoScriptSyntax methods return simple Python variables or Python List-based data structures. Thus, once you are familiar with Python, you will be able to use any and all functions in the RhinoScriptSyntax methods library. RhinoScriptSyntax is divided into modules that mirror standard Rhino commands.

A good set of tutorials on using RhinoScript methods can be found in the Python in Rhino tutorials

For those that are familiar with the RhinoScript language in Rhino for Windows. RhinoScriptSyntax is meant to duplicate the functionality provided by the RhinoScript language. If you are familiar with RhinoScript in Rhino for Windows the transition to Python in Rhino should be natural.

RhinoCommon

RhinoCommon is an extensive, low level .NET library of the Rhino SDK. It is meant for more experienced programmers that would like to most extensive access to Rhino and its classes.

An important detail that will become important as you are learning to script Rhino with Python is that the implementation of Python that is embedded in Rhino is called IronPython: a Python implementation in C# that runs on the .Net/mono platform which means that in addition to the Python language features and the rhinoscriptsyntax package, you al... [truncated]

GUIDES / RHINOPYTHON / ETO-CONTROLS-PYTHON
------------------------------------------------------------

Create a group box
Source: guides\rhinopython\eto-controls-python\index.md
Eto is an open source cross-platform dialog box framework available in Rhino 6. This guide demonstrates the syntax required to create the most common Eto controls in Rhino.Python. Eto controls include labels, buttons, edit boxes and sliders. In Eto there are more than 35 different controls that can be created.

For details on creating a complete Eto Dialog in Rhino.Python go to the Getting Started with Eto Guide. The samples in this guide can be added to the controls section of the Basic dialog framework covered in the Getting Started Guide.

Buttons

Buttons are placed on almost every dialog.

{{}}

Creating a new button is simple. Use the forms.Button and specify the Text that is shown on the button face. In addition to creating the new button, an action is commonly attached through the .Click event. Use the += syntax as shown below to bind the action to button.


 self.mbutton = forms.Button(Text = 'OK')
 self.mbutton.Click += self.OnButtonClick


The bound method, listed later in the calss definition is run if the button is clicked.


 # Close button click handler
 def OnOKButtonClick(self, sender, e):
 if self.mtextbox.Text == "":
 self.Close(False)
 else:
 self.Close(True)


In this specific case the button is clicked and the bound method OnOKButtonClick checks the Text of the mtextbox to to determine if anything has been entered. Then the method closes the dialog, returning either True or False.

The Eto.Dialog class has two special reserved names for buttons, the DefaultButton and the AbortButton. The DefaultButton name will create a button that is a standard button and also will receive a click event if the Enter Key is used. The AbortButton is a button that recieves a .Click event if the ESC key is used. These buttons are simple assigned through the name of the control, using self syntax.

The syntax for the DefaultButton is:


self.DefaultButton = forms.Button(Text = 'OK')


And for the AbortButton is:


self.AbortButton = ... [truncated]

Essential Code:
    # Close button click handler
    def OnOKButtonClick(self, sender, e):
        if self.m_textbox.Text == "":
            self.Close(False)
        else:
            self.Close(True)

Create LinkButton
        self.m_linkbutton = forms.LinkButton(Text = 'For more details...')
        self.m_linkbutton.Click += self.OnLinkButtonClick

    # Linkbutton click handler
    def OnLinkButtonClick(self, sender, e):
        webbrowser.open("http://rhino3d.com")


GUIDES / RHINOPYTHON / ETO-FORMS-PYTHON
------------------------------------------------------------

Imports
Source: guides\rhinopython\eto-forms-python\index.md
Overview

Eto is an open source cross-platform user-interface framework available in Rhino 6. Eto can be used in Rhino plug-ins, Grasshopper components, and Python scripts to create dialog boxes and other user-interface features.

Rhino.Python comes with a series of pre-defined user interface dialogs which can be used for the times a simple dialog box is needed. But, if the pre-defined dialogs above do not provide enough functionality, then creating a custom dialog box using Eto may be the right solution.

For example, here is a custom, collapsing dialog that uses many controls:

{{}}

The Eto framework allows creation of the dialog box, the controls, and the actions and events required to make the form functional.

Eto is powerful, full-features user-interface toolkit. Understanding how best to write, organize and use Eto dialogs will take some work.

This guide will cover the basics and best practices of creating Eto dialogs in Rhino.Python. Some of the syntax may seem a little onerous, but in practice the following methods allow Eto code to efficiently be managed in Rhino.Python scripts.

The Eto framework

Conceptually, an Eto dialog can be thought of as a set of layers:

{{}}

Learning how each code each of these layers is key to learning Eto:
Custom Dialog Class - Extending the Eto Dialog/Form class is the best way to create a dialog.
The Dialog Form - The Dialog/Form is the base container.
The Controls - Controls, such as labels, buttons and edit boxes, can be created and then placed in a layout.
The Layout - Within each form, a layout is used to position the controls.
Control delegates - Delegate actions are the methods that are executed when a control is click, edited or changed. Any delegate actions must be bound to specific controls to specify what methods are run at the time of control events.

Thinking about theses dialog parts as layers can help keep the code is organized. As an example of the layered approach of a dialog, here is a simple Eto dialog w... [truncated]

Essential Code:
#! python3

Imports
import Rhino
import scriptcontext
import System
import Rhino.UI
import Eto.Drawing as drawing
import Eto.Forms as forms
 
SampleEtoRoomNumber dialog class
class SampleEtoRoomNumberDialog(forms.Dialog[bool]):
 
    # Dialog box Class initializer
    def __init__(self):
        super().__init__()
        # Initialize dialog box
        self.Title = 'Sample Eto: Room Number'
        self.Padding = drawing.Padding(10)
        self.Resizable = False
...
class SampleEtoViewRoomNumber(forms.Dialog[bool]):


GUIDES / RHINOPYTHON / ETO-LAYOUTS-PYTHON
------------------------------------------------------------

Index
Source: guides\rhinopython\eto-layouts-python\index.md
Eto is an open source cross-platform dialog box framework available in Rhino 6. This guide demonstrates the syntax required to create Layouts. Layouts are containers in which controls are placed. The Layout will position the controls in a dialog or another Layout. It is possible to nest Layouts within each other to handle more complex Layouts.

For details on creating a complete Eto Dialog in Rhino.Python go to the Getting Started with Eto Guide. The samples in this guide can be added to the controls section of the Basic dialog framework covered in the Getting Started Guide.

There are 5 different layout styles in Eto. 
Panel - Controls that subclass Panel, such as Window, GroupBox, Scrollable, etc allow you to specify a single child Content control
TableLayout - Similar to how an HTML table works, with a single control per cell
PixelLayout - Specify X,Y coordinates for the position of each control (from Upper-Left)
DynamicLayout - Dynamic hierarchical horizontal and vertical layout
StackLayout - Horizontal or Vertical list of controls

This guide will focus on using the DynamicLayout style only. The forms.DynamicLayout() has a clear simple syntax in Python and is quite flexible. 

Dynamic Layout

A layout in Eto is a virtual grid in which controls are placed. The layout arranges its child controls in a table structure of rows and columns. It is similar to the HTML table layout. Understanding how rows and columns interact with each other is the key to using layouts effectively. 

AddRow Method

In its simplest form a layout is built row by row using the .AddRow method. Each .AddRow may contain one or more controls. If one control is added for each row a simple stack of rows are created and the controls will stretch to the width of the Layout: 

{{}}


layout = forms.DynamicLayout()
layout.Spacing = drawing.Size(5, 5)

layout.AddRow(label)
layout.AddRow(image)
layout.AddRow(button-capture)
layout.AddRow(button-cancel)


Each successive .AddRow will add a new... [truncated]

GUIDES / RHINOPYTHON / GHPYTHON-BAKE
------------------------------------------------------------

Index
Source: guides\rhinopython\ghpython-bake\index.md
Many times it is useful to create a custom component in Grasshopper to bake both geometry and other properties into Rhino in the same component. This guide will cover the varying calls to create these custom components using GhPython.

There are a few different ways to approach baking. This guide set's up the simplest approach. At the end of this guide is a section on some of the variations possible to fit other bake situations.

For more details any of the concepts in this guide, more details can be found in:
GHPython editor basics guide
RhinoScriptSyntax and Python Guide
RhinoCommon API please refer to the McNeel RhinoCommon Developer site.

Basic GHPython Component

Start with a standard GHPython Component.

{{}}

Download this sample Gh file here....

In this case we use 3 inputs. Change the names of input and output and the Type hint by right clicking on each input:
G: Geometry to bake (Guid)
L: Layer name to bake to (str).
B: Activate toggle to bake (bool)

To test this component. the Box Param is the easiest geometry type to use for testing. Add a Layer name using a panel as input. Use a Button or a Switch to toggle True and False.

The Python code

Here is the code for this component. In this case, the geometry is baked to Rhino on the default layer, then through Python we switch the layer to the one input. 

{{}}

"""Provides a scripting component.
 Inputs:
 G: Geometry to bake
 L: Layer name for bake
 B: Bake Activate
 Output:
 a: The a output variable"""

author = "ScottD"
version = "2019.08.10"

import rhinoscriptsyntax as rs
import scriptcontext
import Rhino

if B:

 print(type(G)) #debug message to Python output

 #we obtain the reference in the Rhino doc
 docobject = scriptcontext.doc.Objects.Find(G)
 print(type(docobject))

 attributes = docobject.Attributes
 print('the type of attributes is: ' + str(type(attributes))) #debug message to Python output

 geometry = docobject.Geometry
 print('the type of geometry is: ' + str(type(docobject))) #d... [truncated]

GUIDES / RHINOPYTHON / GHPYTHON-CALL-COMPONENTS
------------------------------------------------------------

Index
Source: guides\rhinopython\ghpython-call-components\index.md
Node-in-Code™: almost every Grasshopper component is now callable as a function in other places in Rhino. Grasshopper components may be called in GhPython (on the Gh canvas) and from rhino.Python (off the canvas). This adds few thousand new functions accessible to GhPython. Functions are also available through 3rd party components. Along with the new functionality that this provides, the technique can be used to simplify existing gh definition files by simply lumping together a bunch of related components into a single 'scottdavidson' script.

There is a module in ghpythonlib.components which attempts to make every component available in Python in the form of an easy to call function.

Components As functions from GhPython

In this example we can make a new ghPhython component that combines the standard Grasshopper Voronoi component and the Grasshopper Area components. Within one GhPython component the voronoi curves are created and the cell centroid points are output.

{{}}

Use a GhPython component with these inputs:

{{}}
Node in Code sample file

Before entering code in the GhPython component it to review the input properties to make sure the correct Type hint is used. In this case the points input has a Point3D hint and a List Access level set. Do this by right clicking on the GhPython component input.

Enter this code into the GhPython component:


import ghpythonlib.components as ghcomp
curves = ghcomp.Voronoi(points) # call the Grasshopper Voronoi component
centroids = ghcomp.Area(curves).centroid # call Grasshopper Area component with curves from Voronoi


Of course you can mix in other Python to perform calculations on the results of the component function calls. I tweaked the above example to find the curve generated from Voronoi that has the largest area.


import ghpythonlib.components as ghcomp

curves = ghcomp.Voronoi(points)
areas = ghcomp.Area(curves).area
#find the biggest curve in the set
maxarea = -1
maxcurve = None
for i, curve i... [truncated]

GUIDES / RHINOPYTHON / GHPYTHON-GLOBAL-STICKY
------------------------------------------------------------

Index
Source: guides\rhinopython\ghpython-global-sticky\index.md
Sometimes there is a need to share information between Grasshopper and Rhino.Python. This can be done through a global sticky variable creating a definition wide global sticky variable. Both Rhino.Python and gh.python use the same Python instance, so the Python sticky is shared between the two.

With a global sticky variable all the components in a definition can access the information.

As an example, here is a definition that creates a simple sticky variable and passes it to another component that is not connected:

{{}}


import scriptcontext as rs

rs.sticky["someName"] = x #"x" is the input for the component



The scriptcontext.sticky creates a global variable names "someName". This can be referenced in another component using this code:


import scriptcontext as rs

a = rs.sticky["someName"] #output the value of the sticky



Within Rhino.Python, the same value can be accessed the same way through Rhino.Python sticky.

Related Topics
Your first script with Python in Grasshopper
What is Python and RhinoScript?
Editing Python in Grasshopper
Python Guide for Rhino

GUIDES / RHINOPYTHON / GHPYTHON-QUESTION-ANSWER
------------------------------------------------------------

Index
Source: guides\rhinopython\ghpython-question-answer\index.md
The GhPython component allows to use both RhinoCommon and RhinoScript from within Grasshopper. Here some Q&As.

How can I use the rhinoscriptsyntax?

By importing RhinoScript, for example by writing:

import rhinoscriptsyntax as rs

...and then calling some rhinoscript functions...


import rhinoscriptsyntax as rs

line = rs.AddLine((1, 2, 3), (10, 11, 12))
a = line


How can I use RhinoCommon?

By importing from the Rhino module, for example by writing:

from Rhino.Geometry import Point3d, Line

...and then assigning some new geometry to the results


from Rhino.Geometry import Point3d, Line

a = Line(Point3d(1, 2, 3), Point3d(10, 11, 12))


What is "ghdoc" and how does it relate to the rhinoscriptsyntax?

The ghdoc variable is provided by the component for better RhinoScript library support.

This library is imperative, and it is build from a set of functions that act on geometrical types through one level of indirection: most of the time, the user does not work with the geometry itself but with an identifier (Guid) of geometry that is present in a document.

This is exactly what ghdoc is: it is a reference to the document that the RhinoScript library implicitly targets with all Add__() calls (for example, AddLine()).

The scriptcontext module has a doc variable with the currently active document, that can be assigned by you to ghdoc, or RhinoDoc.ActiveDoc, the Rhino document.

Is RhinoScript use within GhPython less ideal than RhinoCommon?

While targeting the ghdoc variable, the special Grasshopper document is used, therefore we can use Grasshopper while leaving the Rhino document unchanged. This saves uncountable Undo's, and makes it easy to structure ideas through the Grasshopper definition.

This means that both RhinoCommon or RhinoScript are good in practice.

Is the rhinoscriptsyntax target irrelevant if using solely RhinoCommon classes?

Yes. If you create class instances (objects), you will need to create also your own collection objects ... [truncated]

GUIDES / RHINOPYTHON / GRASSHOPPER-DATATREES-AND-PYTHON
------------------------------------------------------------

Index
Source: guides\rhinopython\grasshopper-datatrees-and-python\index.md
Data trees, technically

The data tree data structure is a complex data structure that is best kept in Grasshopper realms. It is a .Net class that is part of the Grasshopper SDK and, as such, all its members can be found on the DataTree class Grasshopper SDK documentation site.

On the implementation side, in Python it can be thought as an object with behavior similar to a dict - really, System.Collections.Generic.SortedList.aspx) - of GHPaths, or Grasshopper.Kernel.Data.GHPath. For each one of the paths-keys inside, there is an associated .Net list.aspx)-value, that is a branch. Items are stored in each list. There is no null-path, but paths can be sparse. Items cannot be sparse, but there can be null-items.

Other data structures would also be able to accommodate similar data. In Python, a similar object with better language support would be a list of lists.


nestedlist = [[0, 1], [2, 3]]

However, a list of lists cannot always represent the merging of two datatrees with different dimensional depth in data (example: a datatree with an item at {0;1}[0] and an item at {0}[1]). If the data tree is constructed by normal and integral Grasshopper logic, it will have constant dimensional depth, and therefore this problem can be avoided. Alternatively, the data tree with inferior dimension can be 'grafted' to a branch of an upper dimension, and also this way the problem is avoided.

Coding against the DataTree class

This example shows how to iterate through any data tree and explain the content of it.


a = []

for i in range(x.BranchCount):
 branchList = x.Branch(i)
 branchPath = x.Path(i)

 for j in range(branchList.Count):
 s = str(branchPath) + "[" + str(j) + "] "
 s += type(branchList[j]).name + ": "
 s += str(branchList[j])

 a.append(s)


On the opposite side, this example shows how to create a data tree from scratch:


import ghpythonlib.treehelpers as th
import Rhino

layerTree = [list() for in layernames]

for i in range(len(layernames)... [truncated]

GUIDES / RHINOPYTHON / HACKING-ATOM
------------------------------------------------------------

Notes on the Rhino Python Search Paths toolbar:
Source: guides\rhinopython\hacking-atom\index.md
Specifically, running from the "settings" branch of the source to test the search paths configuration.

I updated the rhino-python Atom package to support configuring the Python search path which I plan to deploy when we release MR5.1. The document describes how to install and run it from source so some of you can test and give feedback. 
open a terminal window pointing to the directory where you want to clone the rhino-python package and type:
 
 git clone https://github.com/mcneel/rhino-python.git
 
 
 cd rhino-python
 
switch to the branch that implements the search paths configuration.
 
 git checkout settings
 
create a link so that the package will be loaded from the git repo when Atom is run in dev mode:
 
 apm link -d
 
install the package dependencies
 
 apm install
 
to launch Atom in dev mode cd to where your python files are and type:
 
 atom -d .
 
You are now running the rhino-python package from source. You are specifically running from the "settings" git branch where the python search paths configuration is implemented.
Rename Rhinoceros.app to something else to back it up then rename RhinoWIP.app to Rhinoceros.app (this is a temporary step that won't be required in he future).
Launch the RhinoWIP (renamed) and type the command: StartAtomEditorListener. Getting and setting the Python search path values is done by Rhino so it has to be running and listening for Atom requests. 
Switch back to Atom and press the ctrl + alt + s keys to open the "Rhino Python Search Paths" window.

Notes on the Rhino Python Search Paths toolbar:
when the window is 1st opened only the add ( + ) button is enabled.
click on a path to select it and the other nav buttons become enabled.
None of the changes made in the UI are saved until the save button is clicked which sends the save request to Rhino.
Clicking the revert button discards all changes made since the last save by sending a request to Rhino for the last saved search paths.

Please send all feedback to... [truncated]

GUIDES / RHINOPYTHON / PRIMER-101 / 1-WHATS-IT-ALL-ABOUT
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\1-whats-it-all-about\index.md
1.1 Macros

Rhinoceros is based on a command-line interface. This means you can control it by using only the keyboard. You type in the commands and the program will execute them. Ever since the advent of the mouse, a user interface which is purely command-line based is considered to be primitive, and rightly so. Instead of typing:


Line 0,0,0 10,0,0

you can also click on the Line button and then twice in the viewport to define the starting and ending points of a line-curve. Because of this second (graphical) interface some people have done away with the
command-line entirely. Emotions run high on the subject; some users are command-line fanatics, others use only toolbars and menus. Programmers have no emotions in this respect, they are all wedded to the command-line. It’s no use programming the mouse to go to a certain coordinate and then simulate a mouse click, that is just plain silly. Programmers pump text into Rhino and they expect to get text in return.

The lowest form of programming in Rhino is using macros. I do not wish to offend those of you who write macros for a living, but it cannot be denied that it is a very primitive way to automate processes. I shall only briefly pause at the subject of macros, partly so we know which is which and partly because we might at some point simulate macros using RhinoScriptSyntax in Python.

A macro is a prerecorded list of orders for Rhino to execute. The Line command at the top of this page is an example of a very simple macro. If your job is to open Rhino files, add a line from 0,0,0 to 10,0,0 to each one and save the file again, you would probably get very tired very quickly from typing Line w0,0,0 w10,0,0 six times a minute. Enter macros. Macros allow you to automate tasks you would normally do by hand but not by brain. Macros cannot be made smart, nor do they react to the things they help create. They’re a bit like traffic wardens in that respect. An example of a more sophisticated macro would be:


SelNone
Po... [truncated]

GUIDES / RHINOPYTHON / PRIMER-101 / 2-PYTHON-ESSENTIALS
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\2-python-essentials\index.md
2.1 Language Origin

Like conversational languages, programming languages group together in clusters. Python is a high level language, indicating that the language was designed to be easy for humans to understand. On the opposite end of the spectrum are extremely low level languages, (often referred to as machine-code), that are most definitely not easy to understand. In between are languages such as C or C++ which offer layers of abstraction above machine-code. As I mentioned, Python is a step even higher, meaning that it is far easier to read (closer to the English language) and we don't need to manage difficult functionality like memory allocation, or declaring variables!

Lucky us.

Python was first released in 1991, since then it has grown to become freely available with a user-group exceeding tens of thousands. The Python documentation claims, " Python plays well with others," " Python runs everywhere," " Python is friendly... and easy to learn" and " Python is Open!" python.org.

Assuming that you might be reading these pages without any prior programming experience whatsoever, I still dare guess that the following example will not give you much trouble:


import rhinoscriptsyntax as rs

somenumber = rs.GetReal("Line length")
line = rs.AddLine( (0,0,0), (somenumber,0,0) )
if line is None:
 print("Something went wrong")
else:
 print("Line curve inserted with id", line)

Of course you might have no conception of what [0,0,0] actually means and you might be confused by rs.GetReal() but on the whole it is pretty much the same as the English you use at the grocers:


Ask Rhino to assign a number to something called 'somenumber'.
Tell Rhino to add a line from the world origin to the point on the x-axis indicated by 'somenumber'
print a success message


Translating Python code to and from regular English should not be very difficult, at least not at this feathe... [truncated]

Essential Code:
x, y, z = [1,2,3]
print(x) # returns 1
print(y)  # returns 2
print(z)  # returns 3


GUIDES / RHINOPYTHON / PRIMER-101 / 3-SCRIPT-ANATOMY
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\3-script-anatomy\index.md
3.1 Programming in Rhino

Rhinoceros offers various ways of programmatic access. We've already met macros and scripts, but the plot thickens. Please invest a few moments of your life into looking at the diagram below, which you will never be asked to reproduce:

{{}}

The above is a complete breakdown of all developer tools that Rhino has to offer. I'll give you a brief introduction as to what this diagram actually represents and although that is not vital information for our primary goal here ("learning how to script" in case you were wondering), you might as well familiarize yourself with it so you have something to talk about on a first date.

At the very core of Rhino are the code libraries. These are essentially collections of procedures and objects which are used to make life easier for the programs that link to them. The most famous one is the openNURBS library which was developed by Robert McNeel & Associates but is completely open source and has been ported by 3rd party programmers to other operating systems such as Unix and Linux. OpenNURBS provides all the required file writing and reading methods as well the basic geometry library. Practically all the 3D applications that support the 3dm file format use the openNURBS library. These code libraries have no knowledge of Rhino at all, they are 'upstream' so to speak.

Rhino itself (the red blob) is tightly wrapped around these core libraries, it both implements and extends them. Apart from this obvious behavior, Rhino also adds the possibility of plugins. Whereas most companies provide plugin support for 3rd party developers, McNeel has taken a rather exotic approach which eliminates several big problems. The technical term for this approach is "eating your own dogfood" and it essentially boils down to McNeel programmers using the same tools as 3rd party programmers. Rather than adding code to Rhino itself, McNeel programmers prefer writing a plugin instead. For one, if they screw up the collateral damage is... [truncated]

Essential Code:
#! python3                                 # Language Type

import rhinoscriptsyntax as rs             # Import Statements
import scriptcontext as sc
import math

import System
import System.Collections.Generic
import Rhino
import rhinoscriptsyntax as rs                        
#Script written by Ehsan Iran-Nijad        # Default comments

strInfo = "This is just a test"            # Global Variable

def simpleFunction(text):                  # Function Declaration
    print(text)                            # Code to Execute Within the Function
                                               # (Note the Indentation)
simpleFunction(strInfo)                    # Calling the Function (After it's created)


GUIDES / RHINOPYTHON / PRIMER-101 / 4-OPERATORS-AND-FUNCTIONS
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\4-operators-and-functions\index.md
4.1 What on Earth are they and why should I care?

When we were discussing numeric variables in paragraph 2.3.1, there was an example about mathematical operations on numbers:

{{}}


x = 15 + 26 2.33
x = math.sin(15 + 26) + math.sqrt(2.33)
x = math.tan(15 + 26) / math.log(55)


The four lines of code above contain four kinds of code:
Numbers 15, 26, 2.33 and 55
Variables x
Operators =, +, and /
Functions math.sin(), math.sqrt(), math.tan() and math.log()

Numbers and variables are well behind us now. Arithmetic operators should be familiar from everyday life, Python uses them in the same way as you used to during math classes. Python comes with a limited amount of arithmetic operators and they are always positioned between two variables or constants (a constant is a fixed number). The function first signifies that we have imported math at the top of our code, using "import math", and then call a function that is within the math module called "sin()". Thus we write: math.sin(value).

{{}}

4.2 Careful...

One thing to watch out for is operator precedence. As you will remember from math classes, the addition and the multiplication operator have a different precedence. If you see an equation like this:


x = 4 + 5 2

x = (4 + 5) 2 # wrong precedence
x = 4 + (5 2) # correct precedence


x doesn't equal 18, even though many cheap calculators seem to disagree. The precedence of the multiplication is higher which means you first have to multiply 5 by 2, and then add the result to 4. Thus, x equals 14. Python is not a cheap calculator and it has no problems whatsoever with operator precedence. It is us, human beings, who are the confused ones. The example above is fairly straightforward, but how would you code the following?

{{}}$$y =\frac{\sqrt{x^2+(x+1)}}{x-3} + \left {\frac{2x}{x^{0.5x}}}\right $${{}}

Without extensive use of parenthesis, this would be very nasty indeed. By using parenthesis in equations we can force precedence, and we can easily grou... [truncated]

Essential Code:
Returns:
String        » The identifier of the picked object if successful.
None        » If not successful, or on error.

def Alphabet():
    strSeries = "abcdefghijklmnopqrstuvwxyz"


GUIDES / RHINOPYTHON / PRIMER-101 / 5-CONDITIONAL-EXECUTION
------------------------------------------------------------

Iteratively scale down a curve until it becomes shorter than a certain length
Source: guides\rhinopython\primer-101\5-conditional-execution\index.md
5.1 What if?

What if I were to fling this rock at that bear? What if I were to alleviate that moose from its skin and wear it myself instead? It's questions like these that signify abstract thought, perhaps the most stunning of all human traits. As a programmer, you need to take abstract thought to the next level; the very-very-conscious level.

A major part of programming is recovering from screw-ups. A piece of code does not always behave in a straightforward manner and we need to catch these aberrations before they propagate too far. Other times we design our code to deal with more than one situation. In any case, there's always a lot of conditional evaluation going on, a lot of 'what if' questions. Let's take a look at three conditionals of varying complexity:
If the object is a curve, delete it.
If the object is a short curve, delete it.
If the object is a short curve, delete it, otherwise move it to the "curves" layer.

The first conditional statement evaluates a single boolean value; an object is either is a curve or it is not. There's no middle ground. The second conditional must also evaluate the constraint 'short'. Curves don't become short all of a sudden any more than people grow tall all of a sudden. We need to come up with a boolean way of talking about 'short' before we can evaluate it. The third conditional is identical to the second one, except it defines more behavioral patterns depending on the outcome of the evaluation.

The translation from English into Python is not very difficult. We just need to learn how conditional syntax works.

Problem 1:

{{}}


if (rs.IsCurve(strObjectID)):
 rs.DeleteObject(strObjectID)


Problem 2:


if (rs.IsCurve(strObjectID)):
 if (rs.CurveLength(strObjectID) }}

{{}}

import rhinoscriptsyntax as rs
import datetime as dt

def viewportclock():
 now = dt.datetime.now()
 textobjectid = rs.AddText(str(now), (0,0,0), 20)
 if textobjectid is None: return
 rs.ZoomExtents(None, True)
 while True:
 rs... [truncated]

Essential Code:
import rhinoscriptsyntax as rs
import datetime as dt

def viewportclock():
    now = dt.datetime.now()
    textobject_id = rs.AddText(str(now), (0,0,0), 20)
    if textobject_id is None: return
    rs.ZoomExtents(None, True)
    while True:
        rs.Sleep(1000)
        now = dt.datetime.now()
        rs.TextObjectText(textobject_id, str(now))

if __name__=="__main__":
    viewportclock()


Iteratively scale down a curve until it becomes shorter than a certain length
import rhinoscriptsyntax as rs


def fitcurvetolength():
    curve_id = rs.GetObject("Select a curve to fit to length", 4, True, True)
    if curve_id is None: return
    
    length = rs.CurveLength(curve_id)

    length_limit = rs.GetReal("Length limit", 0.5 * length, 0.01 * length, length)
    if length_limit is None: return

    while True:
        if rs.CurveLength(curve_id)<=length_limit: break
        curve_id = rs.ScaleObject(curve_id, (0,0,0), (0.95, 0.95, 0.95))
        if curve_id is None:
            print("Something went wrong...")
            return

...

GUIDES / RHINOPYTHON / PRIMER-101 / 6-TUPLES-LISTS-DICTIONARIES
------------------------------------------------------------

This returns 12345 - the first value inside the Tuple
Source: guides\rhinopython\primer-101\6-tuples-lists-dictionaries\index.md
6.1 Tuples

We've already been using tuples and lists in examples and I've always told you not to worry about it. Those days are officially over. Now is the time to panic. Perhaps it's best if we just get the obvious stuff out of the way first:

Tuples, Lists and Dictionaries are just a collection of things!

That's really all there is to it. Sometimes -in fact quite often- you want to store a large or unknown amount of things. You could of course declare 15,000 different variables by hand but that is generally considered to be bad practice. Remember, Tuples, Lists and Dictionaries always start counting at zero, while us humans are normally used to start counting at one. Try it by counting the number of fingers on your right hand. Chances are you are someone who has just counted to five. Code would disagree with you, it would only have counted to four:

{{}}

It helps to refer to numbers as 'indices' when you use the zero-based counting system just to avoid confusion. So when we talk about the 'first element' of a tuple we actually mean 'the element with index 0'. I know this all sounds strange, but zero-based counting systems habitually confuse even the most die-hard programmer.

A tuple consists of a number of values separated by commas, for instance:


t = 12345, 5421, 'hello!' # Creating a Tuple with a variable name t
print(t[0]) # print the first value of the Tuple t
This returns 12345 - the first value inside the Tuple
print(t)
This returns (12345, 54321, 'hello!') - all of the values within the Tuple


Tuples can be used for coordinates (x,y) or any other time you need to store various elements. Tuples may contain multiple variables, nested Tuples, Lists or other objects. If you remember from section 4.5, Tuples are immutable, meaning that they cannot be changed! (Refer to section 4.5 on Mutability) That means that we cannot create a Tuple then remove an element, instead we need to create an entirely new Tuple that contains the desired change. A numb... [truncated]

Essential Code:
t = 12345, 5421, 'hello!' # Creating a Tuple with a variable name t
print(t[0]) # print the first value of the Tuple t
This returns 12345 - the first value inside the Tuple
print(t)
This returns (12345, 54321, 'hello!') - all of the values within the Tuple

myList = [] #This creates an empty list with the variable name myList
myList.append(5)
myList.append(6)
print myList[0]
This returns 5 - the first element (0th item) in the list
print(myList)
This returns [5,6] - the entire contents of the list myList


GUIDES / RHINOPYTHON / PRIMER-101 / 7-CLASSES
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\7-classes\index.md
7.1 Class Syntax

Classes are useful mechanism for organization above what we have already mentioned: variables, flow control and functions. Classes give us another level of functionality and actually define a specific type of programming called Object-Oriented Programming. This means that we can create objects, rather than simply procedures or variables. Object-Oriented Programming gives us the ability to create a class with internal attributes, functions and any number of other characteristics and then create multiple instances. Classes offer you a possibility to organize your code based on objects, these objects can relate to one another with inheritance, add or remove information/characteristics through functions and actually exhibit "polymorphism"! (Sounds fancy!)

Polymorphism, another exciting feature of Object-Orient Programming, is the ability to create one object or class that can exhibit multiple characteristics and commonly respond to similar functions. For example, if we have a function that asks for a "Person's" age and returns their birth year, we could pass in a "Professor" or we could pass in a "Person" although they are actually different objects they can respond to the same question (this is like acting as different people at different times, depending on the question)! 

Classes can be used describe geometry - i.e. a surface is an object that has multiple characteristics, curvature, centroid, number of U & V points etc. We can also ask for information about a surface based on functions embedded within the class; like returning the surface area or the bounding box etc! We can also create our own types of objects like "Connections" or "Apertures" etc - with functionality and specific attributes, while each one being slightly unique! Classes are very powerful, but at first glance are often difficult to wrap your head around!!

Ok, enough talking - lets see some code (because that's much easier to understand...)! To create a class the syntax is:

{{}... [truncated]

Essential Code:
class MyClass:
    """A simple example"""
    x = 10
    def test(self):
        return 'hello'

obj = MyClass()
print(obj.x)
print(obj.test())

class Harder:
    def __init__(self,m,n):
        self.i = m
        self.j = n
newObj = Harder(10,20)
print(newObj.i)
print(newObj.j)


GUIDES / RHINOPYTHON / PRIMER-101 / 8-GEOMETRY
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\8-geometry\index.md
8.1 The openNURBS™ Kernel

Now that you are familiar with the basics of scripting, it is time to start with the actual geometry part of Rhino. To keep things interesting we've used plenty of Rhino methods in examples before now, but that was all peanuts. Now you will embark upon that great journey which, if you survive, will turn you into a real 3D geek.

As already mentioned in Chapter 3, Rhinoceros is built upon the openNURBS™ kernel which supplies the bulk of the geometry and file I/O functions. All plugins that deal with geometry tap into this rich resource and the RhinoScriptSytnax plugin is no exception. Although Rhino is marketed as a "NURBS modeler", it does have a basic understanding of other types of geometry as well. Some of these are available to the general Rhino user, others are only available to programmers. When writting in Python you will not be dealing directly with any
openNURBS™ code since RhinoScriptSyntax wraps it all up into an easy-to-swallow package. However, programmers need to have a much higher level of comprehension than users which is why we'll dig fairly deep.

8.2 Objects in Rhino

All objects in Rhino are composed of a geometry part and an attribute part. There are quite a few different geometry types but the attributes always follow the same format. The attributes store information such as object name, color, layer, isocurve density, linetype and so on. Not all attributes make sense for all geometry types, points for example do not use linetypes or materials but they are capable of storing this information nevertheless. Most attributes and properties are fairly straightforward and can be read and assigned to objects at will.

{{}}

This table lists most of the attributes and properties which are available to plugin developers. Most of these have been wrapped in the RhinoScriptSyntax module, others are missing at this point in time and the custom user data element is special. We'll get to user data after we're done with the basic geo... [truncated]

Essential Code:
import rhinoscriptsyntax as rs

def displayobjectattributes(object_id):
    source = "By Layer", "By Object", "By Parent"
    data = []
    data.append( "Object attributes for :"+str(object_id) )
    data.append( "Description: " + rs.ObjectDescription(object_id))
    data.append( "Layer: " + rs.ObjectLayer(object_id))
    #data.append( "LineType: " + rs.ObjectLineType(object_id))
    #data.append( "LineTypeSource: " + rs.ObjectLineTypeSource(object_id))
    data.append( "MaterialSource: " + str(rs.ObjectMaterialSource(object_id)))

    name = rs.ObjectName(object_id)
    if not name: data.append("<Unnamed object>")
    else: data.append("Name: " + name)

    groups = rs.ObjectGroups(object_id)
    if groups:
        for i,group in enumerate(groups):
            data.append( "Group(%d): %s" % i+1, group )
...
import rhinoscriptsyntax as rs

def main():
    curve_id = rs.GetObject("Select a curve to sample", 4, True, True)
    if not curve_id: return

    rs.EnableRedraw(False)
    t = 0
    while t<=1.0:
        addpointat_r1_parameter(curve_id,t)
        t+=0.002
    rs.EnableRedraw(True)

def addpointat_r1_parameter(curve_id, parameter):
    domain = rs.CurveDomain(curve_id)


    r1_param = domain[0] + parameter*(domain[1]-domain[0])
    r3point = rs.EvaluateCurve(curve_id, r1_param)
    if r3point:
...

GUIDES / RHINOPYTHON / PRIMER-101 / WHERE-TO-FIND-HELP
------------------------------------------------------------

Index
Source: guides\rhinopython\primer-101\where-to-find-help\index.md
Forums:

The RhinoPython community in Discourse is very active and offers a wonderful resource for posting questions/answers and finding help on just about anything!:
https://discourse.mcneel.com/c/scripting

General References for Python:

Python's main website offers a plethora of information about the syntax, building-in functionality, libraries etc! This is the main resource for anything Python!
http://docs.python.org/

The Python Documentation also has a great introduction into the basics of Python:
http://docs.python.org/tutorial/introduction.html
http://docs.python.org/tutorial/

A very useful Python style guide:
http://www.python.org/dev/peps/pep-0008/

Another very thorough resource for Python is from MIT, called "How to Think Like a Computer Scientist":
http://www.greenteapress.com/thinkpython/thinkCSpy/thinkCSpy.pdf

Common Exceptions/Errors:

For a list of common errors, exceptions and pitfalls that you are likely to run into when coding see:
http://docs.python.org/release/3.1.3/library/exceptions.html#bltin-exceptions
http://secant.cs.purdue.edu/_media/proghints.pdf

Syntax & Programming Reminders:
Python is Case Sensitive ("A" and "a" are NOT the same thing!)
Python is Indent Sensitive (Use indentation to delineate the scope of loops, conditionals, functions and classes)
 Remember an extra space or the absence of a space can make a world of a difference!
You do NOT need to declare variables or variables types! Just simply use them (x=3)!
The " # " sign is used for comments, the computer will skip over them.
Print and Return are NOT the same thing - print writes something to the screen, return actually passes a value!
Remember Variable Scope - where you define a variable is important! Variables defined within functions & classes can only be used within those functions/classes unless passed as input or through the return statement!
Develop code incrementally, testing, debugging and printing as you finish smaller sections. Writing hundreds of lines and hi... [truncated]

GUIDES / RHINOPYTHON / PYTHON-CANCELING-SCRIPTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-canceling-scripts\index.md
In Rhino 6, when a script is running and it is not waiting for user input, it can be cancelled by pressing the ESC. In Rhino.Python this is done by adding a scriptcontext.escapetest test.

The following script is not be cancelled by pressing the ESC key.


def TightLoopEscapeTest():
 for i in range(10000):

TightLoopEscapeTest()

By scriptcontext.escapetest function the loop can now be canceled:


import scriptcontext

def TimeConsumingTask(): 
 for i in range(10000):
 # Was escape key pressed?
 if (scriptcontext.escapetest(False)):
 print "TimeConsumingTask cancelled."
 break
 print i

TimeConsumingTask()


It might be necessary to press the ESC key a couple times to catch the scriptcontext.escapetest test in the correct state.

Related Topics
What is Python and RhinoScript?
Your First Python Script in Rhino (Windows)
Running Scripts
Canceling Scripts
Editing Scripts
Scripting Options

Essential Code:
def TightLoopEscapeTest():
  for i in range(10000):

TightLoopEscapeTest()

import scriptcontext

def TimeConsumingTask():    
    for i in range(10000):
        # Was escape key pressed?
        if (scriptcontext.escape_test(False)):
            print "TimeConsumingTask cancelled."
            break
        print i

TimeConsumingTask()


GUIDES / RHINOPYTHON / PYTHON-CODE-CONVENTIONS
------------------------------------------------------------

My first comment
Source: guides\rhinopython\python-code-conventions\index.md
Overview

Coding conventions are suggestions designed to help you write Python and RhinoScript code. Coding conventions can include the following:
Naming conventions for objects, variables, and procedures
Commenting conventions
Code Block syntax
Whitespace (spaces vs tabs)

The reason for using coding conventions is to standardize the structure and style of a script or set of scripts so that you and others can easily read and understand the code. Using coding conventions results in clear, precise, and readable code that is consistent with other language conventions and is intuitive.

For the official documentation on Python Syntax, see the Style Guide for Python Code

Names and Capitalization

In Python names are used as identifiers of functions, classes, variables, etc.... Identifiers must start with a Letter (A-Z) or an underscore ("_"), followed by more letters or numbers.

Python does not allow characters such as @, $, and % within identifier names.

Python is case sensitive. So "selection" and "Selection" are two different identifiers. Normally class names will begin with capital letters and other identifiers will be all lower case. It is also common practice to start private identifiers with an underscore.

The body of a variable or procedure name should use mixed case and be as descriptive as necessary. Also, procedure names should begin with a verb, such as InitNameArray or ValidateLayer.

For frequently used or long terms, standard abbreviations are recommended to help keep name length reasonable. In general, variable names greater than 32 characters can be difficult to read. When using abbreviations, make sure they are consistent throughout the entire script. For example, randomly switching between Cnt and Count within a script may lead to confusion.

Best practices for Python naming can be found in the Style Guide for Python Naming Conventions.

Comments in Python

Comments in Pythons are used to leave notes in the code to better explain what is happening... [truncated]

Essential Code:
#****************************************************
Purpose: Locates the first occurrence of a specified
layer in the LayerList array.
Inputs:  arrLayerList: the list of layers to be searched.
strTargetLayer: the name of the layer to search for.
Returns: The index of the first occurrence of the
strTargetLayer in the strLayerList array.
If the target layer is not found, return -1.
#****************************************************
import rhinoscriptsyntax as rs

def FindLayer(LayerList, TargetLayer):

  FindLayer = -1 # Default return value
  i = 0          # Initialize loop counter
  blnFound = False
  while i < len(LayerList) and not blnFound:
    if LayerList[i] == TargetLayer:
      blnFound = True # Set flag to True
      FindLayer = i   # Set return value to loop count
...

GUIDES / RHINOPYTHON / PYTHON-CONDITIONALS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-conditionals\index.md
Overview

You can control the flow of your script with conditional statements and looping statements. Using conditional statements, you can write Python code that makes decisions and repeats actions. The following conditional statements are available in Python:

 if statement
 if...else statement
if...elif...elif...else nested statement

The if... statement is used to evaluate whether a condition is True or False and, depending on the result, to specify one or more statements to run. Usually the condition is an expression that uses a comparison operator to compare one value or variable with another. For information about comparison operators, see the Python Operators guide. if... and if...elif statements can be nested to as many levels as you need.

Python programming language assumes any non-zero and non-null values as TRUE, and if it is either zero or null, then it is assumed as FALSE value.

if

To run only one statement when a condition is True, use the single-line syntax for the if... statement. The following example shows the single-line syntax.


var1 = 350
if var1 == 350 : print ("The value of the variable is 350")


To run more than one line of code, you must use the multiple-line (or block) syntax. The first line ends in a colon (:). As with all Python block syntax, the whitespaces to the left of the lines must be the same throughout the block. As an example:


var1 = 350
if var1 == 350 :
 print ("The value of the variable is 350")
 var2 = 450
 print ("The value of variable 2 is 450")


if..else

You can use an if...else statement to define two blocks of executable statements: one block to run if the condition is True, the other block to run if the condition is False...


var1 = 350
if var1 == 0 :
 MyLayerColor = 'vbRed'
 MyObjectColor = 'vbBlue'
else :
 MyLayerColor = 'vbGreen'
 MyObjectColor = 'vbBlack'
print (MyLayerColor)


if..elif..elif..else

A variation on the if...else statement allows you to choose from several alternativ... [truncated]

GUIDES / RHINOPYTHON / PYTHON-CSV-FILE
------------------------------------------------------------

Check to see if this file is being executed as the "main" python
Source: guides\rhinopython\python-csv-file\index.md
CSV (comma separated values ) files are commonly used to store and retrieve many different types of data. 
The CSV format is one of the most flexible and easiest format to read.

As an example, a CSV file might be used to store point locations in their X, Y, Z coordinate values:


0.58,-3.7,0
0.58,-3.1,0
-0.23,0.91,0
-5,8.2,0
-3,9.2,0
2.1,8.8,0
2.5,5.5,0
6.2,1.6,0
6,1,0


Or a CSV might contain building data, for instance room and usage information in a database type format. Note that this CSV has a header titles on the first row: 


RoomID,Floor,Use,Square Footage,Capacity,Price
100,1,Retail,6598,55,6500
101,1,Retail,1900,25,3000
102,1,Retail,1850,25,3000
103,1,Restroom,250,0,0
104,1,Maintenance,150,0,0
200,2,Studio,875,2,850
201,2,Studio,734,2,850
202,2,Studio,624,2,850
203,2,Studio,624,2,850


The csv module in Python can be used to quickly parse CSV files into different data structures. In this sample the point coordinate file we will read into a list in which the X, Y and Z coordinates can be referenced by the index position in a list. The building data will be read in to a dictionary object so that the various values can be referenced by the header titles as named pieces of information. 

Reading into a list

Here is an example script to read a CSV file into a list. Each row will become its own list and then can be referenced by the index position: 

{{}}

import csv
import rhinoscriptsyntax as rs

def CSVlist():
 #prompt the user for a file to import
 filter = "CSV file (.csv) .csv .txt All Files (.) . "
 filename = rs.OpenFileName("Open Point File", filter)
 if not filename: return

 with open(filename) as csvfile:
 reader = csv.reader(csvfile)
 for row in reader:
 x = float(row[0])
 y = float(row[1])
 z = float(row[2])
 print x, y, z
 rs.AddPoint(x,y,z)

Check to see if this file is being executed as the "main" python
script instead of being used as a module by so... [truncated]

Essential Code:
import csv
import rhinoscriptsyntax as rs

def CSVlist():
    #prompt the user for a file to import
    filter = "CSV file (*.csv)|*.csv|*.txt|All Files (*.*)|*.*||"
    filename = rs.OpenFileName("Open Point File", filter)
    if not filename: return

    with open(filename) as csvfile:
        reader = csv.reader(csvfile)
        for row in reader:
            x = float(row[0])
            y = float(row[1])
            z = float(row[2])
            print x, y, z
            rs.AddPoint(x,y,z)

Check to see if this file is being executed as the "main" python
...
import csv
import rhinoscriptsyntax as rs


def CSVbuilding():
    #prompt the user for a file to import
    filter = "CSV file (*.csv)|*.csv|*.txt|All Files (*.*)|*.*||"
    filename = rs.OpenFileName("Open Point File", filter)
    if not filename: return

    with open(filename) as csvfile:
        reader = csv.DictReader(csvfile)
        for row in reader:
            print(row['Use'], row['Square Footage'])
print(row)

Check to see if this file is being executed as the "main" python
script instead of being used as a module by some other python script
This allows us to use the module which ever way we want.
...

GUIDES / RHINOPYTHON / PYTHON-DATATYPES
------------------------------------------------------------

Index
Source: guides\rhinopython\python-datatypes\index.md
Overview

Python has five standard Data Types:

 Numbers
 String
 List
 Tuple
Dictionary

Python sets the variable type based on the value that is assigned to it. Unlike more riggers languages, Python will change the variable type if the variable value is set to another value. For example:


var = 123 # This will create a number integer assignment
var = 'john' # the var variable is now a string type.


Numbers

Python numbers variables are created by the standard Python method:


var = 382


Most of the time using the standard Python number type is fine. Python will automatically convert a number from one type to another if it needs. But, under certain circumstances that a specific number type is needed (ie. complex, hexidecimal), the format can be forced into a format by using additional syntax in the table below:

 Type Format Description 

 int a = 10 Signed Integer 
 long a = 345L (L) Long integers, they can also be represented in octal and hexadecimal 
 float a = 45.67 (.) Floating point real values 
 complex a = 3.14J (J) Contains integer in the range 0 to 255. 

Most of the time Python will do variable conversion automatically. You can also use Python conversion functions (int(), long(), float(), complex()) to convert data from one type to another. In addition, the type function returns information about how your data is stored within a variable.


message = "Good morning"
num = 85
pi = 3.14159

print(type(message)) # This will return a string
print(type(num)) # This will return an integer
print(type(pi)) # This will return a float


String

Create string variables by enclosing characters in quotes. Python uses single quotes ' double quotes " and triple quotes """ to denote literal strings. Only the triple quoted strings """ also will automatically continue across the end of line statement.


firstName = 'john'
lastName = "smith"
message = """This is a string that will span across multiple lines. Using newline characters
and no... [truncated]

Essential Code:
message = "Good morning"
num = 85
pi = 3.14159

print(type(message))  # This will return a string
print(type(num))  # This will return an integer
print(type(pi))  # This will return a float

mylist = ['Rhino', 'Grasshopper', 'Flamingo', 'Bongo']
B = len(mylist) # This will return the length of the list which is 3. The index is 0, 1, 2, 3.
print (mylist[1]) # This will return the value at index 1, which is 'Grasshopper'
print (mylist[0:2]) # This will return the first 3 elements in the list.


GUIDES / RHINOPYTHON / PYTHON-DICTIONARIES
------------------------------------------------------------

Index
Source: guides\rhinopython\python-dictionaries\index.md
Overview

One of the nice features of scripting languages such as Python is what is called an associative array. An associative array differs from a "normal" array in one major respect: rather than being indexed numerically (i.e. 0, 1, 2, 3, ...), it is indexed by a key, or an English-like word. Python has something very similar to an associative array in the Dictionary object. The Python Dictionary object provides a key:value indexing facility. Note that dictionaries are unordered - since the values in the dictionary are indexed by keys, they are not held in any particular order, unlike a list, where each item can be located by its position in the list.

The Dictionary object is used to hold a set of data values in the form of (key, item) pairs. A dictionary is sometimes called an associative array because it associates a key with an item. The keys behave in a way similar to indices in an array, except that array indices are numeric and keys are arbitrary strings. Each key in a single Dictionary object must be unique.

Dictionaries are used when some items need to be stored and recovered by name. For example, a dictionary can hold all of the environment variables defined by the system or all the values associated with a registry key. While this can be much faster than iterating a list looking for a match, a dictionary can only store one item for each key value. That is, dictionary keys must all be unique.

Creating Dictionaries

To create an empty dictionary, use a pair of braces {}

roomempty = {}

To construct an instance of a dictionary object with key:item pairs filled in, use one of the following methods.

The dictionary roomnum is created and filled in with each key:value pair, rather than as an empty dictionary. The key is a string or number, in the example below it is a person's name, followed be a colon : as a separator from the associated value which can be any datatype, in this case an integer. Commas , seperate different key:value pairs in the dictionar... [truncated]

GUIDES / RHINOPYTHON / PYTHON-DICTIONARY-DATABASE
------------------------------------------------------------

Here is a method to find and change a value in the database.
Source: guides\rhinopython\python-dictionary-database\index.md
Overview

There are many modern data structures that use a structured key:value pairs to describe objects and the data that is stored within them. A few popular ones are XML, JSON and Amazon S3(Dynamo).

The Dictionary object is used to hold a set of data values in the form of (key, value) pairs. The values can be any standard datatype including lists. This article may serve help understand how Python can be used to create and access nested information.

Creating a Key:Value datastore

Using Dictionaries, list and a key:values can be used together to create this datastore. Here is an example of a nested dictionary that stores many different items. In this case, we have a series of polylines representing various rooms for a medical office. Look closely at the bracket and parens that are used. The curly braces {} denote the a dictionary. The square brackets [] represent a list as a value in the medical key. The list in 'medical' actually contains a series of dictionaries for each individual office.


datastore = { "office": {
 "medical": [
 { "room-number": 100,
 "use": "reception",
 "sq-ft": 50,
 "price": 75
 },
 { "room-number": 101,
 "use": "waiting",
 "sq-ft": 250,
 "price": 75
 },
 { "room-number": 102,
 "use": "examination",
 "sq-ft": 125,
 "price": 150
 },
 { "room-number": 103,
 "use": "examination",
 "sq-ft": 125,
 "price": 150
 },
 { "room-number": 104,
 "use": "office",
 "sq-ft": 150,
 "price": 100
 }
 ],
 "parking": {
 "location": "premium",
 "style": "covered",
 "price": 750
 }
 }
}


Accessing the Datastore

There are many ways to access the data in this datastore:


print datastore"office"


This returns the parking dictionary object{ "location": "premium", "style": "covered", "price": 750 }

Knowing that the value for medical is a list. Use and index number to access any single book:


 print datastore"office"[0]


This returns the dictionary object for room 100, reception.

The objects and values in the datastore can also be a... [truncated]

GUIDES / RHINOPYTHON / PYTHON-ERR-OBJECTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-err-objects\index.md
Overview

The VBScript Err object provides access to run-time error information.

The Err object encapsulates errors for a VBScript script. By default, if an error occurs, VBScript terminates script execution and RhinoScript reports the error back to the user. Sometimes this default error processing is not desirable. In this case, the Err object and the On Error statement can be used to let scripts perform their own error handling.

Details

The Err object is a predefined global object. It does not need to be declared before it can be used. The object is used to encapsulate all the information relating to an error condition. This information is presented as a series of properties:
The .Number property is the error number (or code) for the error. This is the default property of the Err object.
The .Source property contains a string that specifies the source of the error. This is typically the ProgID (Programmatic Identifier) of the object that generated the error.
The .Description property contains a string describing the error.
The .HelpFile and .HelpContext properties store information to reference a help topic in a help file. This allows the error to refer to information on possible causes of the error.

Using On Error

To generate a user-defined run-time error, first clear the Err object using the .Clear method. Then raise the error using the .Raise method. This method takes up to five arguments that correspond, in order, to the properties previously listed. For example:


Err.Clear
Err.Raise 1000, "This is a script-defined error", "Test Script"


This example displays the standard RhinoScript error dialog box showing the error information.

To intercept run-time errors and process them in scripts, use the On Error statement. The syntax of this statement is:


On Error Resume Next


After this statement executes, the next run-time errors do not cause script execution to end. Instead, the Err object properties are set to reflect the error informatio... [truncated]

GUIDES / RHINOPYTHON / PYTHON-LOOPING
------------------------------------------------------------

Index
Source: guides\rhinopython\python-looping\index.md
Overview

Looping allows you to run a group of statements repeatedly. Some loops repeat statements until a condition is False; others repeat statements until a condition is True. There are also loops that repeat statements a specific number of times.

The following looping statements are available in Python:

 for - Uses a counter or loops through a each item in a list a specified number of times.
 while - Loops while a condition is True.
 Nested loops - Repeats a group of statements for each item in a collection or each element of an array.

Loop statements use a very specific syntax. Unlike other languages, Python does not use an end statement for its loop syntax. The initial Loop statement is followed by a colon : symbol. Then the next line will be indented by 4 spaces. It is these spaces to the left of the line that is key.


for c in range(0, 3):
 This is the the loop
 This is a second line and the last line of the for loop
This line is not part of the loop. It is the first line in the rest of the script.
.....


Each subsequent lone in the loop also needs to be indented by 4 or more spaces. If a line is not indented it is considered outside the loop and will also terminate any additional lines considered in the loop. A common mistake is remove the spaces and therefore prematurely end the loop.

For Loop

You can use for statements to run a block of statements a specific number of times. 

Using Python to loop through each item in any type of list based structure is very easy. 

For loops, use a counter variable whose value increases or decreases with each repetition of the loop.

The following example causes a procedure to execute 4 times. The for statement specifies the counter variable x and its start and end values. Python will automatically increments the counter (x) variable by 1 after coming to end of the execution block.


for x in range(0, 3):
 print ("We're on loop " + str(x))


Python can use any iterable method as a the for loop counter. ... [truncated]

GUIDES / RHINOPYTHON / PYTHON-MODULES
------------------------------------------------------------

Index
Source: guides\rhinopython\python-modules\index.md
Overview

Python is an extensible programming language with hundreds of additional modules. This allows Python to be used in many situations both inside Rhino and outside Rhino. There are some specific additional models that are specifically of interest related to Rhino and Grasshopper.

These new modules can be accessed in a Python script by including the import method at the top of each Python script:


import rhinoscriptsyntax as rs
import math


RhinoScriptSyntax

The RhinoScriptSyntax methods library contains hundreds of easy-to-use functions that perform a variety of operations on Rhino. The library allows Python to be aware of the Rhino's:

 Geometry
 Commands
 Document objects
 Application methods

To make these methods easy-to-use, all RhinoScriptSyntax methods return simple Python variables or Python List-based data structures. Thus, once you are familiar with Python, you will be able to use any and all functions in the RhinoScriptSyntax methods library. RhinoScriptSyntax is divided into modules that mirror standard Rhino commands.

A good set of tutorials on using RhinoScript methods can be found in the Python in Rhino tutorials

For those that are familiar with the RhinoScript language in Rhino for Windows. RhinoScriptSyntax is meant to duplicate the functionality provided by the RhinoScript language. If you are familiar with RhinoScript in Rhino for Windows the transition to Python in Rhino should be natural.

RhinoCommon

RhinoCommon is an extensive, low level .NET library of the Rhino SDK. It is meant for more experienced programmers that would like to most extensive access to Rhino and its classes.

An important detail that will become important as you are learning to script Rhino with Python is that the implementation of Python that is embedded in Rhino is called IronPython: a Python implementation in C# that runs on the .Net/mono platform which means that in addition to the Python language features and the rhinoscriptsyntax package, you al... [truncated]

GUIDES / RHINOPYTHON / PYTHON-OPERATORS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-operators\index.md
Overview

Python has a full range of operators, including arithmetic operators, comparison operators, concatenation operators, and logical operators.

Operator Precedence

When several operations occur in an expression, each part is evaluated and resolved in a predetermined order called operator precedence. You can use parentheses to override the order of precedence and force some parts of an expression to be evaluated before others. Operations within parentheses are always performed before those outside. Within parentheses, however, standard operator precedence is maintained.

When expressions contain operators from more than one category, arithmetic operators are evaluated first, comparison operators are evaluated next, and logical operators are evaluated last. Comparison operators all have equal precedence; that is, they are evaluated in the left-to-right order in which they appear. Arithmetic and logical operators are evaluated in the following order of precedence.

Arithmetic

 Description Symbol 

 Exponentiation * 
 Unary negation - 
 Multiplication 
 Division / 
 Integer Division // 
 Modulus arithmetic % 
 Addition + 
 Subtraction - 
 String concatenation + 

Comparison

 Description Symbol 

 Less than  
 Less than or equal to = 
 Equality == 
 Inequality != 
 Object equivalence is 

Logical

 Description Symbol 

 Logical negation not 
 Logical conjunction and 
 Logical disjunction or 

Considerations

When multiplication and division occur together in an expression, each operation is evaluated as it occurs from left to right. Likewise, when addition and subtraction occur together in an expression, each operation is evaluated in order of appearance from left to right.

The string concatenation (+) operator is not an arithmetic operator, but in precedence it falls after all arithmetic operators and before all comparison operators. The is operator is an object reference comparison operator. It does not compare objects or their values; it checks only to de... [truncated]

GUIDES / RHINOPYTHON / PYTHON-OVERLOADS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-overloads\index.md
Problem

When you run a script that calls a RhinoCommon method that has overloads , you might see the following error:

Message: Multiple targets could match


More Information

.NET supports overloading methods by both number of arguments and type of arguments.

When IronPython code calls an overloaded method, it tries to select one of the overloads at runtime based on the number and type of arguments passed to the method, and also names of any keyword arguments.

In most cases, the expected overload gets selected. However, IronPython will raise a TypeError if there are conversions to more than one of the overloads:

To control the exact overload that gets called, use the Overloads method on method objects:

Example

For a practical example, let's look at RhinoCommon's Brep.Split method, which has five overloads:


// Splits a Brep into pieces using a Brep as a cutter.
public Brep[] Split(Brep splitter, double intersectionTolerance)

// Splits a Brep into pieces using Breps as cutters.
public Brep[] Split(IEnumerable cutters, double intersectionTolerance)

// Splits a Brep into pieces using curves, at least partially on the Brep, as cutters.
public Brep[] Split(IEnumerable cutters, double intersectionTolerance)

// Splits a Brep into pieces using a Brep as a cutter.
public Brep[] Split(Brep splitter, double intersectionTolerance, out bool toleranceWasRaised)

// Splits a Brep into pieces using a combination of curves, to be extruded, and Breps as cutters.
public Brep[] Split(IEnumerable cutters, Vector3d normal, bool planView, double intersectionTolerance)


If you run the following example code, which should split a Brep with one or more cutting Breps:


import Rhino
import scriptcontext as sc
import rhinoscriptsyntax as rs

id = rs.GetObject("Select Brep to split", filter = 8+16, preselect = True)
brep = rs.coercebrep(id)

ids = rs.GetObjects("Select cutting Breps", filter = 8+16,)
cutters = [rs.coercebrep(item) for item in ids]

tol = sc.doc.ModelAbsoluteT... [truncated]

Essential Code:
// Splits a Brep into pieces using a Brep as a cutter.
public Brep[] Split(Brep splitter, double intersectionTolerance)

// Splits a Brep into pieces using Breps as cutters.
public Brep[] Split(IEnumerable<Brep> cutters, double intersectionTolerance)

// Splits a Brep into pieces using curves, at least partially on the Brep, as cutters.
public Brep[] Split(IEnumerable<Curve> cutters, double intersectionTolerance)

// Splits a Brep into pieces using a Brep as a cutter.
public Brep[] Split(Brep splitter, double intersectionTolerance, out bool toleranceWasRaised)

// Splits a Brep into pieces using a combination of curves, to be extruded, and Breps as cutters.
public Brep[] Split(IEnumerable<GeometryBase> cutters, Vector3d normal, bool planView, double intersectionTolerance)


GUIDES / RHINOPYTHON / PYTHON-PACKAGES
------------------------------------------------------------

r: numpy
Source: guides\rhinopython\python-packages\index.md
One of the powers of Python is its ability to use thousands of additional modules in its scripts.
There are 4 main sources of Python packages that may be installed or loaded into Python 3.
 Built-in Modules - Comes with the Rhino.Python install.
 Local Modules - These are Libraries made from other Python files.
 Packages on PyPI - 500,000 Python Modules available online.
 Downloaded Packages - For some specialized Packages, it may be necessary to download the models manually.

Built-in Modules

Python comes with many built-in modules that add functionality. To use methods within built-in modules they simply need to be imported first:


import math


Here's a list of most useful predefined modules within Python:

 Date and Time
 datetime — Basic date and time types
 time — Time access and conversions
 Numeric and Mathematical Modules
 math — Mathematical functions
 fractions — Rational numbers
 random — Generate pseudo-random numbers
 File and Directory Access
 System.IO — Common pathname manipulations
 tempfile — Generate temporary files and directories
 csv — CSV File Reading and Writing
 String Services
 string — Common string operations
 StringIO — Read and write strings as files
 fpformat — Floating point conversions

A complete list of predefined modules in Python, see the Python Standard Library modules

Local Modules

In addition to built-in modules, you can define and import your own Python functions from other files. This allows you to organize your code into reusable components.

For instance in a pythonfunctions.py file here are two defined functions printrhinoversion and getpythonversion


import Rhino
import sys

def printrhinoversion():
 ver = str(Rhino.RhinoApp.Version)
 versp = ver.split(".")
 print("Major version: " + versp[0])
 print("Service Release: " + versp[1])

def getpythonversion():
 ver = sys.version
 print("Python version: " + ver)


Those functions then can be imported and called by:


import pythonfunctions as pf
... [truncated]

Essential Code:
import Rhino
import sys


def print_rhino_version():
    ver = str(Rhino.RhinoApp.Version)
    versp = ver.split(".")
    print("Major version: " + versp[0])
    print("Service Release: " + versp[1])


def get_python_version():
    ver = sys.version
    print("Python version: " + ver)

import python_functions as pf

pf.print_rhino_version()


GUIDES / RHINOPYTHON / PYTHON-PROCEDURES
------------------------------------------------------------

Use this code to call the Celsius function
Source: guides\rhinopython\python-procedures\index.md
Overview

In Python a function is a named block of code that can perform a reusable action. This allows Python code to be broken down into functional, reusable blocks of code.

There are many modules available for Python. These modules contain a great number of pre-defined procedures that can be very useful. There are libraries that help with Date, Time, Math, etc.

Import Modules

You can use any Python file as a module by using the import statement. Once imported all the procedures in the import are available. The standard syntax for importing is:


import rhinoscriptsyntax


To import more the one module, use commas to separate module names:


import rhinoscriptsyntax, time, math

To access procedures in imported modules, prefix the function with the imported model name, separated by a period (.):


import time

print (time.strftime("%H:%M:%S")) #strftime is a proccedure in the time module.


The import statement can also be used to change the reference name of the incoming module. Use this function to make module names shorter to use and easier to read in the code. A very common example of this is how we normally will shorted the rhinoscriptsyntax module to rs for convenience:


import rhinoscriptsyntax as rs

rs.AddPoint (1, 2, 3) # The Rhinoscriptsyntax module is accessed throught 'rs' abreviation.


It is also possible to import only a portion of a module. In the following case, only certain namespaces are imported from the larger Syste.IO module:


from System.IO import Path, File, FileInfo, FileAttributes


The imported modules above are referenced by using Path, File, FileInfo, FileAttributes as namespaces.

Common Modules

There are many modules available for Python. Some of the most useful to Rhino Python are:

 Rhinoceros modules
 rhinoscriptsyntax - The basic rhino library of procedures
 rhino -
 String Services
 string — Common string operations
 StringIO — Read and write strings as files
 fpformat — Floating p... [truncated]

Essential Code:
def Celsius(fDegrees):
    _Celsius = (fDegrees - 32) * 5 / 9
    return _Celsius;

Use this code to call the Celsius function
temp = raw_input("Please enter the temperature in degrees F.", 1)
MsgBox "The temperature is " & Celsius(temp) & " degrees C."


Function Celsius(fDegrees)
    _Celsius = (fDegrees - 32) * 5 / 9
    return _Celsius;


GUIDES / RHINOPYTHON / PYTHON-RANDOM-NUMBER
------------------------------------------------------------

Index
Source: guides\rhinopython\python-random-number\index.md
Overview

Python comes with a random number generator which can be used to generate various distributions of numbers. These random number generators are suitable for generating numbers for spacial and graphical distributions. To access the random number generators, the random module must be imported.

IMPORTANT  Use os.urandom() or SystemRandom if you require a cryptographically secure pseudo-random number generator.

Simple Random numbers

The basic method to create a random number from the imported random module is with random.random()


import random

rannumber = random.random()
print rannumber

The output from the above code is a random number between 0 and 1, say 0.280268102083 The number can be used directly or to arrive at some other number:


import random
import rhinoscriptsyntax as rs

rannumber = random.random()
degrees = rannumber*360
id = rs.GetObject("Select an object to rotate randomly around the CPlane origin")
if id:
 rs.RotateObject(id,[0,0,0], degrees)


Use random.uniform() to generate a random number between two numbers other than zero and 1:



import random

low = 4; high = 8
rannumber = random.uniform(low, high)
print rannumber

The above would generate a random number between 4 and 8. Note for random.uniform low and high numbers must be specified.

Advanced Random numbers

For graphic and special random distributions, many times better distributions can be generated using one of the advanced distributions. These random numbers can generate cumulative distribution functions. There are functions to compute uniform), normal \(Gaussian\), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is also available.

For more detailed information on these advanced number generators go to the Generate pseudo-random numbers documentation

The random module contain... [truncated]

GUIDES / RHINOPYTHON / PYTHON-READING-WRITING
------------------------------------------------------------

Import points from a text file
Source: guides\rhinopython\python-reading-writing\index.md
We'll use a couple of simple scripts from the Python Samples folder as examples - we'll dissect these to see how they work.

Reading a file

Here is the import-points.py script


Import points from a text file
import rhinoscriptsyntax as rs

def ImportPoints():
 #prompt the user for a file to import
 filter = "Text file (.txt) .txt All Files (.) . "
 filename = rs.OpenFileName("Open Point File", filter)
 if not filename: return

 #read each line from the file
 file = open(filename, "r")
 contents = file.readlines()
 file.close()

 # local helper function 
 def _pointfromstring(text):
 items = text.strip("()\n").split(",")
 x = float(items[0])
 y = float(items[1])
 z = float(items[2])
 return x, y, z

 contents = [pointfromstring(line) for line in contents]
 rs.AddPoints(contents)

Check to see if this file is being executed as the "main" python
script instead of being used as a module by some other python script
This allows us to use the module which ever way we want.
if( name == "main" ):
 ImportPoints()


We've put the action inside a function in this script, the


def ImportPoints()


section. This allows the code to be re-used and simplifies error checking.
The first part uses the rs function


rs.OpenFileName()


to allow the user to specify a file to open, and sets a variable 'filename' to hold this information:


filename = rs.OpenFileName("Open Point File", filter)


with a filter for text files.

If for some reason the user does not specify a file, say with a Cancel, then the line


if not filename: return


ensures that the rest of the code inside this particular function will not be run, since there is nothing that can be done without a file name, and executing the next lines in the script will result in error messages without it. Since there is only the one function in this script, a cancel means the script will stop.

Next a variable is se... [truncated]

Essential Code:
Import points from a text file
import rhinoscriptsyntax as rs

def ImportPoints():
    #prompt the user for a file to import
    filter = "Text file (*.txt)|*.txt|All Files (*.*)|*.*||"
    filename = rs.OpenFileName("Open Point File", filter)
    if not filename: return

    #read each line from the file
    file = open(filename, "r")
    contents = file.readlines()
    file.close()

    # local helper function    
    def __point_from_string(text):
        items = text.strip("()\n").split(",")
        x = float(items[0])
        y = float(items[1])
        z = float(items[2])
...
def ImportPoints()


GUIDES / RHINOPYTHON / PYTHON-REFERENCE
------------------------------------------------------------

Index
Source: guides\rhinopython\python-reference\index.md
Overview

Python functions can return multiple objects as a tuple. 

On the other hand, .NET methods, like those provided by RhinoCommon, can only return one object as the result of a call. In order to return more than one object, by-reference, or by-ref, parameters are needed. These parameters are decorated with the ref and out keywords in C#.

More Information

A example of a method that requires a by-ref parameter is Dictionary.TryGetValue, which has a value output parameter. The method returns true if the dictionary contains an element with the specified key (the element value itself is returned to the parameter "value"), otherwise it returns false.

When making calls to such methods in IronPython, we may not pass in arguments for the output parameters. Instead, the result of such .NET method call in IronPython will likely be a tuple (unless the .NET method's return type is void and the method has only one by-ref parameter), which contains the value of the output parameter (see the example below).


import System
d = System.Collections.Generic.Dictionary
d[1], d[2] = 'One', 'Two'

print d.TryGetValue(1) # (True, 'One')
print d.TryGetValue(2)[1] # Two 
print d.TryGetValue(3) # (False, None)


We may also pass a clr.Reference object for the output parameter. The clr.Reference object has only one member "Value", which will carry the output parameter value after the call. When encountering this type of argument, the IronPython code generation and runtime does something special to update the "Value".


x = clr.Reference
print d.TryGetValue(1, x), x.Value # True One
print d.TryGetValue(3, x), x.Value # False None


For reference parameters, we are required to pass in something. If the argument is not a clr.Reference object, such reference argument value will also be part of the returned tuple; otherwise, the by-ref change is tracked inside clr.Reference.

Note, if the .NET method contains more than one by-ref parameter, Python expects the user to prov... [truncated]

Essential Code:
// Gets a world 3-D, or Euclidean, control point at the given u,v index. 
// The 4-D representation is (x, y, z, 1.0).
public bool GetPoint(int u, int v, out Point3d point)

// Gets a homogeneous control point at the given (u, v) index, 
// where the 4-D representation is (x, y, z, w). 
// The world 3-D, or Euclidean, representation is (x/w, y/w, z/w).
public bool GetPoint(int u, int v, out Point4d point)


GUIDES / RHINOPYTHON / PYTHON-REGEXP-OBJECTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-regexp-objects\index.md
Overview

The VBScript RegExp object matches strings against special text patterns, called regular expressions.

The InStr function can be used to search a string to see if it contains another string. The RegExp object provides a far more sophisticated string searching facility by using regular expressions.

A regular expression is a string that describes a match pattern. The match pattern provides a template that can be used to test another string, the search string, for a matching sub-string. In its simplest form, the match pattern string is just a sequence of characters that must be matched. For example, the pattern "fred" matches this exact sequence of characters and only this sequence. More sophisticated regular expressions can match against items such as file names, path names, and Internet URLs. Thus, the RegExp object is frequently used to validate data for correct form and syntax.

Using RegExp

To test a search string against a match pattern, create a RegExp object and set the match pattern. Then use the .Test method to test for a match. For example:


Dim oRE, bMatch
Set oRE = New RegExp
oRE.Pattern = "fred"
bMatch = oRE.Test("His name was fred brown")


Regular expression objects are created using the New keyword. This is an anomaly of VBScript, because it is the only object, apart from user-defined objects, that is created in this manner. Once created in this way, the methods and properties of the object are accessed normally.

The .Pattern property defines the match pattern, and the .Test method tests the supplied string against this match pattern, returning True if the match pattern is found within the supplied string. In the preceding example, bMatch is set to True as there is clearly a match.

The .Execute method of the RegExp object also checks for a pattern match, but it returns a Matches collection object that contains detailed information on each pattern match. The Matches object is a normal collection object containing a .Count property... [truncated]

GUIDES / RHINOPYTHON / PYTHON-REMOTE-LOCAL-MODULE
------------------------------------------------------------

Create a circle from a center point and a circumference.
Source: guides\rhinopython\python-remote-local-module\index.md
Overview

A Python script normally can be full of functions that can be imported as a library of functions in other scripts, or a python script can be a command that runs in Rhino. 

There is a way to have Python definitions be both a library of functions and a direct command.

The key is to add these statements to the end of the file:


if name == 'main':
 CreateCircle() # Put the a call to the main function in the file. 


A complete script example

Here is a complete Python sample that shows how the if name == 'main': statement can be added to a Python script:


Create a circle from a center point and a circumference.
import rhinoscriptsyntax as rs
import math

def CreateCircle(circumference=None):
 center = rs.GetPoint("Center point of circle")
 if center:
 plane = rs.MovePlane(rs.ViewCPlane(), center)
 length = circumference
 if length is None: length = rs.GetReal("Circle circumference")
 if length and length>0:
 radius = length/(2math.pi)
 objectId = rs.AddCircle(plane, radius)
 rs.SelectObject(objectId)
 return length
 return None

Check to see if this file is being executed as the "Main" python
script instead of being used as a module by some other python script
This allows us to use the module which ever way we want.
if name == 'main':
 CreateCircle()



The CreateCricle file above will run as a script to create a circle. But it can be used in the UseModule.py script as an imported module, as follows:


This script uses a function defined in the CircleFromLength.py
script file
import CircleFromLength

call the function a few times just for fun using the
optional parameter
length = CircleFromLength.CreateCircle()
if length is not None and length>0.0:
 for i in range(4):
 CircleFromLength.CreateCircle(length)


How it works

When the Python interpreter reads a source file, it executes all of the code found in it.

Before executing the code, it will define a few special variables. If Python is running the file as the main program then ... [truncated]

Essential Code:
if __name__ == '__main__':
    CreateCircle()  # Put the a call to the main function in the file.    

Create a circle from a center point and a circumference.
import rhinoscriptsyntax as rs
import math

def CreateCircle(circumference=None):
    center = rs.GetPoint("Center point of circle")
    if center:
        plane = rs.MovePlane(rs.ViewCPlane(), center)
        length = circumference
        if length is None: length = rs.GetReal("Circle circumference")
        if length and length>0:
            radius = length/(2*math.pi)
            objectId = rs.AddCircle(plane, radius)
            rs.SelectObject(objectId)
            return length
    return None

Check to see if this file is being executed as the "Main" python
script instead of being used as a module by some other python script
This allows us to use the module which ever way we want.
...

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-COLOR
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-color\index.md
Colors

Colors in Rhino are represented as zero-based, one-dimensional arrays that contain four values. The first 3 values are the Red, Green and Blue channels. Each channel may contain a value from 0 to 255. The fourth value is the Alpha Channel. This control transparency of the color. 0 is completely transparent and the default value of 255 is completely opaque. 


color contains (Red, Green, Blue, Alpha)


Use the CreateColor() function to create a new color structure:


import rhinoscriptsyntax as rs

color1 = rs.CreateColor(128, 128, 128) # Creates a medium grey color.


The CreateColor() function assumes the alpha value is 255 by default. 


import rhinoscriptsyntax as rs

col = rs.CreateColor(43,45,56)

print (col.R)
print (col.G)
print (col.B)


Unlike many other Rhino types, colors are immutable. This means you cannot set one channel by itself, but must always create a new color when trying to make a color. Setting one channel will not work, for instance color1.B = 56 will throw an error. 

Here is a table of commonly used colors:

 Color Red Green Blue 

 Black 0 0 0 
 White 255 255 255 
 Medium Gray 128 128 128 
 Aqua 0 128 128 
 Navy Blue 0 0 128 
 Green 0 255 0 
 Orange 255 165 0 
 Yellow 255 255 0 

For more colors see an Online RGB Color table. 

Related Topics
What is Python and RhinoScript?
Python Points
Python Vectors
Python Lines
Python Planes
Python Objects

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-INTRODUCTION
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-introduction\index.md
Overview

The RhinoScriptSyntax module contains hundreds of easy-to-use functions that perform a variety of operations on Rhino. The library allows Python to be aware of Rhino's:

 Geometry
 Commands
 Document objects
 Application methods

To make these methods easy-to-use, all RhinoScriptSyntax methods return simple Python variables or Python List-based data structures. Thus, once you are familiar with Python, you will be able to use any and all functions in the RhinoScriptSyntax methods library. For the whole namespace, see the Rhinoscriptsyntax API reference.

Importing RhinoScriptSyntax

Before using RhinoScriptSyntax a line must be added to the top of each Python file to allow access to RhinoScriptSyntax:


import rhinoscriptsyntax as rs


The import above not only imports the library, but also renames the module to rs.. This is done to just make it easier to type when accessing the methods in RhinoScriptSyntax. Access to the methods can now be made by starting methods with 'rs.'. For example, accessing the AddCircle() method in the RhinoScriptSyntax module can be used to create a circle:


import rhinoscriptsyntax as rs

centerpoint = [1, 2, 4]
rs.AddCircle( centerpoint, 5.0 )


Geometry

Rhino is a 3D modeler, therefore creating and modifying geometry is key to developing in Rhino. Here are the primitive geometry types of Rhino:
Points
List of Points
Vectors
Lines
Planes
Rhino Geometry Objects

Creating, accessing and manipulating geometry is one of the first places RhinoScriptSyntax is used. Simple geometry such as points, lines, and planes can be described with lists in Python. More complicated geometry objects such as NURBS curves, Surfaces and Poly-surfaces can be created by Rhino and referenced by an object ID in RhinoScriptSyntax.

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-LINE
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-line\index.md
Lines

3-D lines, or chords, are represented as zero-based, one-dimensional arrays that contain two elements: the starting 3-D point and the ending 3-D point. A 3-D line is represented by a start pint and an ednpoint.

line1 = ((1.0, 2.0, 3.0), (4.0, 5.0, 6.0))

To add the line to the current Rhino file, and see it drawn on screen, you can use the AddLine method in RhinoscriptSytnax:


import rhinoscriptsyntax as rs

startPoint = (1.0, 2.0, 3.0)
endPoint = (4.0, 5.0, 6.0)

lineID = rs.AddLine(startPoint,endPoint)

print(lineID)


When adding geometry to Rhino, rhinoscriptsyntax will return an 'Object ID' for the added object. The Rhino file has the object added as geometry in the file. Just like an object added using a Rhino command, it has an ID that is a unique reference to this object. This makes it possible and easy to get access to the specific object later in the script. Saving this ID in a variable or a list is what allows it to be used later to select and manipulate the object.

RhinoScript contains a number of methods to manipulate lines. See Lines and Planes for details.

Related Topics
What is Python and RhinoScript?
Python Points
Python Vectors
Python Lines
Python Planes
Python Objects

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-LINE-PLANE-METHODS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-line-plane-methods\index.md
Line and Plane Methods

The following methods are available for creating and manipulating lines and planes.

Lines are represented as zero-based, one-dimensional arrays containing two elements: the start point (3-D point) and the end point (3-D point).

Planes are represented as zero-based, one-dimensional arrays containing four elements: the plane's origin (3-D point), the plane's x-axis direction (3-D vector), the plane's y-axis direction (3-D vector), and the plane's z-axis direction (3-D vector).


 Method Description 

 DistanceToPlane Returns the distance from a plane to a point. 
 EvaluatePlane Evaluates a point on a plane. 
 IntersectPlanes Returns the point calculated by intersecting three planes. 
 LineArcIntersection Intersects an infinite line and an arc. 
 LineBetweenCurves Create a line perpendicular or tangent between two curves. 
 LineBoxIntersection Intersects an infinite line and an axis aligned bounding box. 
 LineCircleIntersection Intersects an infinite line and a circle. 
 LineClosestPoint Finds the point on an infinite line that is closest to a test point. 
 LineCurveIntersection Intersect an infinite line and a curve object. 
 LineCylinderIntersection Calculates the intersection of a line and a cylinder. 
 LineIsFartherThan Determines if the shortest distance from a line to a point or another line is greater than a specified distance. 
 LineLineIntersection Returns the point calculated by intersecting two lines. 
 LineMaxDistanceTo Finds the longest distance between the line, as a finite chord, and a point or another line. 
 LineMeshIntersection Intersects an infinite line with a mesh object. 
 LineMinDistanceTo Finds the shortest distance between the line, as a finite chord, and a point or another line. 
 LinePlane Returns a plane that contains the line. 
 LinePlaneIntersection Returns the point calculated by intersecting a line with a plane. 
 LineSphereIntersection Calculates the intersecti... [truncated]

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-LIST-POINTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-list-points\index.md
Lists of Points

Many rhinoscriptsyntax functions require a list of points as an argument or return a list of Point3d structures. For example the 'DivideCurve()' function will return a list of points:


import rhinoscriptsyntax as rs

obj = rs.GetObject("Select a curve")

if obj:
 points = rs.DivideCurve(obj, 4)

print(points[0])


There are a number of ways to access the information in these lists.

Use an index to access any one of the points as in the line:


print(points[0]) # Returns a Point3d structure


With Python, it is easy to use the for loop to walk through the list and print out the coordinates for each point,


for i in points:
 print(i)


It is also possible to use nested indexes to access a specific coordinate of a point in the list. This example will access the Y coordinate of the second point in the list:


print(points1)


Using the .Y property on the Point3d also would work:


print(points[1].Y)


To add a point to this list, first create the point3d with CreatePoint(), then append it:


points.append(rs.CreatePoint(1.0, 2.0, 3.0))

for i in points:
 print(i)


Related Topics
What is Python and RhinoScript?
Python Points
Python Vectors
Python Lines
Python Planes
Python Objects

Essential Code:
print(points[0]) # Returns a Point3d structure


GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-NURBS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-nurbs\index.md
Overview

Rhino uses various geometry types. There are some basic types like Points, Vectors, Lines and Planes. In Python, simple geometry can be described with simple lists.

More complicated geometry objects such as NURBS curves, surfaces, and poly-surfaces can be created by Rhino. Rhino Geometry Objects are referenced by an object ID by RhinoScriptSyntax

Although not required, having some understanding of the computational methods used in 3D modeling and computer graphics can be helpful when developing in Rhino. A good introductory resource is the Essential Mathematics for Computational Design. Although all concepts are explained visually using Grasshopper®, they are directly applicable to RhinoScriptSyntax.

NURBS Geometry

All NURBS curves and surfaces share terminology and behave similarly. Since curves are easiest to describe, we will cover them in detail.

A NURBS curve is defined by four things: degree, control points, knots, and an evaluation rule. 

Degree

The degree of a curve is a positive whole number. 

This number is usually 1, 2, 3 or 5, but can be any positive whole number. NURBS lines and polylines are usually degree 1, NURBS circles are degree 2, and most free-form curves are degree 3 or 5. Sometimes the terms "linear," "quadratic," "cubic," and "quintic" are used. "Linear" means degree 1, "quadratic" means degree 2, "cubic" means degree 3, and "quintic" means degree 5. 

You may see references to the "order" of a NURBS curve. The order of a NURBS curve is positive whole number equal to the degree plus one (degree+1). Consequently, the degree is equal to the order minus one (order-1). 

It is possible to increase the degree of a NURBS curve and not change its shape. Generally, it is not possible to reduce a NURBS curve’s degree without changing its shape.

Control Points

The control points are a list of at least degree+1 points. 

One of easiest ways to change the shape of a NURBS curve is to move its control points. 

The control points have ... [truncated]

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-OBJECTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-objects\index.md
Objects

Rhino can create and manipulate a number of objects, including points, point clouds, curves, surfaces, B-reps, meshes, lights, annotations, and references. Each object in the Rhino document is identified by a globally unique identifier, or GUID, that is generated and assigned to objects when they are created. Object identifiers are saved in the 3dm file, so an object's identifier will be the same between editing sessions.

To view an object's unique identifier, use Rhino's Properties command.

For convenience, RhinoScriptSyntax returns object identifiers in the form of a string. For example, an object's identifier will look something like the following:

F6E01514-3264-4598-8A07-A58BFE739C38

The majority of RhinoScriptSyntax's object manipulation methods require one or more object identifiers to be acquired before the method can be executed.

Geometry and Attributes

Rhino objects consist of two components: the object's geometry and the object's attributes.

The types of geometry support by Rhino include points, point clouds, curves, surfaces, polysurfaces, extrusions, meshes, annotations and dimensions.

The attributes of an object include such properties as color, layer, linetype, render material, and group membership, amongst others.

Example

The following example uses Object IDs to create reference geometry:


import rhinoscriptsyntax as rs

startPoint = (1.0, 2.0, 0.0)
endPoint = (4.0, 5.0, 0.0)

line1ID = rs.AddLine(startPoint,endPoint) # Adds a line to the Rhino Document and returns an ObjectID

startPoint2 = (1.0, 4.0, 0.0)
endPoint2 = (4.0, 2.0, 0.0)

line2ID = rs.AddLine(startPoint2,endPoint2) # Returns another ObjectID

int1 = rs.LineLineIntersection(line1ID,line2ID) # passing the ObjectIDs to the function.

print(int1)


Related Topics
What is Python and RhinoScript?
Points
Vectors
Lines
Planes
Rhino NURBs Geometry

Essential Code:
import rhinoscriptsyntax as rs

startPoint = (1.0, 2.0, 0.0)
endPoint = (4.0, 5.0, 0.0)

line1ID = rs.AddLine(startPoint,endPoint) # Adds a line to the Rhino Document and returns an ObjectID

startPoint2 = (1.0, 4.0, 0.0)
endPoint2 = (4.0, 2.0, 0.0)

line2ID = rs.AddLine(startPoint2,endPoint2) # Returns another ObjectID

int1 = rs.LineLineIntersection(line1ID,line2ID) # passing the ObjectIDs to the function.

print(int1)


GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-PLANE
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-plane\index.md
Planes

Planes are represented by a Plane structure. Planes can be thought of as a zero-based, one-dimensional list containing four elements: the plane's origin (point3D), the plane's X axis direction (vector3d), the plane's Y axis direction (vector3d), and the plane's Z axis direction (vector3d).

{{}}


plane contains (pointOrigin, vectorX, vectorY, vectorZ)


It is easy to forget that there is a specific geometric relationship between the axes. With Planes, the Y axis is automatically oriented 90-degrees to the X axis. The X axis is the only axis that can be easily defined. The Y axis is made orthogonal to the X vector, and the direction of the Z axis is computed from the cross-product of the other two vectors.

Planes can be constructed in a number of ways. One common function is PlaneFromPoints:


import rhinoscriptsyntax as rs

plane = rs.PlaneFromPoints((-2,-5,0),(1,2,0),(-3,3,0))

print(plane.Origin) # origin point
print(plane.XAxis) # x-axis vector
print(plane.YAxis) # y-axis vector


Plane also have a number of properties that can be used to get or set the individual values in the Point object. In the example below the .Origin, .XAxis, .Yaxis, .Zaxis are used.

Planes can also be created using the CreatePlane(), PlaneFromFrame, PlaneFromNormal, and PlaneFromPoints functions.

To change origin of a Plane, simply assign a new value to the .Origin property.


import rhinoscriptsyntax as rs

plane = rs.PlaneFromPoints((-2,-5,0),(1,2,0),(-3,3,0))

print(plane.Origin) # origin point
print(plane.XAxis) # x-axis vector
print(plane.YAxis) # y-axis vector

plane.Origin = rs.CreatePoint(3,4,5) # Changes the origin of the plane.

print(plane.Origin)
print(plane.XAxis) # x-axis vector
print(plane.YAxis) # y-axis vector


RhinoScriptSyntax contains a number of functions to manipulate planes. See Lines and Planes for details.

Also, please see the Python primer Section 8.5 Planes.

Related Topics
What is Python and RhinoScript?
Python Points
Python Ve... [truncated]

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-POINT-VECTOR-METHODS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-point-vector-methods\index.md
Point & Vector Methods

The following methods are available for creating and manipulating 3-D points and 3-D vectors. 3-D points and 3-D vectors are represented as zero-based, one-dimensional arrays that contain three numbers. 

 Method Description 

 IsVectorParallelTo Compares two vectors to see if they are parallel. 
 IsVectorPerpendicularTo Compares two vectors to see if they are perpendicular. 
 IsVectorTiny Verifies a vector is tiny. 
 IsVectorZero Verifies a vector is zero. 
 PointAdd Adds a point or a vector to a point. 
 PointArrayBoundingBox Returns the bounding box of an array of 3-D points. 
 PointArrayClosestPoint Finds the point in an array of 3-D points that is closest to a test point 
 PointArrayTransform Transforms an array of 3-D points. 
 PointClosestObject Finds the object that is closest to a test point. 
 PointCompare Compares two points. 
 PointDivide Divides a point by a value. 
 PointsAreCoplanar Verifies that a list of 3-D points are coplanar. 
 PointScale Scales a point by a value. 
 PointSubtract Subtracts a point or a vector from a point. 
 PointTransform Transforms a point. 
 ProjectPointToMesh Projects one or more points onto one or more meshes. 
 ProjectPointToSurface Projects one or more points onto one or more surfaces 
 PullPoints Pulls points to a surface or a mesh object. 
 VectorAdd Adds two vectors. 
 VectorAngle Returns the angle between two 3-D vectors. 
 VectorCompare Compares two vectors. 
 VectorCreate Create a vector from two 3-D points. 
 VectorCrossProduct Returns the cross product of two vectors. 
 VectorDivide Divides a vector. 
 VectorDotProduct Returns the dot product of two vectors. 
 VectorLength Returns the length of a vector. 
 VectorMultiply Multiplies two vectors. 
 VectorReverse Reverses a vector. 
 VectorRotate Rotates a vector. 
 VectorScale Scales a vector. 
 VectorSubtract Subtracts two vectors. 
 VectorTransform Trans... [truncated]

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-POINTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-rhinoscriptsyntax-points\index.md
Points

In Python, a Rhino 3D point is represented as a Point3d structure. Conceptually, Point3d exist in memory as a zero-based list containing three numbers. These three numbers represent the X, Y and Z coordinate values of the point.


point3D contains (1.0, 2.0, 3.0) 


Creating Points

A Point3D structure can be constructed in a number of different ways. Two common ways are:


import rhinoscriptsyntax as rs

pnt = rs.CreatePoint(1.0, 2.0, 3.0)
pnt = rs.CreatePoint(1.0, 2.0) # This creates a point with the Z coordinate set to 0


The 'CreatePoint()' function is very flexible. It can take a tuple of two or 3 numbers and return a Point3d. The function can also extract the coordinates of a Rhino GUID to return a Point3D.

It is not always necessary to construct a point before passing it to a function that requires a point. It is possible to construct points directly as an argument to a function. A Point is a list like structure. Wrap coordinates in parenthesis() when passing them directly to a function. For instance the rs.addline(point, point) function requires two points. Use the following syntax to construct the points on the fly:


rs.AddLine((45,56,32),(56,47,89))


Like 3-D points, Python represents a single 2-D point as a zero-based list of numbers. The difference being that 2-D points contain only X and Y coordinate values.

Passing coordinates in () to a function is common with RhinoScriptSyntax.

Accessing Point Coordinates

A Point3D list can be accessed like a simple python tupple, one element at a time:


import rhinoscriptsyntax as rs

pnt = rs.CreatePoint(1.0, 2.0, 3.0)

print(pnt[0]) #Print the X coordinate of the Point3D
print(pnt[1]) #Print the Y coordinate of the Point3D
print(pnt[2]) #Print the Z coordinate of the Point3D


The coordinates of a Point3d may also be accessed through its .X, .Y and .Z properties.


import rhinoscriptsyntax as rs

pnt = rs.CreatePoint(1.0, 2.0, 3.0)

print(pnt.X) # Print the X coord... [truncated]

GUIDES / RHINOPYTHON / PYTHON-RHINOSCRIPTSYNTAX-VECTORS
------------------------------------------------------------

A base point
Source: guides\rhinopython\python-rhinoscriptsyntax-vectors\index.md
Vectors

Similar to 3D points, 3D vectors are stored as Vector3d structures. They can be thought as a zero-based, one-dimensional list that contain three numbers. These three number represent to the X, Y and Z coordinate direction of the vector.


vector3d contains (1.0, 2.0, 3.0) 


Here is an easy way to construct a vector:


import rhinoscriptsyntax as rs

vec = rs.CreateVector(1.0, 2.0, 3.0)


A Vector3d's coordinates can be accessed as a list, one element at a time:


import rhinoscriptsyntax as rs

vec = rs.CreateVector(1.0, 2.0, 3.0)

print(vec[0]) #Prints the X coordinate of the Vector3d
print(vec[1]) #Print the Y coordinate of the Vector3d
print(vec[2]) #Print the Z coordinate of the Vector3d


The coordinates of a Vector3d may also be accessed through its .X, .Y and .Z properties:


import rhinoscriptsyntax as rs

vec = rs.CreateVector(1.0, 2.0, 3.0)

print(vec.X) # Prints the X coordinate of the Vector3d
print(vec.Y) # Print the Y coordinate of the Vector3d
print(vec.Z) # Print the Z coordinate of the Vector3d


To change the individual coordinate of a Vector3d, simply assign a new value to the coordinate through the index location or coordinate property:


import rhinoscriptsyntax as rs

point1 = (1,2,3)
point2 = (4,6,7)
vec = rs.CreateVector(1.0, 2.0, 3.0)

vec[0] = 5.0 # Sets the X coordinate to 5.0
vec.Y = 45.0 # Sets the Y coordinate to 45.0

print(vec) #Print the new coordinates


To find the vector between two points, use vector subtraction:

{{}}


point1 = rs.CreatePoint(1,2,3)
point2 = rs.CreatePoint(4,5,6)

vector = point1 - point2

print(vector) #prints the new coordinates.


In the above example, the vector goes from point1 to point2. Reversing this direction is a common mistake. It is important to be sure that the starting point is subtracted from the ending point.

Vectors can also be added to points to create new point locations. Here is an example of moving a point location by a vector:

{{... [truncated]

GUIDES / RHINOPYTHON / PYTHON-RUNNING-SCRIPTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-running-scripts\index.md
Running Scripts

The RunPythonScript command is used to execute script subroutines that were loaded into the Python engine.

RunPythonScript operation

The RunScript dialog box will display a file dialog box. Select a Python file (.py) to run in Rhino. Simply select the python file and hit OK. The Python script will run.

Scripting the RunPythonScript command

As is the case with most Rhino commands, the RunPythonScript command can be scripted, thus bypassing the interactive dialog box. To script the RunPythonScript command, simply precede the command name with a hyphen when entering the command on Rhino's command line. For example:

-RunPythonScript

After entering the command, you will be prompted to enter the name of the script to run.

Assigning the RunPythonScript command to a button.

The RunPythonScript command can also be assigned to command aliases or to a toolbar button.

Related Topics
What is RhinoPython?
Your First Python Script in Rhino (Windows)
Running Scripts
Canceling Scripts
Editing Scripts

GUIDES / RHINOPYTHON / PYTHON-SCRIPT-INTRODUCTION
------------------------------------------------------------

Index
Source: guides\rhinopython\python-script-introduction\index.md
Introduction

The Python language is a comprehensive programming language for both Windows, Macintosh and Grasshopper platforms. Python is meant to be a easy-to-learn language. Python is a great language for people that are not programmers and whom are just learning.

A key characteristic of python is that there is very few extra characters allowing the code to be shorter and potentially easier to read.  Python is open source and managed by the Python Software Foundation

We have added additional libraries to Python in the form of RhinoScriptSyntax and RhinoCommon. These libraries allow Python to be aware of Rhino and Grasshopper:

 Geometry
 Commands
 Document objects
 Application methods

Rhinoscript syntax is the easiest to use and learn library. To make these methods easy-to-use, all RhinoScriptSyntax methods return simple Python variables or Python List-based data structures. Thus, once you are familiar with Python, you will be able to use any and all functions in the RhinoScriptSyntax methods library.

RhinoCommon is an extensive, low level .NET library of the Rhino SDK. It is meant for more experienced programmers that would like to most extensive access to Rhino and its classes.

This document introduces the built-in Script editor in Rhino and using Python with RhinoSciptSyntax to automate Rhino.

Getting help

The information in this help file pertains to the usage of the RhinoScriptSyntax libraries. Additional support for Python in Rhino can be obtained from the following resources.

McNeel Developer Documentation
Rhino Scripting Forum

GUIDES / RHINOPYTHON / PYTHON-STATEMENTS
------------------------------------------------------------

Index
Source: guides\rhinopython\python-statements\index.md
Overview

Many scripting and programming languages, such as JScript, C#, and C++, make no attempt to match the code that is run with the actual physical lines typed into the text editor. This is because they not recognize the end of a line of code until it sees the termination character (in these cases, the semicolon). Thus, the actual physical lines of type taken up by the code are irrelevant.

Unlike other languages, Python does not use an end of line character. Most of the time a simple Enter will do. Yet, Python is very particular about indentation, spaces and lines in certain cases. This document is to help understand Python formatting.

It is important to understand how Python interprets:
End of Statement
Names and Capitalization
Comments
Block Structures
Tabs and Spaces

For the official very detailed documentation on Python Syntax, see the Style Guide for Python Code

End of Statements

To end a statement in Python, you do not have to type in a semicolon or other special character; you simply press Enter. For example, this code will generate a syntax error:


message
=
'Hello World!'


This will not:


message = 'Hello World!'


In general, the lack of a required statement termination character simplifies script writing in Python. There is, however, one complication: To enhance readability, it is recommended that you limit the length of any single line of code to 79 characters. What happens, then, if you have a line of code that contains 100 characters?

Although it might seem like the obvious solution, you cannot split a statement into multiple lines simply by entering a carriage return. For example, the following code snippet returns a run-time error in Python because a statement was split by using Enter.


 message= 'This message will generate an error because
 it was split by using the enter button on your
 keyboard'


You cannot split a statement into multiple lines in Python by pressing Enter. Instead, use the backslash (\) to ... [truncated]

GUIDES / RHINOPYTHON / PYTHON-USER-INPUT
------------------------------------------------------------

GetReal prompts on the command line with optional defaults and a minimum allowable value
Source: guides\rhinopython\python-user-input\index.md
Overview

Prompting the user of a script for the input of a value, selecting a layer, picking a point or selecting a Rhino object is important to many interactive scripts. Many input methods will also validate the user input to make sure only the proper input is accepted.

The RhinoscriptSyntax module contains many ways to interactively prompt for several different types of input. There are three main styles of input that are contained in Rhinosciptsyntax:
Get methods. These are methods that work with the command line, wait for mouse input or prompt for specific input.
Special Dialogs. There are some simple specific dialogs to prompt for input
File system dialogs. Browsing, saving and opening files on the system with Python.
Eto Custom Dialog Framework. A cross-platform dialog framework to create more custom modal and non-modal dialog box classes that can be used in scripts.

The GET methods 

Get are basic ways to prompt for specifc user feedback on the commandline and mouse input. Good examples of a Get might be get a point, a string, or a distance. There are 25 get methods that can 
Commandline Gets - GetReal, GetString, GetInteger, GetBoolean
Interactive Gets - GetPoint(s), GetPointCoordinates, GetLine, GetDistance, GetAngle, GetPolyline, GetRectangle, GetBox, GetCursorPos.
Geometry Gets - GetObject, GetCurveObject, GetSurfaceObject, GetEdgeCurves, GetMeshFaces, GetMeshVertices, GetPointOnCurve, GetPointOnMesh, GetPointOnSurface.

Command Line gets

The simplest Get function is to ask for a specific value on the command line. For instance a Get method may prompting for a number on the command line with rs.GetReal().

Getreal()


import rhinoscriptsyntax as rs

GetReal prompts on the command line with optional defaults and a minimum allowable value
radius = rs.GetReal("Radius of new circle", 3.14, 1.0)
if radius: rs.AddCircle( (0,0,0), radius )

{{}} 

rs.GetReal() accepts any number, including decimals. In some cases your code may need only whole number... [truncated]

GUIDES / RHINOPYTHON / PYTHON-USER-TEXT
------------------------------------------------------------

GetReal prompts on the command line with optional defaults and a minimum allowable value
Source: guides\rhinopython\python-user-text\index.md
User Text

The Rhino allows developers to store custom information on Rhino objects and inside the Rhino 3DM file. This data is referred to as User Text. There are two types of user text:

1.Document user text - custom strings that is stored at the document level of the 3DM file.
2.Object user text - custom strings that are attached to either an object's geometry or an object's attributes.

Important. When storing custom data on an object, the data can be stored on either the object's geometry (e.g. curve, surfaces, etc), or on the object's attributes. An object's attributes maintain it's layer, color and other non-geometric properties. The difference between the two storage methods is that adding or modifying user data that is located on an object's geometry will cause Rhino to place a copy of the object on the Undo stack. Thus, if you are working with large geometric object or lots of user data, it is more efficient to store object user data on an object's attributes.

RhinoScript supports both document user data and object user data. The RhinoScript user data object organizes custom information by Key:Value pairs similar to that of a Windows-style initialization (INI) file or a single layer Python dictionary. For example:


[Section1] 
Key1:String1 
Key2:String2
... 

[Section2] 
Key1:String1 
Key2:String2 
...


The Section value normally is normally a unique name for all the data you might store.

The RhinoScriptSyntax functions only store string values. Fortunetly a Python string can be easily converted from one data type to another if needed.

User Text Methods

Rhino provides a standardized mechanism for users, script writers, and plug-in developers to store and retrieve simple text information on an object and in the document. This mechanism called User Text.

Unlike RhinoScript's User Data methods, which stores data as Section/Entry/String, Rhino stores User Text key/value pairs.

Rhino supports this method of storing object data with its GetUserText, S... [truncated]

GUIDES / RHINOPYTHON / PYTHON-VARIABLES
------------------------------------------------------------

Index
Source: guides\rhinopython\python-variables\index.md
Overview

A variable is a convenient placeholder that refers to a computer memory location where you can store program information that may change during the time your script is running. For example, you might create a variable called ClickCount to store the number of times a user performs a certain operation. 
When a variable is stored in memory, the interpreter will allocate a certain amount of space for each variable type. Where the variable is stored in computer memory is unimportant. What is important is that you know that a variable has a type, and you refer to a variable by name to see or change its value. 

In Python, variables are always one of the five fundamental data types:

 Numbers
 String
 List
 Tuple
Dictionary

For a detailed look at each variable type see Python Variable Types in this guide.

While each variable has its own properties and methods, there are common methods we use to deal with all variables in Python.

Declaration

In Python, variables are created the first time a value is assigned to them. For example:


number = 10
string = "This is a string"


You declare multiple variables by separating each variable name with a comma. For example:


a, b = True, False


This is the same the multiple line declaration of:


a = True
b = False


Naming Restrictions

Variable names follow the standard rules for naming anything in Python. A variable name:
Must begin with an alphabetic character (A -Z) or an underscore (\).
Cannot contain a period(.), @, $, or %.
Must be unique in the scope in which it is declared.
Python is case sensitive. So "selection" and " Selection" are two different variables.

Best practices for all Python naming can be found in the (Style Guide for Python Naming Conventions)[https://www.python.org/dev/peps/pep-0008/#naming-conventions]

Scope & Lifetime

Scope of a variable defines where that variable can be accessed in your code. For instance a global variable can be accessed from anywhere in your co... [truncated]

Essential Code:
global_var = True

def function1():
    local_var = False
    print (global_var)
    print (local_var)

function1() # this runs the function
print (global_var) # this works because global_var is accessible
print (local_var)  # this gives an error because we are outside function1

g_var = 'True'
def function2():
    g_var = 'False'
    print ('inside the function var is ', g_var)

print ('outside the function var is ', g_var)


GUIDES / RHINOPYTHON / PYTHON-WHERE-TO-FIND-HELP
------------------------------------------------------------

Index
Source: guides\rhinopython\python-where-to-find-help\index.md
Forums:

The RhinoPython community is very active and offers a wonderful resource for posting questions/answers and finding help on just about anything!:
http://python.rhino3d.com/forums/

General References for Python:

Python's main website offers a plethora of information about the syntax, building-in functionality, libraries etc! This is the main resource for anything Python!
http://docs.python.org/

The Python Documentation also has a great introduction into the basics of Python:
http://docs.python.org/tutorial/introduction.html
http://docs.python.org/tutorial/

A very useful Python style guide:
http://www.python.org/dev/peps/pep-0008/

Another very thorough resource for Python is from MIT, called "How to Think Like a Computer Scientist":
http://www.greenteapress.com/thinkpython/thinkCSpy/thinkCSpy.pdf

Common Exceptions/Errors:

For a list of common errors, exceptions and pitfalls that you are likely to run into when coding see:
http://docs.python.org/release/3.1.3/library/exceptions.html#bltin-exceptions
http://secant.cs.purdue.edu/_media/proghints.pdf

Syntax & Programming Reminders:
Python is Case Sensitive ("A" and "a" are NOT the same thing!)
Python is Indent Sensitive (Use indentation to delineate the scope of loops, conditionals, functions and classes)
 Remember an extra space or the absence of a space can make a world of a difference!
You do NOT need to declare variables or variables types! Just simply use them (x=3)!
The " # " sign is used for comments, the computer will skip over them.
Print and Return are NOT the same thing - print writes something to the screen, return actually passes a value!
Remember Variable Scope - where you define a variable is important! Variables defined within functions & classes can only be used within those functions/classes unless passed as input or through the return statement!
"return" only works inside a function.
Develop code incrementally, testing, debugging and printing as you finish smaller sections. Writing hundr... [truncated]

GUIDES / RHINOPYTHON / PYTHON-XML-JSON
------------------------------------------------------------

If the file name exists, write a JSON string into the file.
Source: guides\rhinopython\python-xml-json\index.md
JSON (JavaScript Object Notation) is an easy to read, flexible text based format that can be used to store and communicate information to other products. It is mainly based on key:value pairs and is web and .NET friendly. There are many libraries and products that support JSON.

One of the reasons JSON might be used is to collect data from the Rhino model to be used in other places. Use JSON to store information for a door schedule, or a parts list. A report can be created on the name, size and location of all the bitmaps in a model. A JSON file can have the endpoints of all the lines in a model representing column or beam connection points. JSON files are used in several other places and products. JSON is also easy to display on dynamic webpages.

Here is an example of a JSON structure describing a medical office, taken from a set of polylines off a Rhino floorplan. As you will see in the example, the medical space includes 5 rooms and parking, with square footage and pricing for each dedicated space.


{ "office": 
 {"medical": [
 { "room-number": 100,
 "use": "reception",
 "sq-ft": 50,
 "price": 75
 },
 { "room-number": 101,
 "use": "waiting",
 "sq-ft": 250,
 "price": 75
 },
 { "room-number": 102,
 "use": "examination",
 "sq-ft": 125,
 "price": 150
 },
 { "room-number": 103,
 "use": "examination",
 "sq-ft": 125,
 "price": 150
 },
 { "room-number": 104,
 "use": "office",
 "sq-ft": 150,
 "price": 100
 }
 ],
 "parking": {
 "location": "premium",
 "style": "covered",
 "price": 750
 }
 }
} 

It is this dictionary setup that works best for Json.

 But to be saved into a file, all these structures must be reduced to strings. It is the string version that can be read or written to a file. Python has a JSON module that will help converting the datastructures to JSON... [truncated]

GUIDES / RHINOPYTHON / USING-RHINOCOMMON-FROM-PYTHON
------------------------------------------------------------

Create an instance of a GetPoint class and add a delegate for the DynamicDraw event
Source: guides\rhinopython\using-rhinocommon-from-python\index.md
Overview

Along with the RhinoScript style functions you will be able to use all of the classes in the .NET Framework, including the classes available in RhinoCommon. As a matter of fact, if you look at the source for the rhinoscriptsyntax functions, they are just python scripts that use RhinoCommon. This allows you to do some pretty amazing things inside of a python script. Many of the features that once could only be done in a .NET plugin can now be done in a python script

For example, you can implement some custom drawing while a user is picking a point with the following script. This script draws a Red and Blue line connected to the point under the mouse cursor while the user is picking a point.


import Rhino
import System.Drawing

def GetPointDynamicDrawFunc( sender, args ):
 pt1 = Rhino.Geometry.Point3d(0,0,0)
 pt2 = Rhino.Geometry.Point3d(10,10,0)
 args.Display.DrawLine(pt1, args.CurrentPoint, System.Drawing.Color.Red, 2)
 args.Display.DrawLine(pt2, args.CurrentPoint, System.Drawing.Color.Blue, 2)

Create an instance of a GetPoint class and add a delegate for the DynamicDraw event
gp = Rhino.Input.Custom.GetPoint()
gp.DynamicDraw += GetPointDynamicDrawFunc
gp.Get()


Essential Code:
import Rhino
import System.Drawing

def GetPointDynamicDrawFunc( sender, args ):
  pt1 = Rhino.Geometry.Point3d(0,0,0)
  pt2 = Rhino.Geometry.Point3d(10,10,0)
  args.Display.DrawLine(pt1, args.CurrentPoint, System.Drawing.Color.Red, 2)
  args.Display.DrawLine(pt2, args.CurrentPoint, System.Drawing.Color.Blue, 2)

Create an instance of a GetPoint class and add a delegate for the DynamicDraw event
gp = Rhino.Input.Custom.GetPoint()
gp.DynamicDraw += GetPointDynamicDrawFunc
gp.Get()


GUIDES / RHINOPYTHON / WHAT-IS-RHINOPYTHON
------------------------------------------------------------

Index
Source: guides\rhinopython\what-is-rhinopython\index.md
Rhino.Python refers to the Python executables embedded in Rhino, and the associated Python code editors (aka. the ScriptEditor, in Rhino and Grasshopper). They let you write and run standard Python scripts in Rhino, to create interactive scripts, new custom commands, and many more. Currently Rhino supports IronPython 2.7, and CPython 3.9. The main Rhino APIs that are accessible through Rhino.Python are RhinoCommon and rhinoscriptsyntax.

What is Python?

Python is a modern programming language. Python is sometimes called a scripting language or a glue language. This means python is used often to run a series of commands as a script or used to create links between two other technologies as a glue. It is easier to learn and use than other non-scripting style, compiled languages like C#, VB, or C/C++. Yet it is quite powerful.

Python is interpreted, meaning it is executed one line at a time. This makes the program flow easy to understand. Also it is semantically dynamic which allows the syntax to be less restrictive and less formal when using declarations and variables types. These characteristics add to Python's ease-of-use for basic programming tasks.

You may need Python if you want to:
Automate a repetitive task in Rhino much faster than you could do manually.
Perform tasks in Rhino or Grasshopper that you don't have access to in the standard set of Rhino commands or Grasshopper components.
Generate geometry using algorithms.
Many, many other things. It is a programming language after all.

Why Python?

Why should you use Python? Well, Python is meant to be a simple language to read and write. Python also runs both the Windows and Mac versions of Rhino. Since Rhino Python scripting is available on both platforms, the same Python scripts can run on both breeds of Rhino! Python also will run within a Grasshopper component.

But more importantly: Python is very popular outside of Rhino! Much of what you learn about Python can be applied in many other domains.

Rhino ... [truncated]

GUIDES / RHINOPYTHON / YOUR-FIRST-PYTHON-SCRIPT-IN-RHINO-WINDOWS
------------------------------------------------------------

Index
Source: guides\rhinopython\your-first-python-script-in-rhino-windows\index.md
You will learn how to display a message box in Rhino that says "Hello World." It covers the most basic concepts for editing, loading, and running scripts.

The Complete Script


import rhinoscriptsyntax as rs

rs.MessageBox ("Hello World")

To test the Script:
Start Rhino
At the command prompt, type Scripteditor and press Enter.
The Script editor dialog box appears.
In the script Code window, type the code sample above.
Click the "Run the script" button.
The editor dialog box disappears, and the message below appears:

The HelloWorld Function

If you were writing a more complex script, and wanted to display "Hello World" at strategic points throughout the script, you could write this code every time you wanted the message to appear.

But if you changed your mind and wanted it to say "Howdy World" instead, you'd have to search for all the places "Hello World" was used, and replace them.

An easier way to solve this problem is to write a Function (def is used to define the function). At several places throughout your script, you call the function. The function handles displaying the message, so you only have to change the message in one place.

Here's what the function definition looks like:


import rhinoscriptsyntax as rs

def HelloWorld():
 rs.MessageBox ("Hello World")


If you click the run button at this time nothing will happen. Nothing happened? That's because the RhinoScript defined the Subroutine but did not actually call it. To call the subroutine, either add this line of code and click Run.

To call this function, simply add this to the bottom of the script:


HelloWorld()


In Python the functions definitions need to come before being called in the code.

Testing HelloWorld
At the command prompt, type ScriptEditor and press Enter.
The Scripteditor dialog box appears.
In the script Code window, type


import rhinoscriptsyntax as rs

def HelloWorld():
 rs.MessageBox ("Hello World")

HelloWorld()

Click the Run button.

When... [truncated]

Essential Code:
import rhinoscriptsyntax as rs

def HelloWorld():
    rs.MessageBox ("Hello World")

import rhinoscriptsyntax as rs

def HelloWorld():
    rs.MessageBox ("Hello World")

HelloWorld()


GUIDES / RHINOSCRIPT / ACCESSING-DATABASES
------------------------------------------------------------

Index
Source: guides\rhinoscript\accessing-databases\index.md
Overview

Probably the most popular use for VBScript is connecting to databases. It's incredibly useful and surprisingly easy.

The first thing you need is the database, of course. A variety of programs can be used to create it, but probably the most popular is Microsoft Access. You can also use FoxPro or create it directly in an SQL Server using whichever utilities are supplied with the server.

In this example, we will connect to a simple Microsoft Access database. You can download the database used in this demonstration here.

Most VBScript developers use Microsoft's ADO (ActiveX database objects) to get data from database. ADODB is comprised of 3 main objects: Connection, RecordSet, and Command. We will demonstrate the first two objects.

Connecting to a Database

The Datasource is essentially a connection from the server or workstation to a database, which can either be on a dedicated machine running SQL server or a database file sitting somewhere on the web server.

To specify what database you would like to use, you need to add a DSN. That is short for Data Source Name. Data Source Name provides connectivity to a database through an ODBC driver. The DSN contains database name, directory, database driver, UserID, password, and other information. Once you create a DSN for a particular database, you can use the DSN in an application to call information from the database.

There are essentially two types of Datasources (DSN's):
System DSN - A datasource created on the web server by the administrator of the server. T he most popular type of DSN and generally a lot more reliable.
File DSN - Essentially a connection that your script makes itself each time access to the database is required, specifying the path to and name of the database. The database must reside on the server in a directory that your script can access for this to work.

The code below is designed around a System DSN named “test” that points to the above database. You can create System DSNs using th... [truncated]

Essential Code:
Sub Test
   Const adOpenStatic = 3
   Const adLockOptimistic = 3
   Const adUseClient = 3

   Dim objConnection, objRecordset
   Set objConnection = CreateObject("ADODB.Connection")
   Set objRecordset = CreateObject("ADODB.Recordset")

   objConnection.Open "DSN=test;"
   objRecordset.CursorLocation = adUseClient
   objRecordset.Open "SELECT * FROM points" , objConnection, adOpenStatic, adLockOptimistic

   objRecordSet.MoveFirst

   Dim x, y, z
   Do Until objRecordset.EOF
    x = objRecordset.Fields.Item("x")
    y = objRecordset.Fields.Item("y")
    z = objRecordset.Fields.Item("z")
...

GUIDES / RHINOSCRIPT / ADDING-CURVATURE-CIRCLES
------------------------------------------------------------

Index
Source: guides\rhinoscript\adding-curvature-circles\index.md
Overview

Rhino's Curvature command is very useful for analyzing the curvature at a point on a curve. This script shows how to add the circle to the document when the curve is picked (instead of just drawing it dynamically).

There is no option on the Curvature command for leaving the circle that it draw dynamically. But, with the help of a script, you can write a subroutine that will. The following example demonstrates how to do just this.

Sample


Option Explicit

Sub CurvatureCircle
 Dim crv, crvpt, crvt
 Dim arr, crvpl, pl

 crv = Rhino.GetObject("Select curve for curvature measurement", 4, True)
 If IsNull(crv) Then Exit Sub

 Do 
 crvpt = Rhino.GetPointOnCurve(crv, "Select point on curve for curvature measurement")
 If IsNull(crvpt) Then Exit Do

 crvt = Rhino.CurveClosestPoint(crv, crvpt)
 If IsNull(crvt) Then Exit Do

 arr = Rhino.CurveCurvature(crv, crvt)
 If IsNull(arr) Then
 Rhino.Print("Unable to compute curve curvature.")
 Exit Do
 End If

 crvpl = Rhino.PlaneFromFrame(arr(0), arr(1), arr(4))
 pl = Rhino.MovePlane(crvpl, arr(2))

 Rhino.AddCircle pl, arr(3)
 Rhino.AddPoint arr(0)
 Loop While Not IsNull(crvpt)
End Sub


GUIDES / RHINOSCRIPT / ARCHIMEDIAN-SPIRALS
------------------------------------------------------------

Index
Source: guides\rhinoscript\archimedian-spirals\index.md
Overview

It is possible to define an Archimedean Spiral with polar coordinates. In polar coordinates {{}}$$(r, θ)$${{}}, an Archimedean Spiral can be described by the following equation:

{{}}$$r = a+bθ$${{}}

with real numbers {{}}$$a$${{}} and {{}}$$b$${{}}. Changing the parameter a will turn the spiral, while {{}}$$b$${{}} controls the distance between successive turnings...

!Archimedean Spiral

Sample

Once the polar coordinates have been calculated, we can use RhinoScript's Polar method to convert them to Cartesian coordinates, which will allow us to plot the curve using RhinoScript's AddInterpCurve method.

The following sample script code demonstrates how to create an interpolated curve through the points that were calculated using the above equation...


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
 ' ArchimedeanSpiral.rvb -- June 2008
 ' If this code works, it was written by Dale Fugier.
 ' If not, I don't know who wrote it.
 ' Works with Rhino 4.0.

 Option Explicit

 Sub ArchimedeanSpiral()

 Dim aconst, bconst, stepangle, numpoints
 Dim currangle, basepoint, radius, points(), i

 Rhino.Print "Archimedean Spiral (r = a + bθ)"

 aconst = Rhino.GetReal("Value of 'A' constant", 1.0, 0.01)
 If IsNull(aconst) Then Exit Sub

 bconst = Rhino.GetReal("Value of 'B' constant", 1.0, 0.01)
 If IsNull(aconst) Then Exit Sub

 numpoints = Rhino.GetInteger("Number of points to calculate", 10, 2)
 If IsNull(numpoints) Then Exit Sub

 stepangle = Rhino.GetReal("Angle between points", 30.0, 1.0, 45.0)
 If IsNull(stepangle) Then Exit Sub

 currangle = 0.0
 basepoint = Array(0.0, 0.0, 0.0)
 ReDim points(numpoints - 1)

 For i = 0 To UBound(points)
 radius = aconst + (bconst * currangle)
 points(i) = Rhino.Polar(basepoint, radius, currangle)
 currangle = currangle + step_angle
 Next

 Rhino.AddInterpCurve points
 'Rhino.AddPoints points

 End Sub


GUIDES / RHINOSCRIPT / ARRAY-BOUNDS
------------------------------------------------------------

Index
Source: guides\rhinoscript\array-bounds\index.md
Overview

In a two-dimensional array, how do you determine the upper bounds of the array for each dimension? Also, how do you handle jagged arrays? That is, an array whose elements themselves are arrays? How do I find the upper bounds of two, three, or n-dimensional array when the array is rectangular or jagged?

UBound

To determine the upper bounds of an array, use VBScript's UBound method. The UBound method returns the largest available subscript for the indicated dimension of an array. The syntax for UBound is:


UBound(arrayname [,dimension])


where...
arrayname (required) is the name of the array variable.
dimension (optional) is whole number indicating which dimension's upper bound is returned. Use 1 for the first dimension, 2 for the second, and so on. If dimension is omitted, 1 is assumed.

For example:


Dim A(100,3,4)
UBound(A) ' 100
UBound(A, 1) ' 100
UBound(A, 2) ' 3
UBound(A, 3) ' 4


Jagged Arrays

What if you do not know an array's dimensions, which might be the case with a jagged array? How do you know what dimension values are valid to pass to UBound?

VBScript does not have a function that returns the number of dimensions of an array. But, by using the UBound method and some simple error checking, we can write our own function that determines the number of dimension of an array.

Consider the following function:


'Description
' Returns the dimension of an array.
'Parameters
' arr - Name of the array variable.
'Returns
' The dimension of the array if successful.
' Null on error.
'
Function GetArrayDim(ByVal arr)
 GetArrayDim = Null
 Dim i
 If IsArray(arr) Then
 For i = 1 To 60
 On Error Resume Next
 UBound arr, i
 If Err.Number <> 0 Then
 GetArrayDim = i-1
 Exit Function
 End If
 Next
 GetArrayDim = i
 End If
End Function


GetArrayDim simply calls UBound with a different dimension parameter until an error is thrown. Note, since VBScript allows arrays of up to 60 dimensions, we must check up to this value.

Now that we have ... [truncated]

Essential Code:
'Description
'  Returns the dimension of an array.
'Parameters
'  arr - Name of the array variable.
'Returns
'  The dimension of the array if successful.
'  Null on error.
'
Function GetArrayDim(ByVal arr)
  GetArrayDim = Null
  Dim i
  If IsArray(arr) Then
    For i = 1 To 60
      On Error Resume Next
      UBound arr, i
      If Err.Number <> 0 Then
        GetArrayDim = i-1
        Exit Function
      End If
    Next
...
'Description
'  Safely returns the largest available subscript for
'  the indicated dimension of an array.
'Parameters
'  arr - Name of the array variable.
'  i   - Number indicating which dimension's upper bound to return.
'Returns
'  The upper bounds for the indicated dimension if successful.
'  Null on error.
'
Function GetArrayUBound(ByVal arr, ByVal i)
  GetArrayUBound = Null
  If IsArray(arr) Then
    On Error Resume Next
    b = UBound(arr, i)
    If Err.Number = 0 Then GetArrayUBound = b
  End If
End Function


GUIDES / RHINOSCRIPT / ARRAY-UTILITIES
------------------------------------------------------------

Index
Source: guides\rhinoscript\array-utilities\index.md
Overview

Arrays are a very useful and easy way of storing variables - and they're especially easy to use in VBScript. This is due to several factors:
VBScript is particularly liberal with any variable definition - that means that there is no strict defining of variables to a particular data type.
The data type is assigned automatically when the variable is loaded with a value.
It is even possible to mix data types within the same array.
It is also possible to define the arrays in different ways:
Create the array element by element.
Use the VBScript Array method.
Use the VBScript Split method.
It is even possible to create multi-dimensional arrays and to make them dynamic rather than static.

But, VBScript falls short, compared to other programming languages, when it comes to providing tools for manipulating arrays. Some common array operations that VBScript does not provide methods for are:
Adding a new elements to an array.
Appending one array to the end of another array.
Inserting new elements at given positions in an array.
Removing elements from an array.
Removing duplicate items from an array.
Sorting the elements in an array.
Reverse the order of the elements in an array.

For some of these tasks, RhinoScript does provide useful methods:
CullDuplicateNumbers - Remove duplicates from an array of numbers.
CullDuplicatePoints - Remove duplicates from an array of 3-D points.
CullDuplicateStrings - Remove duplicates from an array of strings.
SortNumbers - Sorts an array of numbers.
SortPoints - Sorts an array of 3-D points.
SortStrings - Sorts an array of strings.

For the other tasks, you will need to write your own procedures. Fortunately, VBScript provides us enough tools to write our own procedures to do most of what we would ever want to do with an array. Note,

Utilities

The following examples are general purpose utilities. If you need something more specific, these examples are a good starting point.

Add Elements At End

Add a new element to the end of an... [truncated]

Essential Code:
Function ArraySearch(ByRef arr, ByVal val)
  Dim i
  ArraySearch = -1
  If IsArray(arr) Then
    For i = 0 To UBound(arr)
      If arr(i) = val Then
        ArraySearch = i
        Exit Function
      End If
    Next
  End If
End Function

Function IsArrayDim(ByVal arr)
  IsArrayDim = False
  If IsArray(arr) Then
    On Error Resume Next
    Call UBound(arr)
    If Err.Number = 0 Then IsArrayDim = True
  End If
End Function


GUIDES / RHINOSCRIPT / BYREF-VS-BYVAL
------------------------------------------------------------

Index
Source: guides\rhinoscript\byref-vs-byval\index.md
Overview

There has always been confusion about what exactly ByRef and ByVal mean in VBScript. The confusion arises because VBScript uses “by reference” to mean two similar, but different things. VBScript supports:
Reference types
Variable references

The best way to illustrate the difference is with an example. Consider this class:


Class Foo
 Public Bar
End Class


Now we can create an instance of this class:


Dim Blah, Baz
Set Blah = New Foo
Set Baz = Blah
Blah.Bar = 123


Both Blah and Baz are references to the same object. The fourth line changes both Blah.Bar and Baz.Bar because these are different names for the same thing.

That's the “reference type” feature. We say that VBScript treats objects as reference types.

Now consider this little program:


Sub Change(ByRef XYZ)
 XYZ = 5
End Sub
Dim ABC
ABC = 123
Change ABC


This passes a reference to variable ABC. The local variable XYZ becomes an alias for ABC, so the assignment XYZ = 5 changes ABC as well.

Related Topics
Parentheses

Essential Code:
Class Foo
  Public Bar
End Class


GUIDES / RHINOSCRIPT / CALCULATING-PERMUTATIONS
------------------------------------------------------------

Index
Source: guides\rhinoscript\calculating-permutations\index.md
Overview

The permutation of a set is the number of ways that the items in the set can be uniquely ordered. For example, the permutations of the set {{}}$$\{1, 2, 3\}$${{}} are: {{}}$$\{1, 2, 3\}$${{}}, {{}}$$\{1, 3, 2\}$${{}}, {{}}$$\{2, 1, 3\}$${{}}, {{}}$$\{2, 3, 1\}$${{}}, {{}}$$\{3, 1, 2\}$${{}}, and {{}}$$\{3, 2, 1\}$${{}}.

For {{}}$$N$${{}} objects, the number of permutations is {{}}$$N$${{}} (N factorial, or {{}}$$1 2 3 N$${{}}).

Example

There are a number of methods for calculating permutation sets. The implementation below uses an ordered, or lexicographic, permutation algorithm. This algorithm is based on a a permutation algorithm from the book Practical Algorithms in C++ by Bryan Flamig.


Option Explicit

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' TestPermute - the Main subroutine
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub TestPermute
 Dim arr, n
 'arr = Array("One", "Two", "Three", "Four")
 'arr = Array(1, "Two", 3, "Four")
 arr = Array(1, 2, 3, 4)
 n = UBound(arr) + 1
 Rhino.ClearCommandHistory
 Call Rhino.Print(PermuteCount(n))
 Call Permute(arr, 0, n)
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Permute
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub Permute(ByRef arr, ByVal start, ByVal n)
 Dim i, j
 Call PermutePrint(arr)
 If (start < n) Then
 For i = n-2 To start Step -1
 For j = i+1 To n-1
 Call PermuteSwap(arr, i, j)
 Call Permute(arr, i+1, n)
 Next
 Call PermuteRotate(arr, i, n)
 Next
 End If
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' PermutePrint
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub PermutePrint(ByRef arr)
 Dim s, v
 s = ""
 For Each v In arr
 s = s & CStr(v) & vbTab
 Next
 Rhino.Print s
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' PermuteSwap
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub PermuteSwap(ByRef arr, ByVal i, ByVal j)
 Dim tmp
 tmp = arr(i)
 ar... [truncated]

Essential Code:
Option Explicit

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' TestPermute - the Main subroutine
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub TestPermute
  Dim arr, n
  'arr = Array("One", "Two", "Three", "Four")
  'arr = Array(1, "Two", 3, "Four")
  arr = Array(1, 2, 3, 4)
  n = UBound(arr) + 1
  Rhino.ClearCommandHistory
  Call Rhino.Print(PermuteCount(n))
  Call Permute(arr, 0, n)
End Sub

'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Permute
'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub Permute(ByRef arr, ByVal start, ByVal n)
...

GUIDES / RHINOSCRIPT / CANCELLING-SCRIPTS
------------------------------------------------------------

Index
Source: guides\rhinoscript\cancelling-scripts\index.md
Overview

When running a RhinoScript, it often occurs that a user wants to interrupt a running RhinoScript by pressing ESC. This most frequently happens when running a script with a tight loop or a recursive function. In order to cancel the script, we want to allow the user to press ESC, rather than having to stop Rhino using Task Manager and restart everything. There are two topics to cover: Sleep and OnCancelScript.

Sleep

If you have a tight loop that does not call back into Rhino, then it is possible for ESC key processing to be either very slow or not happen at all. This is because the tight loop does not allow Rhino to process the messages, such as keystrokes, sent to it by Windows.

To work around this situation, you will want to call back into Rhino inside of your tight loop. Using RhinoScript's Sleep function is a good way to do this without slowing down your code...


Sub TightLoopEscapeTest
 For i = 0 To 100000
 '
 ' Do tight loop processing here...
 '
 ' Allow Rhino to "pump" it's message queue
 Call Rhino.Sleep(0)
 Next
 End Sub


If your loop is relatively fast, you may want to postpone the Sleep call or else it will slow down your script significantly...


Sub TightLoopEscapeTest
 For i = 0 To 100000
 '
 ' Do tight loop processing here...
 '
 ' Allow Rhino to "pump" it's message queue
 If ((i Mod 25) = 0) Then Call Rhino.Sleep(0)
 Next
End Sub


...which will call the Sleep method only once every 25 iterations.

OnCancelScript

The default behavior when cancelling a script is to halt the script's execution and print a “Script cancelled” message to Rhino's command line. There are often times when you might want to know when your script is cancelled. For example, lets say you have a script that does the following steps in this order:
Modifies some Rhino parameters...
Performs an operation and...
Resets the modified parameters.

If your script is cancelled in operation (2), then Rhino can be left in a state unfamiliar to the user.

It is ... [truncated]

GUIDES / RHINOSCRIPT / CLOSEST-AXIS-POINT
------------------------------------------------------------

Index
Source: guides\rhinoscript\closest-axis-point\index.md
Problem

You have a bunch of 2-D curves that are planar to the world x-y plane, and you need to find a point in each curve that is closest to the world y-axis. For example:

!Closest Axis Point

What can you do to calculate this point?

Solution

After selecting the curves and verifying that they are both planar and line in the world x-y plane, calculate the world axis-aligned bounding box for each curve. Using the results of the bounding box calculation, create a line, using the first two points from the results, that is parallel to the world y-axis. Intersect this line with the curve. The results of the intersection will be at the point that is closest to the world y-axis.

The following example demonstrates the above algorithm...


Option Explicit

 Sub ClosestAxisPoint

 Dim arrCurves
 arrCurves = Rhino.GetObjects("Select planar curves", 4, True, True)
 If Not IsArray(arrCurves) Then Exit Sub

 Dim strCurve, arrPlane(3), arrBox, strLine, arrCCX
 arrPlane(0) = Array(0,0,0)
 arrPlane(1) = Array(1,0,0)
 arrPlane(2) = Array(0,1,0)
 arrPlane(3) = Array(0,0,1)

 Rhino.EnableRedraw False

 For Each strCurve In arrCurves
 If Rhino.IsCurvePlanar(strCurve) Then
 If Rhino.IsCurveInPlane(strCurve, arrPlane) Then
 arrBox = Rhino.BoundingBox(strCurve)
 strLine = Rhino.AddLine(arrBox(0), arrBox(1))
 arrCCX = Rhino.CurveCurveIntersection(strCurve, strLine)
 If IsArray(arrCCX) Then
 Rhino.AddPoint arrCCX(0,1)
 End If
 Rhino.DeleteObject strLine
 End If
 End If
 Next

 Rhino.EnableRedraw True 

 End Sub


GUIDES / RHINOSCRIPT / COMPARING-ARRAYS
------------------------------------------------------------

Index
Source: guides\rhinoscript\comparing-arrays\index.md
Slow Comparison

Imagine you have two collections of items and you want to determine how many of those items have the same name. In short, you want to compare the contents of two arrays. Consider this straightforward method of comparison:


intSame = 0
For Each strFirst In arrFirst
 For Each strSecond In arrSecond
 If StrComp(strFirst, strSecond, vbTextCompare) = 0 Then
 intSame = intSame + 1
 Exit For
 End If
 Next
Next


This method, although simple, is extremely slow. Let's say there are 5000 items in arrFirst, 3000 items in arrSecond, and 1500 of them have the same value. Every one of the 3500 unsuccessful searches checks all 3000 arrSecond items, and the 1500 successful searches on average check 1500 arrSecond items each. Each time through, the inner loop does one loop iteration and one string comparison. Add all those up and you get millions of function calls to determine this count. Now, each individual function call is only taking a few microseconds, but all of these calls add up!

There is another way...

Fast Comparison

Try building a faster lookup table rather than doing a full search through the collection every time.


Set objLookup = CreateObject("Scripting.Dictionary")
For Each strFirst In arrFirst
 Call objLookup.Add(strFirst, 0) ' 0 = some useless value
Next
For Each strSecond In arrSecond
 If objLookup.Exists(strSecond) Then intSame = intSame + 1
Next


This is only a couple of thousand function calls. So we believe that this will be much, much faster.

Related Topics
Array Bounds
Array Utilities
VBScript Dictionaries
VBScript Looping

GUIDES / RHINOSCRIPT / CONVERTING-GUIDS-TO-STRINGS
------------------------------------------------------------

Index
Source: guides\rhinoscript\converting-guids-to-strings\index.md
Problem

If you have written a RhinoScript function which calls a method on a COM object that return an array of bytes with a GUID, you will likely want to convert this GUID into a string. Converting GUIDs to strings is possible, but it takes a little work.

Solution

The logical format of a GUID in memory is not in the same order as the bytes are in the string. A GUID stored in binary format in memory is a sixteen byte structure in the following format:

DWORD-WORD-WORD-BYTE BYTE-BYTE BYTE BYTE BYTE BYTE BYTE

Where a WORD consists of two bytes and a DWORD consists of four bytes. They are stored in memory in order from the least to the most significant, or “little endian”, on Intel-based systems. So, you need to make sure you decode the array in the correct order

The following example RhinoScript code demonstrates how to convert an array of bytes containing a GUID to a string.


' Returns single digit bytes, like 0, as "00", not "0"
Function HexByte(b)
 HexByte = Right("0" & Hex(b), 2)
End Function

' Converts a GUID to a string
Function GuidToString(ByteArray)
 Dim Binary, S
 Binary = CStr(ByteArray)
 ' Uncomment if you want opening paren
 ' S = "{"
 S = S & HexByte(AscB(MidB(Binary, 4, 1)))
 S = S & HexByte(AscB(MidB(Binary, 3, 1)))
 S = S & HexByte(AscB(MidB(Binary, 2, 1)))
 S = S & HexByte(AscB(MidB(Binary, 1, 1)))
 S = S & "-" 
 S = S & HexByte(AscB(MidB(Binary, 6, 1)))
 S = S & HexByte(AscB(MidB(Binary, 5, 1)))
 S = S & "-" 
 S = S & HexByte(AscB(MidB(Binary, 8, 1)))
 S = S & HexByte(AscB(MidB(Binary, 7, 1)))
 S = S & "-" 
 S = S & HexByte(AscB(MidB(Binary, 9, 1)))
 S = S & HexByte(AscB(MidB(Binary, 10, 1)))
 S = S & "-" 
 S = S & HexByte(AscB(MidB(Binary, 11, 1)))
 S = S & HexByte(AscB(MidB(Binary, 12, 1)))
 S = S & HexByte(AscB(MidB(Binary, 13, 1)))
 S = S & HexByte(AscB(MidB(Binary, 14, 1)))
 S = S & HexByte(AscB(MidB(Binary, 15, 1)))
 S = S & HexByte(AscB(MidB(Binary, 16, 1)))
 ' Uncomment if you want closing paren
 ' S = S & "}"
 GuidToString = S... [truncated]

Essential Code:
' Returns single digit bytes, like 0, as "00", not "0"
Function HexByte(b)
  HexByte = Right("0" & Hex(b), 2)
End Function

' Converts a GUID to a string
Function GuidToString(ByteArray)
  Dim Binary, S
  Binary = CStr(ByteArray)
  ' Uncomment if you want opening paren
  ' S = "{"
  S = S & HexByte(AscB(MidB(Binary, 4, 1)))
  S = S & HexByte(AscB(MidB(Binary, 3, 1)))
  S = S & HexByte(AscB(MidB(Binary, 2, 1)))
  S = S & HexByte(AscB(MidB(Binary, 1, 1)))
  S = S & "-"  
  S = S & HexByte(AscB(MidB(Binary, 6, 1)))
  S = S & HexByte(AscB(MidB(Binary, 5, 1)))
  S = S & "-"  
  S = S & HexByte(AscB(MidB(Binary, 8, 1)))
...

GUIDES / RHINOSCRIPT / CONVERTING-TEXT-TO-GEOMETRY
------------------------------------------------------------

Index
Source: guides\rhinoscript\converting-text-to-geometry\index.md
Problem

You have many text elements that you would like to convert to text objects (geometry) for engraving. You can explode a text element and get curves that outline the text. The problem is, when you change a text element to a single stroke font, it automatically closes each letter/number and is unreadable. The only way you have been able to make a single stroke font work is by creating geometry using Rhino's TextObject command. However, because you have so many text elements it would take forever to remake geometry for each of them. It is possible to write a script to automate this.

Solution

The following script demonstrates how to convert text elements to text objects (geometry). In this sample, text objects (geometry) are created with the identical properties, such as font, height, bold, and italics, as the text element. 


'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ConvertTextToGeometry.rvb -- September 2008
' If this code works, it was written by Dale Fugier.
' If not, I don't know who wrote it.
' Works with Rhino 4.0.

Option Explicit

Sub ConvertTextToGeometry

 ' Declare local variables
 Dim objlist, obj, savedplane, cmd
 Dim font, height, plane, style, text, bold, italic

 ' Select annotation objects
 objlist = Rhino.GetObjects("Select text to convert to geometry", 512, True, True)
 If Not IsArray(objlist) Then Exit Sub

 ' For speed, turn of screen redrawing
 Call Rhino.EnableRedraw(False)

 ' Save the current construction plane
 savedplane = Rhino.ViewCPlane()

 ' Process each selected object
 For Each obj In objlist

 ' Weed out just the text objects
 If Rhino.IsText(obj) Then

 ' Acquire the text parameters
 font = Rhino.TextObjectFont(obj)
 height = Rhino.TextObjectHeight(obj)
 plane = Rhino.TextObjectPlane(obj)
 style = Rhino.TextObjectStyle(obj)
 text = Rhino.TextObjectText(obj)

 If (style And 1) Then
 bold = "Yes"
 Else
 bold = "No"
 End If

 If (style And 2) Then
 italic = "Yes"
 Else
 italic = "No... [truncated]

GUIDES / RHINOSCRIPT / CONVERTING-TO-GRAYSCALE
------------------------------------------------------------

Index
Source: guides\rhinoscript\converting-to-grayscale\index.md
Overview

To convert any color to a grayscale representation of its luminance, first one must obtain the values of its red, green, and blue (RGB) primaries in linear intensity encoding, by gamma expansion. Then, add together 30% of the red value, 59% of the green value, and 11% of the blue value. The resultant number is the desired linear luminance value; it typically needs to be gamma compressed to get back to a conventional grayscale representation.

Example

The following example demonstrates the above algorithm...


Option Explicit

Sub ConvertLayersToGrayscale()

 ' Declare local variables
 Dim arrLayers, strLayer, lngColor
 Dim nGray, nRed, nGreen, nBlue

 ' Turn off screen redrawing (for performance)
 Call Rhino.EnableRedraw(False)

 ' Get all of the layers in the document
 arrLayers = Rhino.LayerNames

 ' Process each layer one-by-one
 For Each strLayer In arrLayers

 ' Get the layer's color
 lngColor = Rhino.LayerColor(strLayer)

 ' Get the color's red-green-blue components
 nRed = Rhino.ColorRedValue(lngColor)
 nGreen = Rhino.ColorGreenValue(lngColor)
 nBlue = Rhino.ColorBlueValue(lngColor)

 ' Calculate the grayscale based on the NTSC color gamut
 nGray = CByte(nRed 0.30) + CByte(nGreen 0.59) + CByte(nBlue * 0.11)

 ' Modify the layer's color
 Call Rhino.LayerColor(strlayer, RGB(nGray, nGray, nGray))

 Next

 ' Turn on screen redrawing
 Call Rhino.EnableRedraw(True)

End Sub


GUIDES / RHINOSCRIPT / COPYING-TO-EXCEL
------------------------------------------------------------

Index
Source: guides\rhinoscript\copying-to-excel\index.md
Overview

You can copy information from Rhino and then paste it into Excel. The real question is "what do you want to copy and paste?"

Copying information from Rhino and pasting it into Excel is fairly easy using RhinoScript. All you have to do is use the ClipboardText method to copy a text string into the Windows Clipboard. Then from Excel, just select the cell and paste.

Details

If you want to copy the string “Hello from Rhino!” into Excel, your script could be as simple as this:


Call Rhino.ClipboardText("Hello from Rhino!")


Easy enough. But, what if you want to copy some delimited data so each "token" appears in a different column in Excel when pasted. Then, simply separate each token with a tab, or vbTab, character. For example:


Call Rhino.ClipboardText("A" & vbTab & "B" & vbTab & "C" & vbTab & "1" & vbTab & "2" & vbTab & "3")


Likewise, if you want to copy some delimited data so each "token" appears in a different row in Excel when pasted, then separate each token with a line-feed, or vbLf, character. For example:


Call Rhino.ClipboardText("A" & vbLf & "B" & vbLf & "C" & vbLf & "1" & vbLf & "2" & vbLf & "3")


You can get more elaborate by creating a formatted string that contains both tab and line-feed characters. In this example, we will copy something useful - curve lengths in this example...


Sub CopyClipCrvLength()
 Dim curves, crv, length, str
 curves = Rhino.GetObjects("Select curves to copy length", 4, True, True)
 If IsArray(curves) Then
 str = str & "Id" & vbTab & "Length" & vbLf
 For Each crv In curves
 length = Rhino.CurveLength(crv)
 str = str & crv & vbTab & CStr(length) & vbLf
 Next
 Call Rhino.ClipboardText(str)
 End If 
End Sub


Now that you have the basic idea, you should be able to write your own scripts that copy any type of data you want from Rhino into Excel.

Related Topics
Reading Excel Files
Automating Excel From RhinoScript (Sample)
Automating Curve Properties to Excel From RhinoScript (Sample... [truncated]

GUIDES / RHINOSCRIPT / CREATING-GUIDS
------------------------------------------------------------

Index
Source: guides\rhinoscript\creating-guids\index.md
Overview

Globally Unique Identifiers - or GUIDs - are unique identification numbers that are used to track items. Rhino uses GUIDs just for this purpose. GUIDs come in different formats, but are usually stored as 128-bit values, and are commonly displayed as 32 hexadecimal digits with groups separated by hyphens:

{3AEC4721-34KP-3152-B2BB-17442C41208P}

Let's write a script that creates GUIDs...

GUID Generation

There is actually a very easy way to generate GUIDs. The Scriptlet.TypeLib object includes a method that generates GUIDs. If you need a GUID, here is a short script that will supply you with one:


' Creates a Registry-formatted GUID string
' Ex: {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
Function CreateGuidRegistryFormat
 Dim objTypeLib
 Set objTypeLib = CreateObject("Scriptlet.TypeLib")
 CreateGuidRegistryFormat = Left(objTypeLib.Guid, 38)
End Function


If you want to create a plain GUID - one without the surrounding curly brackets, then you can do something like this:


' Creates a plain-formatted GUID string
' Ex: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
Function CreateGuidPlainFormat
 Dim objTypeLib
 Set objTypeLib = CreateObject("Scriptlet.TypeLib")
 CreateGuidPlainFormat = Mid(objTypeLib.Guid, 2, 36)
End Function


Related Topics
Globally Unique Identifier (Wikipedia)
Converting GUIDs to Strings

Essential Code:
' Creates a Registry-formatted GUID string
' Ex: {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
Function CreateGuidRegistryFormat
  Dim objTypeLib
  Set objTypeLib = CreateObject("Scriptlet.TypeLib")
  CreateGuidRegistryFormat = Left(objTypeLib.Guid, 38)
End Function

' Creates a plain-formatted GUID string
' Ex: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
Function CreateGuidPlainFormat
  Dim objTypeLib
  Set objTypeLib = CreateObject("Scriptlet.TypeLib")
  CreateGuidPlainFormat = Mid(objTypeLib.Guid, 2, 36)
End Function


GUIDES / RHINOSCRIPT / CURVE-OSCULATING-PLANES
------------------------------------------------------------

Index
Source: guides\rhinoscript\curve-osculating-planes\index.md
Problem

Is it possible to calculate the osculating plane at point {{}}$$P$${{}} on a given curve with the methods provided by RhinoScript?

Solution

Yes. There are a number of methods included in RhinoScript that can be used to calculate a curve's osculating plane, such as CurveClosestPoint, CurveTangent, CurveCurvature, and CurveEvaluate. In this example, we will use the CurveEvaluate function to calculate the 2nd derivative of a curve at a parameter...


Function CurveOsculatingPlane(crv, t)
 CurveOsculatingPlane = Null ' default return value
 If Not Rhino.IsCurveLinear(crv) Then
 Dim rc : rc = Rhino.CurveEvaluate(crv, t, 2)
 If IsArray(rc) Then
 CurveOsculatingPlane = Rhino.PlaneFromFrame(rc(0), rc(1), rc(2))
 End If
 End If
End Function


The following is an example of how you might use this function...


Sub TestCurveOsculatingPlane
 Dim segs : segs = 10
 Dim crv : crv = Rhino.GetObject("Select non-linear curve", 4)
 If Not IsNull(crv) Then
 Dim pts : pts = Rhino.DivideCurve(crv, segs)
 If IsArray(pts) Then
 Dim i, t, p
 For i = 0 To UBound(pts)
 t = Rhino.CurveClosestPoint(crv, pts(i))
 p = CurveOsculatingPlane(crv, t)
 Rhino.AddPlaneSurface p, 1.0, 1.0
 Next
 End If
 End If
End Sub


Essential Code:
Function CurveOsculatingPlane(crv, t)
  CurveOsculatingPlane = Null ' default return value
  If Not Rhino.IsCurveLinear(crv) Then
    Dim rc : rc = Rhino.CurveEvaluate(crv, t, 2)
    If IsArray(rc) Then
      CurveOsculatingPlane = Rhino.PlaneFromFrame(rc(0), rc(1), rc(2))
    End If
  End If
End Function


GUIDES / RHINOSCRIPT / DISCONNECTED-RECORDSET-SORTING
------------------------------------------------------------

Index
Source: guides\rhinoscript\disconnected-recordset-sorting\index.md
Overview

If you are dealing with data which requires more than just key-value pairs and fits best in 2-D array, and you wanted to perform sorting and filtering ... [compressed]GUIDES / RHINOSCRIPT / PARENTHESES
------------------------------------------------------------

Index
Source: guides\rhinoscript\parentheses\index.md
Problem

Every now and then, you may get the error message "Cannot use parentheses when calling a Sub" when calling a function or method. This does not happen all the time. For example, the following code appears to work:


Result = MyFunc(MyArg)
MySub(MyArg)


...but this code does not work:


Result = MyOtherFunc(MyArg1, MyArg2)
MyOtherSub(MyArg1, MyArg2)


Solution

In VBScript, parentheses mean several different things:

Evaluate a subexpression before the rest of the expression. For example:


Average = (First + Last) / 2


or...

Dereference the index of an array. For example:


Item = MyArray(Index)


or...

Call a function or subroutine. For example:


Limit = UBound(MyArray)


or...

Pass an argument which would normally be ByRef as ByVal. For example...


'Arg1 is passed ByRef, Arg2 is passed ByVal.
Result = MyFunction(Arg1, (Arg2))


And, there are additional rules that apply when calling a function or subroutine...

An argument list for a function call with an assignment to the returned value must be surrounded by parentheses. For example:


Result = MyFunc(MyArg)


An argument list for a subroutine call, or a function call with no assignment, that uses the Call keyword must be surrounded by parentheses. For example:


Call MySub(MyArg)


If the above two rules do not apply, then the list must not be surrounded by parentheses.

Finally, there is the ByRef rule: arguments are passed ByRef when possible. But, if there are extra parentheses around a variable, then the variable is passed ByVal, not ByRef.

From these rules, it should be clear why the statement MySub(MyArg) is legal but MyOtherSub(MyArg1, MyArg2) is not. The first case appears to be a subroutine call with parentheses around the argument list, but that would violate the rules. Then why does this work? In fact, it is a subroutine call with no parentheses around the argument list, but parentheses around the first argument. This passes the ... [truncated]

Essential Code:
'Arg1 is passed ByRef, Arg2 is passed ByVal.
Result = MyFunction(Arg1, (Arg2))


GUIDES / RHINOSCRIPT / PARSING-TEXT-FILES
------------------------------------------------------------

Index
Source: guides\rhinoscript\parsing-text-files\index.md
Problem

A frequent workflow is using a text file - generated outside Rhino - to change a Rhino model. You may know how to read in a text file and parse it with VBScript, but what about parsing the text file and assigning the values as a variable?

Solution

Consider the following VBScript subroutine that reads a text file:


Sub ReadTextFile
 Dim objFSO, objFile, strFileName, strLine
 Const ForReading = 1

 strFileName = Rhino.OpenFileName("Open", "Text Files (.txt) .txt ")
 If IsNull(strFileName) Then Exit Sub

 Set objFSO = CreateObject("Scripting.FileSystemObject")
 Set objFile = objFSO.OpenTextFile(strFileName, ForReading)

 While Not objFile.AtEndOfStream
 strLine = objFile.ReadLine
 Rhino.Print strLine
 Wend

 objFile.Close
 Set objFSO = Nothing

End Sub


Note how every line read from the text file is assigned to the strLine variable before it is printed.

Everything read from a text file using VBScript comes in as a string data type. If you want something that you have read to be an integer or a floating point number, then you need to convert the string to that data type. For example, if you have a text file:


7
3.14159
Hello Rhino!


If you use VBScript to read this file, all three lines are read in as strings. If you want line one read as an integer and line read as a double, then you can use some of VBScript's data conversion functions to convert the string to the proper data type. For example:


Dim nFirst, dblSecond, strThird
nFirst = CInt(objFile.ReadLine)
dblSecond = CDbl(objFile.ReadLine)
strThird = objFile.ReadLine


 If you don't know what kind of data is on each line, then consider exporting a data type identifier along with the data from the program that generated the file. This way, when you read a line from VBScript, you will know what kind of data you have.

VBScript's VarType function will return a value indicating the t... [truncated]

GUIDES / RHINOSCRIPT / PERSISTENT-SETTINGS
------------------------------------------------------------

Index
Source: guides\rhinoscript\persistent-settings\index.md
Problem

It can be annoying to enter the same custom parameter each time you run a script. 

Solution

The following script demonstrates how to use a private variable to store a parameter during a Rhino session.


' How to script with persisting settings
' Jess Maertterer - 20.12.2004
Option Explicit
Private dblLength

If IsEmpty(dblLength) Then
 dblLength = 2.00
End If

'/////////////////////////////////////////////////////////////
Sub ExtendCurveLength_Persist
 Dim arrCurves, strCurve, dblResult
 arrCurves = Rhino.GetObjects("Select curves to extend", 4)
 If Not IsNull(arrCurves) Then
 dblResult = Rhino.GetReal("Length to extend", dblLength,0.00)
 If Not IsNull(dblResult) Then
 dblLength = dblResult
 For Each strCurve in arrCurves
 Rhino.ExtendCurveLength strCurve, 2, 2, dblLength
 Next
 End If
 End If
End Sub


If your script should remember the settings from the last session, then you have to use the RhinoScript methods SaveSettings and GetSettings to access a separate .ini file.

Essential Code:
' How to script with persisting settings
' Jess Maertterer - 20.12.2004
Option Explicit
Private dblLength

If IsEmpty(dblLength) Then
  dblLength = 2.00
End If

'/////////////////////////////////////////////////////////////
Sub Extend_Curve_Length_Persist
  Dim arrCurves, strCurve, dblResult
  arrCurves = Rhino.GetObjects("Select curves to extend", 4)
  If Not IsNull(arrCurves) Then
    dblResult = Rhino.GetReal("Length to extend", dblLength,0.00)
    If Not IsNull(dblResult) Then
      dblLength = dblResult
      For Each strCurve in arrCurves
        Rhino.ExtendCurveLength strCurve, 2, 2, dblLength
      Next
...

GUIDES / RHINOSCRIPT / PRIMER-101 / 1-WHATS-IT-ALL-ABOUT
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\1-whats-it-all-about\index.md
1.1 Macros

Rhinoceros is based on a command-line interface. This means you can control it by using only the keyboard. You type in the commands and the program will execute them. Ever since the advent of the mouse, a user interface which is purely command-line based is considered to be primitive, and rightly so. Instead of typing:


Line 0,0,0 10,0,0


you can equally well click on the Line button and then twice in the viewport to define the starting and ending points of a line-curve. Because of this second (graphical) interface some people have done away with the
command-line entirely. Emotions run high on the subject; some users are command-line fanatics, others use only toolbars and menus. Programmers have no emotions in this respect, they are all wedded to the command-line. It’s no use programming the mouse to go to a certain coordinate and then simulate a mouse click, that is just plain silly. Programmers pump text into Rhino and they expect to get text in return.

The lowest form of programming in Rhino is using macros. I do not wish to offend those of you who write macros for a living, but it cannot be denied that it is a very primitive way to automate processes. I shall only briefly pause at the subject of macros, partly so we know which is which and partly because we might at some point simulate macros using RhinoScript.

A macro is a prerecorded list of orders for Rhino to execute. The Line command at the top of this page is an example of a very simple macro. If your job is to open Rhino files, add a line from 0,0,0 to 10,0,0 to each one and save the file again, you would probably get very tired very quickly from typing "Line w0,0,0 w10,0,0" six times a minute. Enter macros. Macros allow you to automate tasks you would normally do by hand but not by brain. Macros cannot be made smart, nor do they react to the things they help create. They’re a bit like traffic wardens in that respect. An example of a more sophisticated macro would be:


 SelNone
 Polyg... [truncated]

GUIDES / RHINOSCRIPT / PRIMER-101 / 2-VBSCRIPT-ESSENTIALS
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\2-vbscript-essentials\index.md
2.1 Language Origin

Like conversational languages, programming languages group together in clusters. There are language families and language generations. VBScript is a member of the BASIC language family which in turn is a third generation group. ‘Third generation’ indicates that the language was designed to be easy for humans to understand. First and second generation languages (often referred to as machine-code), are most definitely not easy to understand. Just so you know the difference between second and third generation code, here is an example of second generation assembly:

 mov [ebx], ecx 
 add ebx, 4 
 loop initloop 
 push dword FirstMsg 
 call puts 
 pop ecx 
 push dword 10 
 push dword array 
 call printarray 
 add esp, 8 

Lucky us.

Incidentally, BASIC stands for Beginner’s All-purpose Symbolic Instruction Code and was first developed in 1963 in order to drag non-science students into programming. As you can see above, even assembly already makes heavy use of English vocabulary but although we are familiar with the words, it is not possible for laymen to decipher the commands. Assuming that you might be reading these pages without any prior programming experience whatsoever, I still dare guess that the following example will not give you much problems:


somenumber = Rhino.GetReal("Line length")
line = Rhino.AddLine(Array(0,0,0), Array(somenumber,0,0))
If IsNull(line) Then
 Rhino.Print "Something went wrong"
Else
 Rhino.Print "Line curve inserted"
End If


Of course you might have no conception of what Array(0,0,0) actually means and you might be confused by Rhino.GetNumber(0) or IsNull(), but on the whole it is pretty much the same as the English you use at the grocers:

Ask Rhino to assign a number to something called 'somenumber'.
Tell Rhino to add a line from the world origin to the point on the x-axis indicated by 'somenumber'
If the result of the previous operation was not a curve object,
then print a failure message
otherwise print a success... [truncated]

GUIDES / RHINOSCRIPT / PRIMER-101 / 3-SCRIPT-ANATOMY
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\3-script-anatomy\index.md
3.1 Programming in Rhino

Rhinoceros offers various ways of programmatic access. We've already met macros and scripts, but the plot thickens. Please invest a few moments of your life into looking at the diagram below, which you will never be asked to reproduce:

{{}}

The above is a complete breakdown of all developer tools that Rhino has to offer. I'll give you a brief introduction as to what this diagram actually represents and although that is not vital information for our primary goal here ("learning how to script" in case you were wondering), you might as well familiarize yourself with it so you have something to talk about on a first date.

At the very core of Rhino are the code libraries. These are essentially collections of procedures and objects which are used to make life easier for the programs that link to them. The most famous one is the openNURBS library which was developed by Robert McNeel & Associates but is competely open source and has been ported by 3rd party programmers to other operating systems such as Unix and Linux. OpenNURBS provides all the required file writing and reading methods as well the basic geometry library. Practically all the 3D applications that support the 3dm file format use the openNURBS library. These code libraries have no knowledge of Rhino at all, they are 'upstream' so to speak.

Rhino itself (the red blob) is tightly wrapped around these core libraries, it both implements and extends them. Apart from this obvious behaviour, Rhino also adds the possibility of plugins. Whereas most companies provide plugin support for 3rd party developers, McNeel has taken a rather exotic approach which elimates several big problems. The technical term for this approach is "eating your own dogfood" and it essentially boils down to McNeel programmers using the same tools as 3rd party programmers. Rather than adding code to Rhino itself, McNeel programmers prefer writing a plugin instead. For one, if they screw up the collateral damage is u... [truncated]

Essential Code:
Option Explicit						         < Option Explicit statement
Script written by David Rutten on 28-08-2006  < Default comments

Public intCount						         < A Global variable

Call Main()						             < Main function call
Sub Main()						             < Main function declaration
	Dim strInfo						         < Main function start
	strInfo = "This is just a test"	  
	Rhino.Print strInfo				
	Rhino.Print "I repeat: " \& strInfo  
End Sub							             < Main function end


GUIDES / RHINOSCRIPT / PRIMER-101 / 4-OPERATORS-AND-FUNCTIONS
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\4-operators-and-functions\index.md
4.1 What on Earth are they and why should I care?

When we were discussing numeric variables in paragraph 2.3.1, there was an example about mathematical operations on numbers:


x = 15 + 26 2.33
x = math.sin(15 + 26) + math.sqrt(2.33)
x = math.tan(15 + 26) / math.log(55)


The four lines of code above contain four kinds of code:
Numbers 15, 26, 2.33 and 55
Variables x
Operators =, +, and /
Functions math.sin(), math.sqrt(), math.tan() and math.log()

Numbers and variables are well behind us now. Arithmetic operators should be familiar from everyday life, VBScript uses them in the same way as you used to during math classes. VBScript comes with a limited amount of arithmetic operators and they are always positioned between two variables or constants (a constant is a fixed number).

{{}}

Now, that looks really scary doesn't it? I am always amazed at how good people are in finding expensive words for simple things. There's nothing to be afraid about though, I'll talk you through the hardest bits and when were done with this chapter, you can impress the living daylights out of any non-programmer by throwing these terms into casual conversation.

4.2 Careful...

As you take a closer look at the tables on the opposite page, you'll notice that the + and the = operator occur twice. The way they behave depends on where you put them, which I can't help but feel was a silly choice to make, even in 1963. Especially the assignment/equals operator can be confusing. If you want to assign a value to a variable called x, you use the following code:


x = SomethingOrOther


But if you want to check if x equals SomethingOrOther you use very identical syntax:


If x = SomethingOrOther Then…


In the second line, the value of x will not change. Java and C programmers are always scornful when they see such careless treatment of the equals operator, and for once they may be right.

Another thing to watch out for is operator precedence. As you will remember from math classes,... [truncated]

Essential Code:
Rhino.GetObject ([strMessage [, intType [, blnPreSelect [, blnSelect [, arrObjects ]]]]])

Returns:
String		» The identifier of the picked object if successful.
Null		» If not successful, or on error.

Function Alphabet()
    Dim strSeries
    strSeries = "abcdefghijklmnopqrstuvwxyz"
End Function


GUIDES / RHINOSCRIPT / PRIMER-101 / 5-CONDITIONAL-EXECUTION
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\5-conditional-execution\index.md
5.1 What if?

What if I were to fling this rock at that bear? What if I were to alleviate that moose from its skin and wear it myself instead? It's questions like these that signify abstract thought, perhaps the most stunning of all human traits. It's no good actually throwing rocks at bears by the way, you're only going to upset it and severely diminish your chances of getting back to your cave by nightfall in one piece. As a programmer, you need to take abstract though to the next level; the very-very-conscious level.

A major part of programming is recovering from screw-ups. A piece of code does not always behave in a straightforward manner and we need to catch these aberrations before they propagate too far. At other times we design our code to deal with more than one situation. In any case, there's always a lot of conditional evaluation going on, a lot of 'what if' questions. Let's take a look at three conditionals of varying complexity:
If the object is a curve, delete it.
If the object is a short curve, delete it.
If the object is a short curve, delete it, otherwise move it to the "curves" layer.

The first conditional statement evaluates a single boolean value; an object is either is a curve or it is not. There's no middle ground. The second conditional must also evaluate the constraint 'short'. Curves don't become short all of a sudden any more than people grow tall all of a sudden. We need to come up with a boolean way of talking about 'short' before we can evaluate it. The third conditional is identical to the second one, except it defines more behavioural patterns depending on the outcome of the evaluation.

The translation from English into VBScript is not very difficult. We just need to learn how conditional syntax works.

Problem 1:


If Rhino.IsCurve(strObjectID) Then
 Call Rhino.DeleteObject(strObjectID)
End If

Problem 2:


If Rhino.IsCurve(strObjectID) Then
 If Rhino.CurveLength(strObjectID) }}

If SomethingOrOther Then
 DoSomething()
 Do... [truncated]

GUIDES / RHINOSCRIPT / PRIMER-101 / 6-ARRAYS
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\6-arrays\index.md
6.1 My Favorite Things

We've already been using arrays in examples and I've always told you not to worry about it. Those days are officially over. Now is the time to panic. Perhaps it's best if we just get the obvious stuff out of the way first:

An array is a list of variables

That's really all there is to it. Sometimes -in fact quite often- you want to store large or unknown amounts of variables. You could of course declare 15,000 different variables by hand but that is generally considered to be bad practise. The only thing about arrays which will seem odd at first is the way they count. Arrays start counting at zero, while we are used to start counting at one. Try it by counting the number of fingers on your right hand. Chances are you are someone who has just counted to five. Arrays would disagree with you, they would only have counted to four:

{{}}

It helps to refer to numbers as 'indices' when you use the zero-based counting system just to avoid confusion. So when we talk about the 'first element' of an array, we actually mean 'the element with index 0'. I know this all sounds like Teaching Granny To Suck Eggs, but zero-based counting systems habitually confuse even the most die-hard programmer.

Arrays are just like other variables in VBScript with the exception that we have to use parenthesis to set and retrieve values:


'Normal variable declaration, assignment and retrieval
Dim intNumber
intNumber = 8
Call Rhino.Print(intNumber)

'Array declaration, assignment and retrieval
Dim arrNumbers(2)
arrNumbers(0) = 8
arrNumbers(1) = -5
arrNumbers(2) = 47
Call Rhino.Print(arrNumbers(0) & ", " & arrNumber(1) & ", " & arrNumbers(2))


The example above shows how to declare an array which is capable of storing 3 numbers (indices 0, 1 and 2). In cases like this (when you know in advance how many and which numbers you want to assign) you can also use a shorthand notation in which case you have to omit the parenthesis in the variable declaration:


Dim arrNu... [truncated]

Essential Code:
Function AddVector(ByVal vecDir, ByVal ptBase)
    On Error Resume Next
    AddVector = Null

    If IsNull(ptBase) Or Not IsArray(ptBase) Then
        ptBase = Array(0,0,0)
    End If

    Dim ptTip
    ptTip = Rhino.PointAdd(ptBase, vecDir)
    If Not (Err.Number = 0) Then Exit Function

    AddVector = Rhino.AddLine(ptBase, ptTip)
    If Not (Err.Number = 0) Then Exit Function
    If IsNull(AddVector) Then Exit Function

    Call Rhino.CurveArrows(AddVector, 2)
End Function

Function SmoothingVector(ByVal P, ByVal Pprev, ByVal Pnext, ByVal s)
    Dim Pm(2), i

    For i = 0 To 2
        Pm(i) = (Pprev(i) + Pnext(i)) / 2.0
    Next

    Dim Va, Vm
    Va = Rhino.VectorCreate(Pm, P)
    Vm = Rhino.VectorScale(Va, s)

    SmoothingVector = Vm
End Function


GUIDES / RHINOSCRIPT / PRIMER-101 / 7-GEOMETRY
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\7-geometry\index.md
7.1 The openNURBS™ Kernel

Now that you are familiar with the basics of scripting, it is time to start with the actual geometry part of RhinoScript. To keep things interesting we've used plenty of Rhino methods in examples before now, but that was all peanuts. Now you will embark upon that great journey which, if you survive, will turn you into a real 3D geek.

As already mentioned in Chapter 3, Rhinoceros is build upon the openNURBS™ kernel which supplies the bulk of the geometry and file I/O functions. All plugins that deal with geometry tap into this rich resource and the RhinoScript plugin is no exception. Although Rhino is marketed as a "NURBS modeler for Windows", it does have a basic understanding of other types of geometry as well. Some of these are available to the general Rhino user, others are only available to programmers. As a RhinoScripter you will not be dealing directly with any
openNURBS™ code since RhinoScript wraps it all up into an easy-to-swallow package. However, programmers need to have a much higher level of comprehension than users which is why we'll dig fairly deep.

7.2 Objects in Rhino

All objects in Rhino are composed of a geometry part and an attribute part. There are quite a few different geometry types but the attributes always follow the same format. The attributes store information such as object name, colour, layer, isocurve density, linetype and so on and so forth. Not all attributes make sense for all geometry types, points for example do not use linetypes or materials but they are capable of storing this information nevertheless. Most attributes and properties are fairly straightforward and can be read and assigned to objects at will.

{{}}

This table lists most of the attributes and properties which are available to plugin developers. Most of these have been wrapped in the RhinoScript plugin, others are missing at this point in time and the custom user data element is special. We'll get to user data after we're done with the ... [truncated]

Essential Code:
Sub Main()
    Dim strCurveID
    strCurveID = Rhino.GetObject("Select a curve to sample", 4, True, True)
    If IsNull(strCurveID) Then Exit Sub

    Dim t
    Call Rhino.EnableRedraw(False)
    For t = 0.0 To 1.0 Step 0.002
        Call AddPointAtR1Parameter(strCurveID, t)
    Next
    Call Rhino.EnableRedraw(True)
End Sub

Function AddPointAtR1Parameter(strCurveID, dblUnitParameter)
    AddPointAtR1Parameter = Null

    Dim crvDomain : crvDomain = Rhino.CurveDomain(strCurveID)
    If IsNull(crvDomain) Then Exit Function

    Dim dblR1Param
...
Sub Main()
    Dim strSurfaceID
    strSurfaceID = Rhino.GetObject("Select a surface to sample", 8, True)
    If IsNull(strSurfaceID) Then Exit Sub

    Dim strCurveID
    strCurveID = Rhino.GetObject("Select a curve to measure", 4, True, True)
    If IsNull(strCurveID) Then Exit Sub

    Dim arrPts : arrPts = Rhino.DivideCurve(strCurveID, 500)
    Dim i

    Call Rhino.EnableRedraw(False)
    For i = 0 To UBound(arrPts)
        Call EvaluateDeviation(strSurfaceID, 1.0, arrPts(i))
    Next
    Call Rhino.EnableRedraw(True)
End Sub

Function EvaluateDeviation(strSurfaceID, dblThreshold, arrSample)
...

GUIDES / RHINOSCRIPT / PRIMER-101 / WHERE-TO-FIND-HELP
------------------------------------------------------------

Index
Source: guides\rhinoscript\primer-101\where-to-find-help\index.md
Forums

The RhinoScript community is very active and offers a wonderful resource for posting questions/answers and finding help on just about anything!:
https://discourse.mcneel.com/c/scripting

Related Topics
Where to find help - Next Topic >>

GUIDES / RHINOSCRIPT / QUADRATIC-SOLVER
------------------------------------------------------------

Index
Source: guides\rhinoscript\quadratic-solver\index.md
Problem

If you are trying to solve quadratic equations like:

{{}}$${-b \pm \sqrt{b^2 - 4ac} \over 2a }$${{}}

the results may seem incorrect at times.

Solution

Most likely, the problem that is that there are floating point rounding errors. Being that you only get 15 decimal places of accuracy, you can use them all up if you are dealing with small numbers.

The following algorithm should produce more accurate results:


Function QuadraticSolver(a, b, c)
 Dim d, s0, s1
 d = b b - 4 a c
 If d < 0 Then
 ' No real solution
 QuadraticSolver = Null
 Else
 s0 = (-b - Sqr(d)) / (2 a)
 s1 = (-b + Sqr(d)) / (2 a)
 If Abs(s0) < Abs(s1) Then s0 = s1
 s1 = c / (a s0)
 QuadraticSolver = Array(s0,s1)
 End If
End Function


Essential Code:
Function QuadraticSolver(a, b, c)
  Dim d, s0, s1
  d = b * b - 4 * a * c
  If d < 0 Then
    ' No real solution
    QuadraticSolver = Null
  Else
    s0 = (-b - Sqr(d)) / (2 * a)
    s1 = (-b + Sqr(d)) / (2 * a)
    If Abs(s0) < Abs(s1) Then s0 = s1
    s1 = c / (a * s0)
    QuadraticSolver = Array(s0,s1)
  End If
End Function


GUIDES / RHINOSCRIPT / QUICK-SORT-KEY-VALUE-PAIR
------------------------------------------------------------

Index
Source: guides\rhinoscript\quick-sort-key-value-pair\index.md
Overview

The .NET Framework's SortedList class provides a hash table with automatically sorted key-value pairs. The available methods and properties for SortedList are very similar to the ones available in ArrayList.

The following sample code creates a SortedList and populates it with some key-value pairs:


Set SortedList = CreateObject("System.Collections.Sortedlist")
SortedList.Add "First", "Hello"
SortedList.Add "Second", ","
SortedList.Add "Third", "Rhino"
SortedList.Add "Fourth", "!"

For i = 0 To SortedList.Count - 1
 Rhino.Print SortedList.GetKey(i) & vbTab & SortedList.GetByIndex(i)
Next


 It is not possible to sort the list by values.

Quick Sort

VBScript and RhinoScript do not expose procedures for sorting multiple arrays. The .NET framework does, but only a single Key-Value pair. The algorithm outlined on below can be easily extended to work for any number of value arrays. It is a standard implementation of the QuickSort algorithm.

QuickSort works through a Divide and Conquer approach and it's one of the fastest sorting algorithms available. However, this implementation uses the recursive approach which may result in stack overflow errors on large datasets. QuickSort works best on randomized arrays, if the array is already almost sorted the solution will take more steps.

This implementation comes as a collection of three procedures, but it can be easily packaged into one.

First, the big one. This is the actual recursive algorithm:


Sub QuickSort(ByRef A(), ByRef B(), ByVal min, ByVal max)
 Dim i : i = min
 Dim k : k = max

 If (max - min) >= 1 Then
 Dim pivot : pivot = A(min)

 While (k > i)
 While (A(i) i)
 i = i+1
 Wend

 While (A(k) > pivot And k >= min And k >= i)
 k = k-1
 Wend

 If (k > i) Then Call SwapElements(A, B, i, k)
 Wend

 Call SwapElements(A, B, min, k)
 Call QuickSort(A, B, min, k-1)
 Call QuickSort(A, B, k+1, max)
 End If
End Sub


It depends on the SwapElement() subrou... [truncated]

Essential Code:
Function SortByKey(ByRef Keys(), ByRef Values())
  Call QuickSort(Keys, Values, 0, Ubound(Keys))
End Function


GUIDES / RHINOSCRIPT / READ-WRITE-UTF8
------------------------------------------------------------

Index
Source: guides\rhinoscript\read-write-utf8\index.md
Problem

If you have a text file saved as UTF-8, sometimes - when you read the file - it reads in weird characters and not the correct characters. This happens often when the files contain Chinese characters. How can you make it read the correct characters?

Solution

The File System Object.aspx), generally used by VBScript developers to read and write text files, can read only ASCII or Unicode text files. You cannot use it to read or write UTF-8 encoded text files.

But, if you can use Microsoft ActiveX Data Objects (ADO), you can read UTF-8 encoded text files like this:


Dim objStream, strData
Set objStream = CreateObject("ADODB.Stream")
objStream.CharSet = "utf-8"
objStream.Open
objStream.LoadFromFile("C:\Users\admin\Desktop\test.txt")
strData = objStream.ReadText()


If you want to write a UTF-8 encode text file, you can do so like this:


Dim objStream
Set objStream = CreateObject("ADODB.Stream")
objStream.CharSet = "utf-8"
objStream.Open
objStream.WriteText "The data I want in utf-8"
objStream.SaveToFile "C:\Users\admin\Desktop\test.txt", 2


Related Topics
File System Object on MSDN.aspx)
Microsoft ActiveX Data Objects (ADO) on MSDN

GUIDES / RHINOSCRIPT / READING-EXCEL-FILES
------------------------------------------------------------

Index
Source: guides\rhinoscript\reading-excel-files\index.md
Problem

You would like to read a Microsoft Excel file from RhinoScript into an array that can be accessed in Rhino.

Solution

The following general purpose function will read an Excel worksheet into a two-dimensional array...


' Description:
' Reads a Microsoft Excel file.
' Parameters:
' strFile - [in] The name of the Excel file to read.
' Returns:
' A two-dimension array of cell values, if successful.
' Null on error
Option Explicit

Function ReadExcelFile(ByVal strFile)

 ' Local variable declarations
 Dim objExcel, objSheet, objCells
 Dim nUsedRows, nUsedCols, nTop, nLeft, nRow, nCol
 Dim arrSheet()

 ' Default return value
 ReadExcelFile = Null

 ' Create the Excel object
 On Error Resume Next
 Set objExcel = CreateObject("Excel.Application")
 If (Err.Number <> 0) Then
 Exit Function
 End If

 ' Don't display any alert messages
 objExcel.DisplayAlerts = 0 

 ' Open the document as read-only
 On Error Resume Next
 Call objExcel.Workbooks.Open(strFile, False, True)
 If (Err.Number <> 0) Then
 Exit Function
 End If

 ' If you wanted to read all sheets, you could call
 ' objExcel.Worksheets.Count to get the number of sheets
 ' and the loop through each one. But in this example, we
 ' will just read the first sheet.
 Set objSheet = objExcel.ActiveWorkbook.Worksheets(1)

 ' Get the number of used rows
 nUsedRows = objSheet.UsedRange.Rows.Count

 ' Get the number of used columns
 nUsedCols = objSheet.UsedRange.Columns.Count

 ' Get the topmost row that has data
 nTop = objSheet.UsedRange.Row

 ' Get leftmost column that has data
 nLeft = objSheet.UsedRange.Column

 ' Get the used cells
 Set objCells = objSheet.Cells

 ' Dimension the sheet array
 ReDim arrSheet(nUsedRows - 1, nUsedCols - 1)

 ' Loop through each row
 For nRow = 0 To (nUsedRows - 1)
 ' Loop through each column
 For nCol = 0 To (nUsedCols - 1)
 ' Add the cell value to the sheet array
 arrSheet(nRow, nCol) = objCells(nRow + nTop, nCol + nLeft).Value
 Next
 Next

 ' Close the workbook without sa... [truncated]

Essential Code:
' Description:
'   Reads a Microsoft Excel file.
' Parameters:
'   strFile - [in] The name of the Excel file to read.
' Returns:
'   A two-dimension array of cell values, if successful.
'   Null on error
Option Explicit

Function ReadExcelFile(ByVal strFile)

  ' Local variable declarations
  Dim objExcel, objSheet, objCells
  Dim nUsedRows, nUsedCols, nTop, nLeft, nRow, nCol
  Dim arrSheet()

  ' Default return value
  ReadExcelFile = Null

  ' Create the Excel object
...

GUIDES / RHINOSCRIPT / REPLACING-POINTS-WITH-BLOCKS
------------------------------------------------------------

Index
Source: guides\rhinoscript\replacing-points-with-blocks\index.md
Problem

Imagine you have a number of point objects in your model and you would like to replace them with a block so they appear as markers. How can this be done without running the Insert command a bunch of times?

Solution

The following sample code demonstrates how to replace point objects with block objects using RhinoScript...


' Replaces points with blocks
Sub ReplacePointsWithBlocks

 ' Select points to replace with a block
 Dim arrObjects
 arrObjects = Rhino.GetObjects("Select points to replace with a block", 1, True, True)
 If Not IsArray(arrObjects) Then Exit Sub

 ' Get the names of all block definitions in the document 
 Dim arrBlocks
 arrBlocks = Rhino.BlockNames(True)
 If Not IsArray(arrBlocks) Then
 Rhino.Print "No block definitions found in the document."
 Exit Sub
 End If

 ' Select a block name from a list
 Dim strBlock
 strBlock = Rhino.ListBox(arrBlocks, "Select block", "Replace Points")
 If IsNull(strBlock) Then Exit Sub

 ' Turn off redrawing (faster)
 Rhino.EnableRedraw True 

 ' Process each selected point object
 Dim strObject, arrPoint
 For Each strObject In arrObjects
 ' Get the point object's coordinates
 arrPoint = Rhino.PointCoordinates(strObject)
 ' Insert the block at that location
 Rhino.InsertBlock strBlock, arrPoint
 Next

 ' Delete all of the point objects
 Rhino.DeleteObjects arrObjects 

 ' Turn redrawing back on 
 Rhino.EnableRedraw True 

End Sub


Inverse

The following script will do just the opposite - it will replace block objects with point objects...


' Replaces blocks with points
Sub ReplaceBlocksWithPoints

 ' Select blocks to replace with points
 Dim arrObjects
 arrObjects = Rhino.GetObjects("Select blocks to replace with points", 4096, True, True)
 If Not IsArray(arrObjects) Then Exit Sub

 ' Turn off redrawing (faster)
 Rhino.EnableRedraw True 

 ' Process each selected block object
 Dim strObject, arrPoint
 For Each strObject In arrObjects
 ' Get the block's insertion point
 arrPoint = Rhino.BlockIn... [truncated]

GUIDES / RHINOSCRIPT / REVERSING-ARRAYS
------------------------------------------------------------

Index
Source: guides\rhinoscript\reversing-arrays\index.md
Problem

How does one quickly reverse the order of the elements in an array?

Solution

Consider the following subroutine:


Sub ReverseArray(ByRef arr)

 Dim i, j, last, half, temp
 last = UBound(arr)
 half = Int(last/2)

 For i = 0 To half
 temp = arr(i)
 arr(i) = arr(last-i)
 arr(last-i) = temp
 Next

End Sub


...which can be used as follows:


Sub Main()

 Dim arr, i
 arr = Array(1,2,3)

 For i = 0 To UBound(arr)
 Rhino.Print arr(i)
 Next

 Call ReverseArray(arr)

 For i = 0 To UBound(arr)
 Rhino.Print arr(i)
 Next

End Sub


GUIDES / RHINOSCRIPT / ROUNDING-NUMBERS
------------------------------------------------------------

Index
Source: guides\rhinoscript\rounding-numbers\index.md
Overview

You need to round when you want to convert a number of greater precision into a number of lesser precision. The most common case is when you need to convert a floating-point number into an integer. There are many different types of rounding: rounding up, rounding down, banker's rounding. This guide covers many of the common rounding methods and demonstrates those that can be done in VBScript.

Rounding Down

The simplest form of rounding is truncation. Any digits after the desired precision are simply ignored. The Fix function is an example of truncation. For example:


Rhino.Print Fix( 3.5) ' 3
Rhino.Print Fix(-3.5) ' -3


The Int function rounds down to the highest integer less than the value. Both Int and Fix act the same way with positive numbers - truncating - but give different results for negative numbers:


Rhino.Print Int( 3.5) ' 3
Rhino.Print Int(-3.5) ' -4


The Fix function is an example of symmetric rounding because it affects the magnitude (absolute value) of positive and negative numbers in the same way. The Int function is an example of asymmetric rounding because it affects the magnitude of positive and negative numbers differently.

RhinoScript has a Floor function that truncates positive values, but does not work with negative numbers:


Rhino.Print Rhino.Floor( 3.5) ' 3
Rhino.Print Rhino.Floor(-3.5) ' -4


Rounding Up

RhinoScript has a Ceil function which always rounds fraction values up (more positive) to the next value.


Rhino.Print Rhino.Ceil( 3.5) ' 4
Rhino.Print Rhino.Ceil(-3.5) ' -3


VBScript does not have a corresponding round-up function. However, for negative numbers, both Fix and Int can be used to round upward, in different ways.

Fix rounds towards 0 (up in the absolute sense, but down in absolute magnitude):


Rhino.Print Fix( 3.5) ' 3
Rhino.Print Fix(-3.5) ' -3


Int rounds away from 0 (up in terms of absolute magnitude, but down in the absolute sense):


Rhino.Print Int( 3.5) '... [truncated]

Essential Code:
' Function:
'   RoundToNearest
' Description
'   Rounds a number by an increment
' Parameters:
'   Amt (Number) - number to round
'   RoundAmt (Number) - increment to which Amt will be rounded
'   bRoundUp (Boolean) - rounding direction (up or down)
'
Function RoundToNearest(Amt, RoundAmt, bRoundUp)
  On Error Resume Next
  Dim Temp : Temp = Amt / RoundAmt
  If Int(Temp) = Temp Then
    RoundToNearest = Amt
  Else
    If (bRoundUp = True) Then
     Temp = Int(Temp) + 1
    Else
     Temp = Int(Temp)
    End If
...
' Asymmetrically rounds numbers down - similar to Int().
' Negative numbers get more negative.
Function AsymDown(X, Factor)
  AsymDown = Int(X * Factor) / Factor
End Function

' Symmetrically rounds numbers down - similar to Fix().
' Truncates all numbers toward 0.
' Same as AsymDown for positive numbers.
Function SymDown(X, Factor)
  SymDown = Fix(X * Factor) / Factor
End Function

' Asymmetrically rounds numbers fractions up.
' Same as SymDown for negative numbers.
' Similar to Rhino.Ceil().
Function AsymUp(X, Factor)
  Dim Temp
  Temp = Int(X * Factor)
  AsymUp = (Temp + IIf(X = Temp, 0, 1)) / Factor
...

GUIDES / RHINOSCRIPT / RUNNING-SCRIPTS-FROM-MACROS
------------------------------------------------------------

Index
Source: guides\rhinoscript\running-scripts-from-macros\index.md
How To

Creating button or alias for your macro or script

The simplest way to save and run your macro is from a toolbar button or alias. If you don’t know how to make a new toolbar button or alias, look in the Help file. There’s a good explanation. Once you have your new button (or have chosen to edit an existing one), open the editor by shift+right-clicking on the button. For an alias, you will do the same thing, but instead of creating a new button, go into Options > Aliases and use the New button to create a new alias.

Use the macro editor to work out new macros

The MacroEditor command opens a text editing window in which you can type macros and try them out without the need to edit a button every time. The run button on the lower edge of the editor runs the macro. If there is selected text, it runs the selected text. When it all runs to your satisfaction, copy and paste the macro to a toolbar button.

!Macro Editor

Paste your macro or script into the button or alias

Now, there are two ways to approach associating the macro or script to your button or alias. First and simplest is to just copy/paste the whole thing into the left or right button box (or in the alias box). The advantage of the button method is that it is portable. That is, if you copy or export the button to another installation the macro goes with it. Once the test is pasted in, click OK to exit the button editor, and you’re ready to go!

The paste-in-button (or alias) method is fine for macros of Rhino commands and shorter, smaller scripts, but it gets a bit unwieldy to edit if there is a great deal of text. For larger scripts, some people like to place them externally in a folder with a link so that Rhino can find them. Both toolbar buttons and aliases can link to external scripts. One advantage of this system is that all scripts are located in one spot so you can easily find and update them. The problem here is that if you copy your button or workspace for use somewhere else, you have to re... [truncated]

GUIDES / RHINOSCRIPT / SAVING-FILE-SUMMARY-INFO
------------------------------------------------------------

Index
Source: guides\rhinoscript\saving-file-summary-info\index.md
Problem

When you right-click on a file, using Windows Explorer, and pick “Properties...”, to bring up the File Properties dialog, you can add summary information to a file by clicking on the Summary tab and entering the appropriate information. Imagine you would like to do this when saving Rhino files. Rhino does not have this capability, but RhinoScript can help.

Solution

The following example script will save the Rhino file by scripting Rhino's Save command. If the command was successful in saving the file, script will then display the File Properties dialog and display the summary information for that file...


Sub SuperSaver()
 Rhino.Command "_Save"
 If (0 = Rhino.LastCommandResult()) Then
 Dim objShell, objFolder, objFolderItem, objInfo
 Set objShell = CreateObject("Shell.Application")
 Set objFolder = objShell.NameSpace(Rhino.DocumentPath)
 If (Not objFolder Is Nothing) Then
 Set objFolderItem = objFolder.ParseName(Rhino.DocumentName)
 If (Not objFolderItem Is Nothing) Then
 Call objFolderItem.InvokeVerbEx("properties", "summary")
 End If
 Set objFolderItem = Nothing
 End If
 Set objFolder = Nothing
 Set objShell = Nothing
 End If
End Sub


GUIDES / RHINOSCRIPT / SCRIPT-DEMAND-LOAD
------------------------------------------------------------

Index
Source: guides\rhinoscript\script-demand-load\index.md
Overview

The following RhinoScript example presents an organized and efficient method for loading and running all of the script that you have either written or accumulated.

The following example below demonstrates how to write a single startup script that can load and run any of your scripts on demand.

Details

The Startup.rvb sample script, below, defines two special subroutines:
DemandRun checks for the existence of a user-defined subroutine. If the subroutine is not found, then script file, where the procedure is located, is loaded by running the LoadScript command. Finally, the specified procedure is called.
DemandRegister registers command aliases that run macros that utilize the DemandRun subroutine.
At the bottom of the script file, you can “register” one or more command aliases and specify the scripts they will run.

When Rhino starts and this script file is loaded, all of your command aliases are registered. But, none of your script files are loaded (except for the one and only Startup.rvb). It is not until you run a command alias is the script actually loaded. If you re-run the command alias, the script is not reloaded, but just run (since it is already loaded). Since scripts are only loaded as needed, you are not loading up a bunch of scripts that you will never use, thus conserving memory and allowing Rhino to load faster.


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Startup.rvb -- September 2010
' If this code works, it was written by Dale Fugier.
' If not, I don't know who wrote it.
' Works with Rhino 4.0 and 5.0.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Option Explicit

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Description:
' Demand loads and runs a script.
' Parameters:
' subroutine [in] - The name of the script subroutine to run.
' filename [in] - The name of the file were the subroutine
' is located.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
S... [truncated]

Essential Code:
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Startup.rvb -- September 2010
' If this code works, it was written by Dale Fugier.
' If not, I don't know who wrote it.
' Works with Rhino 4.0 and 5.0.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

Option Explicit

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Description:
'   Demand loads and runs a script.
' Parameters:
'   subroutine [in] - The name of the script subroutine to run.
'   filename   [in] - The name of the file were the subroutine
'                     is located.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub DemandRun(ByVal subroutine, ByVal filename)
  Dim macro
  macro = "_-LoadScript " & QuoteString(filename)
...

GUIDES / RHINOSCRIPT / SCRIPTING-METHODS-FOR-RDK
------------------------------------------------------------

Index
Source: guides\rhinoscript\scripting-methods-for-rdk\index.md
Overview

To get a scripting object for the Rhino RDK, use the following code:


Dim rdk
Set rdk = Rhino.GetPlugInObject("Renderer Development Kit")


Then use the RDK object to access the functions below...

Functions

FactoryList();
Return a list of RDK's content factory collection.

Returns: Array of strings identifying the factory.

ContentList(strContentType)
Returns a list of contents for a certain type: material, texture, environment.

Parameters: strContentType = Required. String. Type of content: material, texture or environment.
Returns: Array of strings identifying the content. NULL in error conditions.

DeleteFactory(strFactoryId)
Deletes a content factory by its identifier.

Parameters: strFactoryId = Required. String. The identifier of the factory to delete.
Returns: Boolean True or false indicating success or failure. NULL in error conditions.

FactoryKind(strFactoryId)
Returns the kind of the content.

Parameters: strFactoryId = Required. String. The identifier of the factory.
Returns: String of the kind of the factory. NULL in error conditions.

FactoryNewContent(strFactoryId, strParentId)
Create a new content of the specified type.

Parameters:
strFactoryId = Required. String. The identifier of the factory.
strParentId = Optional. String. The identifier of the parent content.
Returns: String which identifies new content. NULL in error conditions.

FactoryContentTypeId(strFactoryId)
Returns the identifier of the content type.

Parameters: strFactoryId = Required. String. The identifier of the factory.
Returns: String which identifies the factory. NULL in error conditions.

FactoryContentInternalName(strFactoryId)
Returns the internal name of the content created by specified factory.

Parameters: strFactoryId = Required. String. The identifier of the factory.
Returns: String which is the internal name of the factory. NULL in error conditions.

FactoryRenderEngineId(strFactoryId)
Returns the render engine id of the content that this factory pr... [truncated]

GUIDES / RHINOSCRIPT / SELECTING-CURVES-BY-TYPE
------------------------------------------------------------

Index
Source: guides\rhinoscript\selecting-curves-by-type\index.md
Non-Linear Curves

The following RhinoScript subroutine will select all non-linear curves in the document:


Sub SelNonLinearCrv()
 Dim arrCurves, strCurve
 arrCurves = Rhino.ObjectsByType(4)
 If IsArray(arrCurves) Then
 Rhino.EnableRedraw False
 For Each strCurve In arrCurves
 If Not Rhino.IsCurveLinear(strCurve) Then
 Rhino.SelectObject strCurve
 End If
 Next
 Rhino.EnableRedraw True
 End If
End Sub


Linear Curves

The following RhinoScript subroutine will select all linear curves in the document:


Sub SelLinearCrv()
 Dim arrCurves, strCurve
 arrCurves = Rhino.ObjectsByType(4)
 If IsArray(arrCurves) Then
 Rhino.EnableRedraw False
 For Each strCurve In arrCurves
 If Rhino.IsCurveL
 inear(strCurve) Then
 Rhino.SelectObject strCurve
 End If
 Next
 Rhino.EnableRedraw True
 End If
End Sub


GUIDES / RHINOSCRIPT / SHORTEST-LINE
------------------------------------------------------------

Index
Source: guides\rhinoscript\shortest-line\index.md
Overview

Two lines in three dimensions generally do not intersect at a point. They may be parallel (no intersections) or they may be coincident (infinite intersections) but most often only their projection onto a plane intersects. When they do not exactly intersect at a point they can be connected by a line segment, the shortest line segment is unique and is often considered to be their intersection in 3D.

Example

The following example code demonstrates how to calculate the shortest line between two line segments using RhinoScript...


Option Explicit

' Description:
' Returns the shortest line segment between
' two infinite line segments.
' Parameters:
' p1 - the starting point of the first line
' p2 - the ending point of the first line
' p3 - the starting point of the second line
' p4 - the ending point of the second line
' Returns
' Array - the shortest line segment if successful
' Null - if not successful or on error

Function LineLineIntersect(p1, p2, p3, p4)

 LineLineIntersect = Null

 Const EPS = 2.2204460492503131e-016 
 Dim p13(2), p43(2), p21(2)
 Dim d1343, d4321, d1321, d4343, d2121, numer, denom, mua, mub
 Dim pa(2), pb(2)

 p13(0) = p1(0) - p3(0)
 p13(1) = p1(1) - p3(1)
 p13(2) = p1(2) - p3(2)
 p43(0) = p4(0) - p3(0)
 p43(1) = p4(1) - p3(1)
 p43(2) = p4(2) - p3(2)

 If Abs(p43(0)) < EPS And Abs(p43(1)) < EPS And Abs(p43(2)) < EPS Then Exit Function

 p21(0) = p2(0) - p1(0)
 p21(1) = p2(1) - p1(1)
 p21(2) = p2(2) - p1(2)

 If Abs(p21(0)) < EPS And Abs(p21(1)) < EPS And Abs(p21(2)) < EPS Then Exit Function

 d1343 = p13(0) p43(0) + p13(1) p43(1) + p13(2) p43(2)
 d4321 = p43(0) p21(0) + p43(1) p21(1) + p43(2) p21(2)
 d1321 = p13(0) p21(0) + p13(1) p21(1) + p13(2) p21(2)
 d4343 = p43(0) p43(0) + p43(1) p43(1) + p43(2) p43(2)
 d2121 = p21(0) p21(0) + p21(1) p21(1) + p21(2) p21(2)

 denom = d2121 d4343 - d4321 d4321
 If Abs(denom) < EPS Then Exit Function

 numer = d1343 d4321 - d1321 d4343
 mua = numer / denom
 mub = (d1343 + d4321 mua) / d4343

 ... [truncated]

Essential Code:
Option Explicit

' Description:
'   Returns the shortest line segment between
'   two infinite line segments.
' Parameters:
'   p1 - the starting point of the first line
'   p2 - the ending point of the first line
'   p3 - the starting point of the second line
'   p4 - the ending point of the second line
' Returns
'   Array - the shortest line segment if successful
'   Null - if not successful or on error

Function LineLineIntersect(p1, p2, p3, p4)

  LineLineIntersect = Null

  Const EPS = 2.2204460492503131e-016  
  Dim p13(2), p43(2), p21(2)
...

GUIDES / RHINOSCRIPT / SKIPPING-ITERATIONS-FOR-LOOP
------------------------------------------------------------

Index
Source: guides\rhinoscript\skipping-iterations-for-loop\index.md
Problem

Both the C++ and C# programming languages have a  statement that, when used with a For loop, skips the remaining statements of that iteration and moves on to next iteration. Does VBScript have anything like this?

Solution

There is no  or continue-like statement in VBScript. But using a Do While loop inside of a For Each statement, you can achieve the same functionality. For example:


For i = 0 To 10
 Do
 If i = 4 Then Exit Do
 Rhino.Print i
 Loop While False
Next

Here is another example:

Sub TestContinue

 Dim arrTests, arrTest

 arrTests = Array( 
 Array(1) 
 , Array(1,2,3 ) 
 , Array(1,2) 
 , Array(1) 
 , Array(1,2,3) 
 )

 For Each arrTest In arrTests
 Call Rhino.Print("Process: {" & Join(arrTest, ", ") & "}")
 Do While True ' Continue trick
 Call Rhino.Print(" Process: " & arrTest(0))
 If 0 = UBound(arrTest) Then Exit Do ' Continue
 Call Rhino.Print(" Process: " & arrTest(1))
 If 1 = UBound(arrTest) Then Exit Do ' Continue
 Call Rhino.Print(" Process: " & arrTest(2))
 Exit Do
 Loop
 Next

End Sub


GUIDES / RHINOSCRIPT / SORTING-VBS-ARRAYS-WITH-NET
------------------------------------------------------------

Index
Source: guides\rhinoscript\sorting-vbs-arrays-with-net\index.md
Overview

One of the big limitations in VBScript is that there is no easy way to sort a list of items. To put a list in alphabetical order requires you to either use the pre-canned RhinoScript methods, such as SortNumbers, SortPoints or SortStrings, or write a sorting function of your own, like the following bubble sort code:


For i = (UBound(arrNames) - 1) to 0 Step -1
 For j= 0 to i
 If UCase(arrNames(j)) >
 UCase(arrNames(j+1)) Then
 strHolder = arrNames(j+1)
 arrNames(j+1) = arrNames(j)
 arrNames(j) = strHolder
 End If
 Next
Next


Discussion

There is anothe... [compressed]USERLISTMAX
NEWLINE


While this is still an acceptable way to identify your constants, you may want to use an alternative naming scheme now that you can create true constants using the Const statement. This convention uses a mixed-case format in which constant names have a "con" prefix. For example:


conYourOwnConstant


Variable Naming

To enhance readability and consistency, use the following prefixes with descriptive names for variables in your VBScript code:

 Subtype Prefix Example 

 Array arr arrLayers 
 Boolean bln blnFound 
 Byte byt bytRasterData 
 Date (Time) dtm dtmStart 
 Double dbl dblTolerance 
 Error err errOrderNum 
 Integer int intQuantity 
 Long lng lngDistance 
 Object obj objCurrent 
 Single sng sngAverage 
 String str strFirstName 

Variable Scope

Variables should always be defined with the smallest scope possible. VBScript variables can have the following scope:

 Scope Where Variable Is Declared Visibility 

 Procedure-level Event, Function, or Sub procedure. Visible in the procedure in which it is declared. 
 Sc... [truncated]

Essential Code:
'****************************************************
' Purpose: Locates the first occurrence of a specified
'          layer in the LayerList array.
' Inputs:  arrLayerList: the list of layers to be searched.
'          strTargetLayer: the name of the layer to search for.
' Returns: The index of the first occurrence of the
'          strTargetLayer in the strLayerList array.
'          If the target layer is not found, return -1.
'****************************************************

Option Explicit

Function FindLayer(arrLayerList, strTargetLayer)
  Dim i          ' Loop counter.
  Dim blnFound   ' Target found flag
  FindLayer = -1 ' Default return value
  i = 0          ' Initialize loop counter
  Do While i <= UBound(arrLayerList) And Not blnFound
    If arrLayerList(i) = strTargetLayer Then
      blnFound = True ' Set flag to True
...

GUIDES / RHINOSCRIPT / VBSCRIPT-CONDITIONALS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-conditionals\index.md
Overview

You can control the flow of your script with conditional statements and looping statements. Using conditional statements, you can write VBScript code that makes decisions and repeats actions. The following conditional statements are available in VBScript:
If...Then...Else statement
Select Case statement

If Then Else

The If...Then...Else statement is used to evaluate whether a condition is True or False and, depending on the result, to specify one or more statements to run. Usually the condition is an expression that uses a comparison operator to compare one value or variable with another. For information about comparison operators, see the VBScript Operators guide. If...Then...Else statements can be nested to as many levels as you need.

If True

To run only one statement when a condition is True, use the single-line syntax for the If...Then...Else statement. The following example shows the single-line syntax. Notice that this example omits the Else keyword...


Sub FixDate()
 Dim myDate
 myDate = #11/17/2008#
 If myDate < Now Then myDate = Now
End Sub


To run more than one line of code, you must use the multiple-line (or block) syntax. This syntax includes the End If statement, as shown in the following example:


Sub AlertUser(value)
 If value = 0 Then
 MyLayerColor = vbRed
 MyObjectColor = vbBlue
 End If
End Sub


Some True Some False

You can use an If...Then...Else statement to define two blocks of executable statements: one block to run if the condition is True, the other block to run if the condition is False...


Sub AlertUser(value)
 If value = 0 Then
 MyLayerColor = vbRed
 MyObjectColor = vbBlue
 Else
 MyLayerColor = vbGreen
 MyObjectColor = vbBlack
 End If
End Sub


Several Alternatives

A variation on the If...Then...Else statement allows you to choose from several alternatives. Adding ElseIf clauses expands the functionality of the If...Then...Else statement so you can control program flow based on different possibilit... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-CONSTANTS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-constants\index.md
Overview

A constant is a meaningful name that takes the place of a number or string and never changes. VBScript defines a number of intrinsic constants. You can get information about these intrinsic constants from the VBScript language reference.

Creating Constants

You create user-defined constants in VBScript using the Const statement. Using the Const statement, you can create string or numeric constants with meaningful names and assign them literal values. For example:


Const MyString = "This is my string."
Const MyAge = 49


Note that the string literal is enclosed in quotation marks (" "). Quotation marks are the most obvious way to differentiate string values from numeric values. You represent Date literals and time literals by enclosing them in number signs (#). For example:


Const CutoffDate = #11-17-2008#


You may want to adopt a naming scheme to differentiate constants from variables. This will prevent you from trying to reassign constant values while your script is running. For example, you might want to use a "vb" or "con" prefix on your constant names, or you might name your constants in all capital letters. Differentiating constants from variables eliminates confusion as you develop more complex scripts.

Related Topics
What are VBScript and RhinoScript?

GUIDES / RHINOSCRIPT / VBSCRIPT-DATATYPES
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-datatypes\index.md
Overview

VBScript has only one data type called a Variant. A Variant is a special kind of data type that can contain different kinds of information, depending on how it is used. Because Variant is the only data type in VBScript, it is also the data type returned by all functions in VBScript.

At its simplest, a Variant can contain either numeric or string information. A Variant behaves as a number when you use it in a numeric context and as a string when you use it in a string context. That is, if you are working with data that looks like numbers, VBScript assumes that it is numbers and does what is most appropriate for numbers. Similarly, if you're working with data that can only be string data, VBScript treats it as string data. You can always make numbers behave as strings by enclosing them in quotation marks (" ").

Variant Subtypes

Beyond the simple numeric or string classifications, a Variant can make further distinctions about the specific nature of numeric information. For example, you can have numeric information that represents a date or a time. When used with other date or time data, the result is always expressed as a date or a time. You can also have a rich variety of numeric information ranging in size from Boolean values to huge floating-point numbers. These different categories of information that can be contained in a Variant are called subtypes. Most of the time, you can just put the kind of data you want in a Variant, and the Variant behaves in a way that is most appropriate for the data it contains.

The following table shows subtypes of data that a Variant can contain:

 Subtype Description 

 Empty Variant is uninitialized. Value is 0 for numeric variables or a zero-length string () for string variables. 
 Null Variant intentionally contains no valid data. 
 Boolean Contains either True or False. 
 Byte Contains integer in the range 0 to 255. 
 Integer Contains integer in the range -32,768 to 32,767. 
 Currency -922,337,203,685,477.5808 to 92... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-DICTIONARIES
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-dictionaries\index.md
Overview

One of the nice features of other scripting languages, such as Perl, LISP, and Python is what is called an associative array. A n associative array differs from a "normal" array in one major way: rather than being indexed numerically (i.e. 0, 1, 2, 3, ...), it is indexed by a key, or an English-like word. VBScript has something very similar to an associative array. This object is called the Dictionary object. The VBScript Dictionary object provides an item indexing facility. Dictionaries are part of Microsoft's Script Runtime Library.

The Dictionary object is used to hold a set of data values in the form of (key, item) pairs. A dictionary is sometimes called an associative array because it associates a key with an item. The keys behave in a way similar to indices in an array, except that array indices are numeric and keys are arbitrary strings. Each key in a single Dictionary object must be unique.

Dictionaries are frequently used when some items need to be stored and recovered by name. For example, a dictionary can hold all the environment variables defined by the system or all the values associated with a registry key. However, a dictionary can only store one item for each key value. That is, dictionary keys must all be unique.

Creating Dictionaries

To construct an instance of a dictionary object, just use the following lines of code:


Dim objDictionary
Set objDictionary = CreateObject("Scripting.Dictionary")


Dictionary objects have one property that should be set before any data values are stored in the dictionary. There are two modes for the .CompareMode property which control how individual keys are compared. If the mode is vbBinaryCompare (the default), upper and lower case letters in keys are considered distinct. If the mode is vbTextCompare, upper and lower case letters in keys are considered identical. This means that a Dictionary object in binary mode can contain two keys "Key" and "key", whereas these would be considered the same ... [truncated]

Essential Code:
' Description:
'   Sorts a dictionary by either key or item
' Parameters:
'   objDict - the dictionary to sort
'   intSort - the field to sort (1=key, 2=item)
' Returns:
'   A dictionary sorted by intSort
'
Function SortDictionary(objDict, intSort)

  ' declare constants
  Const dictKey  = 1
  Const dictItem = 2

  ' declare our variables
  Dim strDict()
  Dim objKey
  Dim strKey,strItem
  Dim X,Y,Z

...

GUIDES / RHINOSCRIPT / VBSCRIPT-ERR-OBJECTS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-err-objects\index.md
Overview

The VBScript Err object provides access to run-time error information.

The Err object encapsulates errors for a VBScript script. By default, if an error occurs, VBScript terminates script execution and RhinoScript reports the error back to the user. Sometimes this default error processing is not desirable. In this case, the Err object and the On Error statement can be used to let scripts perform their own error handling.

Details

The Err object is a predefined global object. It does not need to be declared before it can be used. The object is used to encapsulate all the information relating to an error condition. This information is presented as a series of properties:
The .Number property is the error number (or code) for the error. This is the default property of the Err object.
The .Source property contains a string that specifies the source of the error. This is typically the ProgID (Programmatic Identifier) of the object that generated the error.
The .Description property contains a string describing the error.
The .HelpFile and .HelpContext properties store information to reference a help topic in a help file. This allows the error to refer to information on possible causes of the error.

Using On Error

To generate a user-defined run-time error, first clear the Err object using the .Clear method. Then raise the error using the .Raise method. This method takes up to five arguments that correspond, in order, to the properties previously listed. For example:


Err.Clear
Err.Raise 1000, "This is a script-defined error", "Test Script"


This example displays the standard RhinoScript error dialog box showing the error information.

To intercept run-time errors and process them in scripts, use the On Error statement. The syntax of this statement is:


On Error Resume Next


After this statement executes, the next run-time errors do not cause script execution to end. Instead, the Err object properties are set to reflect the error informatio... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-LOGIC
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-logic\index.md
Logic?

Consider the following statements:


If blnResult = True Then Print "True!" Else Print "False!"


and


If blnResult Then Print "True!" Else Print "False!"


Is there a difference?

What Logic?

Yes, there is a big difference. If blnResult is True or False, then both statements do what you would expect – the same thing. But, the first statement is asking "Is blnResult equal to True?" whereas the second question is asking "Is blnResult not equal to False?"

In a strictly Boolean world, those are equal statements. But the VBScript type system is richer than just Booleans.

Details

For example, what if - in the above example - blnResult is the string True? The string True is not equal to the Boolean True, so the first statement is false. But the string is also not equal to False, so the second statement is true, and the statements have different semantics.

The same goes for numbers. When converted to a number, True converts to -1 (for reasons which will become clear in a moment) and False converts to 0. So, if blnResult is 1, again the first statement is false because 1 <> -1, and the second statement is true because 1 <> 0.

What's going on is that VBScript is not logical. VBScript is bitwise. All the so-called logical operators work on numbers, not on Boolean values. Not, And, Or, XOr, Eqv and Imp all convert their arguments to four-byte integers, do the logical operation on each pair of bits in the integers, and return the result. If True is -1 and False is 0 then everything works out, because -1 has all its bits turned on and 0 has all its bits turned off. But if other numbers get in there, all bets are off.

This can lead to some strange situations if you're not careful. In VBScript, it is certainly possible for...


If blnResult Then


and


If blnAnswer Then


to be both true, but


If Blah And Foo Then


to be false, if blnResult is 1 and blnAnswer is 2, for example.

Best Practices

Conditional statements should al... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-LOOPING
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-looping\index.md
Overview

Looping allows you to run a group of statements repeatedly. Some loops repeat statements until a condition is False; others repeat statements until a condition is True. There are also loops that repeat statements a specific number of times.

The following looping statements are available in VBScript:
Do...Loop - Loops while or until a condition is True.
While...Wend - Loops while a condition is True.
For...Next - Uses a counter to run statements a specified number of times.
For Each...Next - Repeats a group of statements for each item in a collection or each element of an array.

Do Loops

You can use Do...Loop statements to run a block of statements an indefinite number of times. The statements are repeated either while a condition is True or until a condition becomes True.

Do While

Use the While keyword to check a condition in a Do...Loop statement. You can check the condition before you enter the loop (as shown in the following ChkFirstWhile example), or you can check it after the loop has run at least once (as shown in the ChkLastWhile example). In the ChkFirstWhile procedure, if myNum is set to 9 instead of 20, the statements inside the loop will never run. In the ChkLastWhile procedure, the statements inside the loop run only once because the condition is already False.


 Sub ChkFirstWhile()
 Dim counter, myNum
 counter = 0
 myNum = 20
 Do While myNum > 10
 myNum = myNum - 1
 counter = counter + 1
 Loop
 MsgBox "The loop made " & counter & " repetitions."
 End Sub

 Sub ChkLastWhile()
 Dim counter, myNum
 counter = 0
 myNum = 9
 Do
 myNum = myNum - 1
 counter = counter + 1
 Loop While myNum > 10
 MsgBox "The loop made " & counter & " repetitions."
 End Sub


Do Until

There are two ways to use the Until keyword to check a condition in a Do...Loop statement. You can check the condition before you enter the loop (as shown in the following ChkFirstUntil example), or you can check it after the loop has run at least once (as shown in the ChkLas... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-OPERATORS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-operators\index.md
Overview

VBScript has a full range of operators, including arithmetic operators, comparison operators, concatenation operators, and logical operators.

Operator Precedence

When several operations occur in an expression, each part is evaluated and resolved in a predetermined order called operator precedence. You can use parentheses to override the order of precedence and force some parts of an expression to be evaluated before others. Operations within parentheses are always performed before those outside. Within parentheses, however, standard operator precedence is maintained.

When expressions contain operators from more than one category, arithmetic operators are evaluated first, comparison operators are evaluated next, and logical operators are evaluated last. Comparison operators all have equal precedence; that is, they are evaluated in the left-to-right order in which they appear. Arithmetic and logical operators are evaluated in the following order of precedence.

Arithmetic

 Description Symbol 

 Exponentiation ^ 
 Unary negation - 
 Multiplication * 
 Division / 
 Integer division \ 
 Modulus arithmetic Mod 
 Addition + 
 Subtraction - 
 String concatenation & 

Comparison

 Description Symbol 

 Equality = 
 Inequality <> 
 Less than  
 Less than or equal to = 
 Object equivalence Is 

Logical

 Description Symbol 

 Logical negation Not 
 Logical conjunction And 
 Logical disjunction Or 
 Logical exclusion Xor 
 Logical equivalence Eqv 
 Logical implication Imp 

Considerations

When multiplication and division occur together in an expression, each operation is evaluated as it occurs from left to right. Likewise, when addition and subtraction occur together in an expression, each operation is evaluated in order of appearance from left to right.

The string concatenation (&) operator is not an arithmetic operator, but in precedence it falls after all arithmetic operators and before all comparison operators. The Is operator is an object reference compar... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-PASSING-PARAMETERS
------------------------------------------------------------

Related Topics
Source: guides\rhinoscript\vbscript-passing-parameters\index.md
Overview

In VBScript, there are two ways values can be passed: ByVal and ByRef. Using ByVal, we can pass arguments as values whereas with the use of ByRef, we can pass arguments are references. This is the obvious bit, but, how do these two differ in practice?

Passing By Value

Consider the following code snippet:


Function GetValue(ByVal var)
 var = var + 1
End Function

Dim x: x = 5

'Pass the variable x to the GetValue function ByVal
Call GetValue(x)

Call Rhino.Print("x = " & CStr(x))


When you run the block of code above, you will get the following output:


x = 5


In other words, when we passed the variable x (ByVal) to the function GetValue, we were simply passing a copy of the variable x. When GetValue executes, var stores a copy of the variable x and increments itself by 1. Therefore, because what we are passing to GetValue is a copy of x, it cannot be modified.

Passing By Reference

Now, let’s look at another way of passing variables: By Reference.

Consider the following code snippet:


Function GetReference(ByRef var)
 var = var + 1
End Function

Dim x: x = 5

'Pass the variable x to the GetReference function ByRef
Call GetReference(x)

Call Rhino.Print("x = " & CStr(x))


When you run the block of code above, you will get the following output:


x = 6


Variable x was increment by 1. But why was x incremented? Only var must have incremented by 1, and not x? Well, that is the core concept behind passing variables by reference.

When the function GetReference executes, var becomes a reference of x, and therefore, any changes made to var would impact x. So if var increments itself by 1, so would x. If var becomes 0 (zero), so would x.

Let’s look at another example:


Function GetReference(ByRef arrArray)
 ReDim Preserve arrArray(UBound(arrArray)+1)
 arrArray(UBound(arrArray)) = 2
End Function

Dim newArray: newArray = Array(0, 1)
Call GetReference(newArray)


Will the size of newArray increase? Look at:


' ... [truncated]

Essential Code:
Function GetValue(ByVal var)
  var = var + 1
End Function

Dim x: x = 5

'Pass the variable x to the GetValue function ByVal
Call GetValue(x)

Call Rhino.Print("x = " & CStr(x))

Function GetReference(ByRef var)
  var = var + 1
End Function

Dim x: x = 5

'Pass the variable x to the GetReference function ByRef
Call GetReference(x)

Call Rhino.Print("x = " & CStr(x))


GUIDES / RHINOSCRIPT / VBSCRIPT-PROCEDURES
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-procedures\index.md
Overview

In VBScript, there are two kinds of procedures; the Sub procedure and the Function procedure.

Sub Procedures

A Sub procedure is a series of VBScript statements (enclosed by Sub and End Sub statements) that perform actions but don't return a value. A Sub procedure can take arguments (constants, variables, or expressions that are passed by a calling procedure). If a Sub procedure has no arguments, its Sub statement should include an empty set of parentheses ().

The following Sub procedure uses two intrinsic, or built-in, VBScript functions, MsgBox and InputBox, to prompt a user for information. It then displays the results of a calculation based on that information. The calculation is performed in a Function procedure created using VBScript. The Function procedure is shown after the following discussion.


Sub ConvertTemp()
 temp = InputBox("Please enter the temperature in degrees F.", 1)
 MsgBox "The temperature is " & Celsius(temp) & " degrees C."
End Sub


Function Procedures

A Function procedure is a series of VBScript statements enclosed by the Function and End Function statements. A Function procedure is similar to a Sub procedure, but can also return a value. A Function procedure can take arguments (constants, variables, or expressions that are passed to it by a calling procedure). If a Function procedure has no arguments, its Function statement should include an empty set of parentheses. A Function returns a value by assigning a value to its name in one or more statements of the procedure. The return type of a Function is always a Variant.

In the following example, the Celsius Function calculates degrees Celsius from degrees Fahrenheit. When the Function is called from the ConvertTemp Sub procedure, a variable containing the argument value is passed to the Function. The result of the calculation is returned to the calling procedure and displayed in a message box.


Sub ConvertTemp()
 temp = InputBox("Please enter the temperature in... [truncated]

Essential Code:
Sub ConvertTemp()
	temp = InputBox("Please enter the temperature in degrees F.", 1)
	MsgBox "The temperature is " & Celsius(temp) & " degrees C."
End Sub

Function Celsius(fDegrees)
	Celsius = (fDegrees - 32) * 5 / 9
End Function

Function Celsius(fDegrees)
	Celsius = (fDegrees - 32) * 5 / 9
End Function


GUIDES / RHINOSCRIPT / VBSCRIPT-REGEXP-OBJECTS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-regexp-objects\index.md
Overview

The VBScript RegExp object matches strings against special text patterns, called regular expressions.

The InStr function can be used to search a string to see if it contains another string. The RegExp object provides a far more sophisticated string searching facility by using regular expressions.

A regular expression is a string that describes a match pattern. The match pattern provides a template that can be used to test another string, the search string, for a matching sub-string. In its simplest form, the match pattern string is just a sequence of characters that must be matched. For example, the pattern "fred" matches this exact sequence of characters and only this sequence. More sophisticated regular expressions can match against items such as file names, path names, and Internet URLs. Thus, the RegExp object is frequently used to validate data for correct form and syntax.

Using RegExp

To test a search string against a match pattern, create a RegExp object and set the match pattern. Then use the .Test method to test for a match. For example:


Dim oRE, bMatch
Set oRE = New RegExp
oRE.Pattern = "fred"
bMatch = oRE.Test("His name was fred brown")


Regular expression objects are created using the New keyword. This is an anomaly of VBScript, because it is the only object, apart from user-defined objects, that is created in this manner. Once created in this way, the methods and properties of the object are accessed normally.

The .Pattern property defines the match pattern, and the .Test method tests the supplied string against this match pattern, returning True if the match pattern is found within the supplied string. In the preceding example, bMatch is set to True as there is clearly a match.

The .Execute method of the RegExp object also checks for a pattern match, but it returns a Matches collection object that contains detailed information on each pattern match. The Matches object is a normal collection object containing a .Count property... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-STATEMENTS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-statements\index.md
Overview

Many scripting and programming languages, such as JScript, C#, and C++, make no attempt to match the code that is run with the actual physical lines typed into the text editor. This is because they not recognize the end of a line of code until it sees the termination character (in these cases, the semicolon). Thus, the actual physical lines of type taken up by the code are irrelevant.

By contrast, VBScript uses the carriage return instead of a special line termination character. To end a statement in VBScript, you do not have to type in a semicolon or other special character; you simply press Enter. For example, this code will generate a syntax error:


Set
objFSO
=
CreateObject("Scripting.FileSystemObject")


This will not:


 Set objFSO = CreateObject("Scripting.FileSystemObject")


Details

In general, the lack of a required statement termination character simplifies script writing in VBScript. There is, however, one complication: To enhance readability, it is recommended that you limit the length of any single line of code to 80 characters. What happens, then, if you have a line of code that contains 100 characters?

Although it might seem like the obvious solution, you cannot split a statement into multiple lines simply by entering a carriage return. For example, the following code snippet returns a run-time error in VBScript because a statement was split by using Enter.


 strMessageToDisplay = strUserFirstName & " " & strUserMiddleInitial & " " & strUserLastName
 Rhino.Print strMessageToDisplay


You cannot split a statement into multiple lines in VBScript by pressing Enter because VBScript sees a carriage return as marking the end of a statement. In the preceding example, VBScript interprets the first line as the first statement in the script. Next, it interprets the second line as the second statement in the script, and the error occurs because strUserLastName is not a valid VBScript statement.

Instead, use the underscore (... [truncated]

GUIDES / RHINOSCRIPT / VBSCRIPT-STRING-LITERALS
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-string-literals\index.md
Overview

In VBScript, you enclose strings with double quote characters, and you use the ampersand (&) operator to concatenate strings. For example:


Dim s
s = "Hello"
s = "Hello" & " Rhino!"


What if you want to assign "Hello Rhino!" (including the quotes) to the variables? In VBScript, you can use two double quote characters to include a double quote character in the string. For example:


Dim s
s = "Hello Rhino!"


Alternatively you can use the Chr(34) construct:


Dim s
s = Chr(34) & "Hello Rhino" & Chr(34)


Or, to make your code more readable, you can write a function...


Function Quote(ByVal s)
 Quote = Null
 If (VarType(s) = vbString) Then
 Quote = Chr(34) & CStr(s) & Chr(34)
End If
End Function

'...

Dim s
s = Quote("Hello Rhino!")


Essential Code:
Function Quote(ByVal s)
	Quote = Null
	If (VarType(s) = vbString) Then
		Quote = Chr(34) & CStr(s) & Chr(34)
End If
End Function

'...

Dim s
s = Quote("Hello Rhino!")


GUIDES / RHINOSCRIPT / VBSCRIPT-VARIABLE-HOISTING
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-variable-hoisting\index.md
Problem

Consider the following VBScript code, which does not work:


Option Explicit
s = "Hello"


Now, consider the following working code:


Option Explicit
s = "Hello"
Dim s


Why can a variable be used before declaring it in VBScript?

Solution

Consider this code:


Dim s
s = Foo(123)

Function Foo(x)
 Foo = x + 345
End Function


Here the function is being used before it is declared. Similarly, variables can be used before they are declared. The behaviour is by design. Variable declarations and functions are logically "hoisted" to the top of their scope in VBScript.

Also, declaring a variable twice in the same script block is illegal, but redefinition in another block is legal. Procedures may be redeclared at will except if the procedure is in a class, in which case redeclaration is illegal.

The following is legal in VBScript:


s = Foo(123)
If Blah Then
 Function Foo(x)
 Foo = x + 345
 End Function
End If


Details

This is not recommended, but it is legal:


Dim i
For i = 1 To 2
 Rhino.Print c
Next
Const c = 10


And this works too:


For i = 1 To 2
 Rhino.Print c
 Dim i
Next
Const c = 10


But, this fails with a "name redefined" error:


For i = 1 To 2
 Rhino.Print c
 Const c = 10
 Dim i
Next


In conclusion, in VBScript:
Variable declarations are logically hoisted to the top of the scope.
Constants are evaluated at code compilation time; the constants' values are injected into the code.

Essential Code:
Dim s
s = Foo(123)

Function Foo(x)
  Foo = x + 345
End Function

s = Foo(123)
If Blah Then
  Function Foo(x)
    Foo = x + 345
  End Function
End If


GUIDES / RHINOSCRIPT / VBSCRIPT-VARIABLES
------------------------------------------------------------

Index
Source: guides\rhinoscript\vbscript-variables\index.md
Overview

A variable is a convenient placeholder that refers to a computer memory location where you can store program information that may change during the time your script is running. For example, you might create a variable called ClickCount to store the number of times a user performs a certain operation. Where the variable is stored in computer memory is unimportant. What is important is that you only have to refer to a variable by name to see or change its value. In VBScript, variables are always of one fundamental data type: Variant.

Declaration

You declare variables explicitly in your script using the Dim statement, the Public statement, and the Private statement. For example:


Dim AngleDegrees


You declare multiple variables by separating each variable name with a comma. For example:


Dim Top, Bottom, Left, Right


Naming Restrictions

Variable names follow the standard rules for naming anything in VBScript. A variable name:
Must begin with an alphabetic character.
Cannot contain an embedded period.
Must not exceed 255 characters.
Must be unique in the scope in which it is declared.

Scope & Lifetime

A variable's scope is determined by where you declare it. When you declare a variable within a procedure, only code within that procedure can access or change the value of that variable. It has local scope and is a procedure-level variable. If you declare a variable outside a procedure, you make it recognizable to all the procedures in your script. This is a script-level variable, and it has script-level scope.

The lifetime of a variable depends on how long it exists. The lifetime of a script-level variable extends from the time it is declared until the time the script is finished running. At procedure level, a variable exists only as long as you are in the procedure. When the procedure exits, the variable is destroyed. Local variables are ideal as temporary storage space when a procedure is executing. You can have local variables of the ... [truncated]

GUIDES / RHINOSCRIPT / WHAT-ARE-VBSCRIPT-RHINOSCRIPT
------------------------------------------------------------

Index
Source: guides\rhinoscript\what-are-vbscript-rhinoscript\index.md
Overview

VBScript (short for Visual Basic Scripting Edition) is an easy-to-use scripting language developed by Microsoft that enables authors to create powerful tools using a subset of the Visual Basic language. VBScript is implemented as a fast, portable interpreter for web browsers and applications that use ActiveX controls and OLE Automation servers.

If you already know Visual Basic or Visual Basic for Applications (VBA), VBScript will be familiar. Even if you do not know Visual Basic, it should not take you long to get up-to-speed. VBScript is a relatively easy language to learn and use.

RhinoScript is a scripting tool based on Microsoft's VBScript language. With RhinoScript, you can quickly add functionality to Rhino, or automate repetitive tasks. Besides providing support for VBScript, RhinoScript also runs as an OLE automation server that exposes the internal workings of Rhino to automation.

Related Topics
VBScript User's Guide and Language Reference on MSDN.aspx)
VBScript Data Types
VBScript Variables
VBScript Constants
VBScript Operators
VBScript Statements
VBScript Conditionals
VBScript Looping
VBScript Procedures
VBScript Code Conventions

GUIDES / SCRIPTING / ADVANCED-ASYNC
------------------------------------------------------------

async: true
Source: guides\scripting\advanced-async\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 }

What is Asynchronous

Normally, most operations in an application with a graphical user interface (GUI), run on the UI Thread. That is the thread that starts the UI and listens to the events like clicking buttons and moving the mouse. When you click on a button, the code behind that button runs on the UI thread.

Asynchronous (Async for short) operations run on Non-UI threads and do not freeze the UI.

If the task is time-consuming, the UI thread (now executing the task after button click) can not respond to any other events. Therefore UI is "Frozen" (not the Disney® movie) and unresponsive. Normally this is ok since you would not want the us... [compressed]OR
place a python-3pluginname.pth file under shared scripts/ and list more that one search path pointing to where the python modules are located

GUIDES / SCRIPTING / ADVANCED-PYRUNTIME
------------------------------------------------------------

Index
Source: guides\scripting\advanced-pyruntime\index.md


GUIDES / SCRIPTING / ADVANCED-PYVENVS
------------------------------------------------------------

venv: my-pytorch-tools
Source: guides\scripting\advanced-pyvenvs\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

 .language-csharp {
 font-size: .9em;
 }

Package Conflicts

Sometimes scripts need different versions of the same package either intentionally or through nested dependencies. Imagine this scenario:
File scripta.py requires pkga version 1
File scriptb.py requires pkgb version 2 which is dependent on pkga version 2 (newer than pkga of scripta)
On a clean Rhino, running scripta installs and loads pkga v1
On a clean Rhino, running scriptb installs and loads pkgb + pkga v2

Here is a few ways that package version conflicts can happen:

A) PIP Install Failure

Following the scenario above, if scripta is executed successfully in a Rhino session, running scriptb will probably fail when installing pkgb. Script Editor is using pip to install packages. Since, by default, all the packages for all the various scripts are installed in the same directory (as python normally does), this creates a conflict when pip is trying to remove pkga v1 to install pkga v2. Remember Rhino has already executed scripta, therefore pkga libraries are loaded in memory and at least on Windows, these library files are locked and can not be deleted while Rhino is running.

Any pip install error will mark the environment as Invalid and will cleanup after Rhino is restarted.

B) Runtime Conflicts

Following the scenario above, even if the two version of pkga can be installed at the same time, pkga is already loaded in Python 3 runtime and loading another version of this package (that is in the same directory) might lead to runtime errors and unexpected behaviour.

Virtual Environments

Tools like pipenv and other environment managers for Python, normally solve this problem by creating multiple Virtual Environments. Each virtual environment has a dedicated folder with its own site-packages (where pip installs packages by default). Python core binaries ar... [truncated]

GUIDES / SCRIPTING / ADVANCED-SCRIPTEDITOR-MACROS
------------------------------------------------------------

Index
Source: guides\scripting\advanced-scripteditor-macros\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

ScriptEditor Command Options

ScriptEditor command has a few options that could be used in macros. Run -ScriptEditor command in Rhino prompt to see these options (- is for non-interactive mode, and ensures command works in all Rhino UI languages. See Command Macros & Scripting for more):
Edit (E): This is the default option when running ScriptEditor command in Rhino. It opens the standalone Script Editor and initialized all languages.
Run (R): Runs given script using the new scripting infrastructure in Rhino 8. It can run scripts or script files of any supported language.
Browse (B): Using this suboption, allows to browse and select a script file
Run a script file in a macro this way 👉 -ScriptEditor R "C:\path\to\script.py" 
Run a script in a macro this way 👇. Note that the language specifier (#! python 3, #! python 2, or // #! csharp) is necessary so the command can determine which language to run the script with:


-ScriptEditor R (
 #! python 3
 print("Hello Rhino")
)

Open (O):: Opens given script file in ScriptEditor
Browse (B): Using this suboption, allows to browse and open a script file
Open a script file to edit this way 👉 -ScriptEditor O "C:\path\to\script.py" 

Script Search Paths

Normally you have specify the full script path in a macro like -ScriptEditor R "C:\path\to\HelloWorld.py" to run the script. However, you can place your most common scripts under a directory, and add the path of that directory to Rhino File Search Paths. When search paths are set up, you can run -ScriptEditor R "HelloWorld.py" and the command can find the script under specified search paths.

 They are purely to search and find python modules.

GUIDES / SCRIPTING / ADVANCED-TYPEHINTS
------------------------------------------------------------

Index
Source: guides\scripting\advanced-typehints\index.md
Coming Soon. If you have any questions please reach out on McNeel Forums

GUIDES / SCRIPTING / ADVANCED-VSCODE
------------------------------------------------------------

Index
Source: guides\scripting\advanced-vscode\index.md


GUIDES / SCRIPTING / EDITOR-CONFIGS
------------------------------------------------------------

Index
Source: guides\scripting\editor-configs\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 }

Editor Options dialog (Tools > Options menu) provides access to editor and language settings that are persistent.

Hovering over help icons provides more information about each option:

General Options

General options are under General tab of Editor Options dialog and are self explanatory:

Grasshopper Script Editor has a few layout options under General tab. Window menu also shows toggles for these options:

Window > Toggle \ menu items provide toggles for Editor UI elements. Editor remembers the last UI layout before it is closed. See Layout Options: Python or C# 

Editing Options

Editing options are language-specific. Each language tab has its own editing options:

Edit > Toggle \* menu items provide toggles for some of the options. These changes are in-session only and do not get saved to settings file. See Editing Features 

Language Support Options

Language Support options are language-specific. Each language tab has its own language options:

Edit > Toggle \ menu items provide toggles for some of the options. These changes are in-session only and do not get saved to settings file. See Editing Features 

Python Paths

Scripts Path

By default, Rhino adds these paths to Python 2 and 3 search paths (sys.path):

On Windows:
Shared %PROGRAMDATA%\McNeel\Rhinoceros\.0\scripts (if exists)
User %APPDATA%\McNeel\Rhinoceros\.0\scripts

On macOS:
Shared /Users/Shared/McNeel/Rhinoceros/.0/scripts (if exists)
User** ~/Library/Application Support/McNeel/Rhinoceros/.0/scripts

Note that the first path on either platform, is the shared path and takes precedence over the user path. So if python module test is available in both paths, the one under shared path will be imported. Shared scripts path are not created by default so the... [truncated]

GUIDES / SCRIPTING / EDITOR-DEBUG
------------------------------------------------------------

Index
Source: guides\scripting\editor-debug\index.md
debuggable scripts
add breakpoint
toggle breakpoints
clear breakpoints
variables
watch
call stack

GUIDES / SCRIPTING / EDITOR-EDITING
------------------------------------------------------------

Index
Source: guides\scripting\editor-editing\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

Script Editor has a few editing features that can be changed or toggled for each specific language. These settings are toggled/set using two different methods:
Edit > Toggle menu items: Affect the current session and are forgotten when Rhino restarts.
Editor Options Dialog: Are persistent and are stored in editor configuration file to disk.

Depending on the type of feature, there might be a Toggle menu item or a setting in Editor Options, or both. Some features are language-specific and can be set independently by scripting language.

Tabs or Spaces?

Choose Edit > Toggle White Spaces to toggle visibilty of white spaces (Tab or Space) in your scripts. See Show White Spaces in Editing Options. This option is Off by default:

Edit > Convert Indentation to Tabs/Spaces commands can be used to convert between Space and Tab indentations. When changing your scripts to SDK-Mode in Grasshopper, the indentation is detected and used in modified script:

Indentation Guides

Indentation guides are vertical lines drawn at different indentation levels to help visually identifying scopes and blocks. See Show Indentation Guides in Editing Options. This option is On by default:

Minimap

Choose Edit > Toggle Minimap to toggle visibilty of minimap. It is effectively a thicker vertical scrollbar that shows a tiny preview of your script. You can scroll up and down the script using minimap. See Show Minimap in Editing Options. This option is Off by default:

Line Numbers

Pretty clear what they are! Choose Edit > Toggle Line Numbers to toggle their visibility:

Diagnostics (Linting)

As you are typing your script, the editor is continiously checking for syntax errors using the static analyzers provided by the language. These messages are categorized as Errors, Warnings, or Info and show up in the Problems panel at the bottom of the edit... [truncated]

GUIDES / SCRIPTING / EDITOR-EXPLORER
------------------------------------------------------------

Index
Source: guides\scripting\editor-explorer\index.md
explore a path
async expand
file prompt
context menus
create
create under a path
open
rename
delete

GUIDES / SCRIPTING / EDITOR-HELP
------------------------------------------------------------

Index
Source: guides\scripting\editor-help\index.md
help tray
show rhino 7 help
online help and help menus
examples panel
open an example

GUIDES / SCRIPTING / EDITOR-LOGS
------------------------------------------------------------

Index
Source: guides\scripting\editor-logs\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

Opening Log Viewer

Script Editor writes log messages during its operation. These log messages are useful in detecting any internal errors that might have happened when working with the script editor. You can view these logs by clicking on the Open Logger button on the far right side of editor status bar, or by running RhinoCodeLogs command:

The same button is also available on a few other editor dialogs like Publish Project dialog:

This opens the RhinoCode Logs window:

Saving Logs

To save all the log messages into a file, choose Logs > Save Contents menu item and save the logs to disk. By default the contents are saved to a log file named ScriptEditor.log

GUIDES / SCRIPTING / EDITOR-PROBLEMS
------------------------------------------------------------

Index
Source: guides\scripting\editor-problems\index.md
shows diagnostic results
these are NOT exec errors
can be disabled in options
errors by default
warings and info can be added
click to go to line

GUIDES / SCRIPTING / EDITOR-SEARCH
------------------------------------------------------------

Index
Source: guides\scripting\editor-search\index.md
search panel
searches all scripts
search options
clear search

GUIDES / SCRIPTING / EDITOR-TEMPLATES
------------------------------------------------------------

Index
Source: guides\scripting\editor-templates\index.md
browse templates
async explore
create new template
save
edit the template
rename
delete

GUIDES / SCRIPTING / EDITOR-TERMINAL
------------------------------------------------------------

Index
Source: guides\scripting\editor-terminal\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

 .language-csharp {
 font-size: .9em;
 }

Terminal Panel

Terminal panel shows printed output of last executed script. You can toggle the terminal using the toggle button at the top-right of editor window.

The two Copy and Clear buttons can be used to copy or clear the terminal contents.

Line By Line Printing

By default, the output of a script is captured during execution and printed on the terminal all at once when execution is completed. This way the script is not slowed down by frequent UI updates.

When debugging a script, this behaviour changes and script output is printed on the terminal as the script is running. This helps seeing the messages being printed from your script during debug.

Sometimes it is desired to see the script output during normal execution. An examples is when a script is processing a series of files and needs to print its progress to the terminal. Waiting for the script to end without seeing any reports negates the point of reporting progress.

Use the Line by Line toggle on the terminal header to print script output during normal execution. You may also want to toggle auto-minimization from Run > Toggle Minimize Editor On Execute menu item to keep editor on screen:

GUIDES / SCRIPTING / PROJECTS-CREATE
------------------------------------------------------------

Index
Source: guides\scripting\projects-create\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

 .language-csharp {
 font-size: .9em;
 }

Rhino Script Editor is designed to utilize the widespread plugin infrastructure in both Rhino and Grasshopper, and generate plugins from your scripts.

Script editor can:
Convert scripts into Rhino commands and publish as Rhino plugin (.rhp file)
Convert scripts into Grasshopper components and publish as Grasshopper plugin (.gha file)
Create a Yak package and publish on Rhino package server

It can also:
Generate toolbar layout files for published Rhino commands (.rui file)
Share code libraries and data files with published commands or components
Generate dotnet project solution for published plugins for furthur customization (.sln and .csproj files)

Create a Project

To create a project:
Run ScriptEditor command
Choose Create Project from main File menu
Navigate to where you would like to save the project. Project file will be stored with .rhproj extension
Editor displays Edit Project dialog.

 This dialog highlights the most important pieces of information about the new project:
Id: Unique UUID of this project. It should not be changed. See Project Id
Name: Plugins will be published with this name. See Project Name
Version: Plugins will be published with this version. See Project Version
Author: This is required and if there are no authors available, this field will show a No Author error. See Project Authors
Choose Save Changes
Project file is now saved and editor opens the Projects panel on the left browser tray
Now that the project saved and open, we can add command and components. We will get a chance to edit project information before publishing the project as plugins.

Add Commands

To add a command, click on the + icon on the Project Tray toolbar and select Add Commands/ item:

You can also right-click on the Commands/ to add new commands:

You can select a single ... [truncated]

Essential Code:
public sealed class AssemblyInfo : GH_AssemblyInfo
{
    public override Guid Id { get; } = new Guid("e73d16e6-a2d4-4917-93e7-aebeac2f38f5");
}


GUIDES / SCRIPTING / PROJECTS-PUBLISH
------------------------------------------------------------

Index
Source: guides\scripting\projects-publish\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

{{}}
Creating Rhino Projects for information on creating projects in Script Editor.
{{}}

Build Plugins from Script Editor

You can build a project directly from Script Editor:
Open Script Editor
Open Project (File > Open Project menu)
Choose Publish Project (File > Publish Project or Publish button in editor dashboard)

 Project information fields are discussed in detail in Create Project. Here we focus on choosing a Build Target and Build Path.
Choose a Build Target:

 This is the minimum version of Rhino required to run your plugin. The available versions are queried from Rhino NuGet packages. You can see macOS and Windows specific targets as well.
Choose a Build Path:

 This is where all generated assemblies and files are placed. Depending on the Build Target a subpath is added to this build path to avoid conflicts (e.g build/rh8/)
Choose Build Package to build the project:

 On a successful build, status tray will show success message in green:

Build Plugins from Terminal

{{}}
To build a project in terminal, use the rhinocode command line utility shipped with Rhino.

See RhinoCode Command Line Interface 
{{}}
Open Terminal
Use rhinocode command line utility to build the project:


$ rhinocode project build ~/MyProject.rhproj
 0% - Preparing project
 10% - Preparing build path
 20% - Preparing plugin assembly
 50% - Preparing grasshopper plugin assembly
 60% - Adding shared resources
 90% - Creating yak package
100% - Complete


See RhinoCode: Build a Project 

Build Artifacts

Once project is built, the target path will contain all the generated artifacts:

A Yak package is generated that contains both Rhino and Grasshopper plugins.

{{}}
See Pushing a Package to the Server on how to publish .yak files to package server
{{}}
... [truncated]

GUIDES / SCRIPTING / SCRIPTING-COMMAND
------------------------------------------------------------

r: numpy
Source: guides\scripting\scripting-command\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

Opening Script Editor

To access the unified script editor in Rhino, type ScriptEditor in the command prompt and select enter to run the command:

If this is the first time you are using the scripting features in Rhino, the editor will immediately start initializing the languages. Setting up the Python 3 (CPython) environment is the most important and normally the longest task here. The editor will display a progress bar showing each initialization task. All editor features are disabled at this point so you should wait for the initialization process to complete.

Once the initialization is complete, the editor will load all the previously open scripts (if any), and will enable the buttons and menus:

First Script

Let's create our first script. We will use IronPython for this example. From the Dashboard (row of buttons at the top of the editor window), click on the New button and choose "Iron Python" to create the first script:

The default script contains a good amount of information under the NOTES: multiline comment (or docstring). We can skip that for now, as we will discuss these more advanced topics later in this guide. Let's remove those comments.

Click on the Save button on the Dashboard to save the script:

Edit Script

Let's type a new line at the bottom of the script. The editor will help autocomplete the names:


print(Rhino.RhinoApp.Version)


In this example, the script tab showing the script's name (FirstScript.py) now shows a dark circle by the name denoting that the script has been modified but not saved.

Running Scripts

Click the green Run button on the Dashboard (or hit F5) to run the script. The only line in our script that produces a result is the print statement. This will print the version of Rhino we are using in the terminal. Click on the Terminal tab at the bottom of the screen ... [truncated]

GUIDES / SCRIPTING / SCRIPTING-COMPONENT
------------------------------------------------------------

r: numpy
Source: guides\scripting\scripting-component\index.md
.main-content img { zoom: 50%; }
 code {
 background-color: #efefef;
 padding-left: 5px;
 padding-right: 5px;
 border-radius: 3px;
 font-size: 14px;
 }

Create Script Component

To access the unified script editor in Grasshopper, go to the Maths tab and Script panel and drop a Script component onto the canvas:

This component is designed to work with any of the supported languages. While being completely new and internally different from the legacy GHPython and C# components, it tries to replicate the same behaviors as those legacy components and stay familiar as much as possible.

First Script

Once you place an instance of the Script component on the canvas, it will show a warning that it is missing a script. We first need to choose the programming language we would like to script in to initialize the component:

{{}}
Double-click on the component to quickly start a new script using the most-recently used language.
{{}}

The first button at the bottom of the component shows the default or last used language for this component. Double-clicking on the component itself will automatically use this language to initialize the component and start a new script:

Other supported languages could be selected from the [ ● ● ● ] menu:

Choose Python 3 to start a new script:

The default script looks like this:


"""Grasshopper Script"""
a = "Hello Python 3 in Grasshopper!"
print(a)


Script Inputs and Outputs

The Script component supports Zoomable User Interface (ZUI for short). This means that you can modify the inputs and outputs of the component by zoo... [compressed]GUIDES / SCRIPTING / TEMPLATE
------------------------------------------------------------

Index
Source: guides\scripting\template\index.md


GUIDES / SCRIPTING / WHAT-IS-SCRIPTEDITOR
------------------------------------------------------------

Index
Source: guides\scripting\what-is-scripteditor\index.md
its a place you write scripts to customize
what rhino had: c#, ironpython, rhinoscript, vb, ghgl
new in rhino 8:
unified editor
python 3
modern c#
better ironpython
no more vb
ghgl in progress
libraries
easy sharing scripts

GUIDES / YAK / CREATING-A-GRASSHOPPER-PLUGIN-PACKAGE
------------------------------------------------------------

Index
Source: guides\yak\creating-a-grasshopper-plugin-package\index.md
The Package Manager was introduced in Rhino 7. It makes it easier to discover, install and manage Grasshopper plug-ins from within Rhino. This guide will describe how to create a package from a Grasshopper plug-in that can be published to the package server.

{{}}
The package manager is cross-platform. The examples below are for Windows.
For Mac, replace the path to the Yak CLI tool with "/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".
{{}}

First, let's assume you have a folder on your computer which contains all the files that you would like to distribute in your package. Something like this...


C:\Users\Bozo\dist
├── Marmoset.gha
├── icon.png
└── misc\
 ├── README.md
 └── LICENSE.txt


{{}}
This is just an example. The only files that matter are Marmoset.gha and icon.png (we'll reference the icon in the manifest.yml file later).
{{}}

We're going to use the Yak CLI tool to create the package, so open up a Command Prompt and navigate to the directory above.


cd C:\Users\Bozo\dist


Now, we need a manifest.yml file! You can easily create your own by studying the Manifest Reference Guide. Alternatively, you can use the spec command to generate a skeleton file. We'll do the latter here.


"C:\Program Files\Rhino {{}}\System\Yak.exe" spec

Inspecting content: Marmoset.gha

name: marmoset
version: 1.0.0
authors:
Park Ranger
description: >
 This plug-in does something. I'm not really sure exactly what it's supposed to
 do, but it does it better than any other plug-in.
url: https://example.com
icon: icon.png
keywords:
mammal


Now that we have a manifest file, we can build the package!


"C:\Program Files\Rhino {{}}\System\Yak.exe" build

Building package from contents of C:\Users\Bozo\dist

Found manifest.yml for package: marmoset (1.0.0)
Inspecting content: Marmoset.gha
Creating marmoset-1.0.0-rh618-any.yak

name: marmoset
version: 1.0.0
authors:
Will Pearson
description: >
 This plug-in does something. I'... [truncated]

GUIDES / YAK / CREATING-A-MULTI-TARGETED-RHINO-PLUGIN-PACKAGE
------------------------------------------------------------

Index
Source: guides\yak\creating-a-multi-targeted-rhino-plugin-package\index.md
The Package Manager was introduced in Rhino 7. It makes it easier to discover, install and manage Rhino plug-ins from within Rhino. This guide will describe how to create a package from a Rhino plug-in that can be published to the package server.

{{}}
The package manager is cross-platform. The examples below are for Windows. For Mac, replace the path to the Yak CLI tool with "/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".
{{}}

First, let's assume you have a build directory on your computer which contains all the files that you would like to distribute in your multi-targeted package. Something like below.


C:\Users\Bozo\dist\
├───net48 
│ │ icon.png 
│ │ Tamarin.rhp 
│ └───misc 
│ License.txt 
│ README.md 
└───net7.0 
 │ icon.png 
 │ Tamarin.rhp 
 └───misc 
 License.txt 
 README.md 


{{}}
This is just an example. The only files that matter are Tamarin.rhp and icon.png (we'll reference the icon in the manifest.yml file later).
{{}}

We're going to use the Yak CLI tool to create the package, so open up a Command Prompt and navigate to the directory above.

 commandline
cd C:\Users\Bozo\dist\


Now, we need a manifest.yml file! You can easily create your own by studying the Manifest Reference Guide. Alternatively, you can use the spec command to generate a skeleton file. We'll do the latter here.

 commandline
"C:\Program Files\Rhino {{}}\System\Yak.exe" spec

Inspecting content: Tamarin.rhp

name: tamarin
version: 1.0.0
authors:
Park Ranger
description: >
 This plug-in does something. I'm not really sure exactly what it's supposed to
 do, but it does it better than any other plug-in.
url: https://example.com
icon: icon.png
keywords:
something


Now that we have a manifest file, we can build the package!

 commandline
"C:\Program Files\Rhino {{}}\System\Yak.exe" build

Building package from contents of C:\Users\Bozo\dist

Found manifest.yml for package: tamarin (1.0.0)
Inspecting content: Tamarin.rhp
Creating tamarin-1.0.0-rh80-any.yak
... [truncated]

GUIDES / YAK / CREATING-A-RHINO-PLUGIN-PACKAGE
------------------------------------------------------------

Index
Source: guides\yak\creating-a-rhino-plugin-package\index.md
The Package Manager was introduced in Rhino 7. It makes it easier to discover, install and manage Rhino plug-ins from within Rhino. This guide will describe how to create a package from a Rhino plug-in that can be published to the package server.

{{}}
The package manager is cross-platform. The examples below are for Windows.
For Mac, replace the path to the Yak CLI tool with
"/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".
{{}}

First, let's assume you have a folder on your computer which contains all the
files that you would like to distribute in your package. Something like this...


C:\Users\Bozo\dist
├── Tamarin.rhp
├── icon.png
└── misc\
 ├── README.md
 └── LICENSE.txt


{{}}
This is just an example. The only files that matter are Tamarin.rhp and icon.png (we'll reference the icon in the manifest.yml file later).
{{}}

We're going to use the Yak CLI tool to create the package, so open up a Command
Prompt and navigate to the directory above.


cd C:\Users\Bozo\dist


Now, we need a manifest.yml file! You can easily create your own by studying
the Manifest Reference Guide. Alternatively, you can use the spec
command to generate a skeleton file. We'll do the latter here.


"C:\Program Files\Rhino {{}}\System\Yak.exe" spec

Inspecting content: Tamarin.rhp

name: tamarin
version: 1.0.0
authors:
Park Ranger
description: >
 This plug-in does something. I'm not really sure exactly what it's supposed to
 do, but it does it better than any other plug-in.
url: https://example.com
icon: icon.png
keywords:
something


Now that we have a manifest file, we can build the package!


"C:\Program Files\Rhino {{}}\System\Yak.exe" build

Building package from contents of C:\Users\Bozo\dist

Found manifest.yml for package: tamarin (1.0.0)
Inspecting content: Tamarin.rhp
Creating tamarin-1.0.0-rh618-any.yak

name: tamarin
version: 1.0.0
authors:
Will Pearson
description: >
 This plug-in does something. I'm not really sure... [truncated]

GUIDES / YAK / INSTALLING-AND-MANAGING-PACKAGES
------------------------------------------------------------

Index
Source: guides\yak\installing-and-managing-packages\index.md
{{}}
Yak is cross-platform. The examples below are for Windows. For Mac, replace the path to the Yak CLI tool with "/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".
{{}}

Install

Installing a yak package with the CLI tool is simple.


"C:\Program Files\Rhino {{}}\System\Yak.exe" install marmoset

Downloading marmoset (1.0.0)...
Downloaded marmoset (1.0.0)
Installing marmoset (1.0.0)...
Successfully installed marmoset (1.0.0)


{{}}
Rhino will load new packages the next time it starts.
{{}}

You can also ask Yak to install a specific version.


"C:\Program Files\Rhino {{}}\System\Yak.exe" install marmoset 1.0.0

...


The package is installed to a special folder, similar to the Grasshopper Libraries folder but with a folder/file structure that Yak controls.

Uninstall

Packages can also be easily uninstalled using the Yak CLI tool.


"C:\Program Files\Rhino {{}}\System\Yak.exe" uninstall marmoset

marmoset successfully uninstalled


{{}}
Rhino will register that the package has been uninstalled
the next time it starts.
{{}}

List

At any point you can check which packages are currently installed.


"C:\Program Files\Rhino {{}}\System\Yak.exe" list

marmoset (1.0.0)


Related Topics
Yak Guides and Tutorials
Creating a Grasshopper Plug-in Package
Creating a Rhino Plug-in Package

GUIDES / YAK / PACKAGE-RESTORE-IN-GRASSHOPPER
------------------------------------------------------------

Index
Source: guides\yak\package-restore-in-grasshopper\index.md
Overview

For starters, this is less of a developer guide and more of a description of how this feature works, so that you, the developer, can better understand how your package and plug-in needs to be set up in order to leverage it.

It can be frustrating to open a Grasshopper definition only to find that the required plug-ins aren't installed on the system. The package manager can help by streamlining the process of satisfying those dependencies.

Since Rhino 6, the "Unrecognized Objects" dialog presents the user with an option to download and install missing plug-ins. This feature is called Package Restore.

!Grasshopper package restore

Package Restore uses the name, ID and version of the missing plug-ins to search the package server. If any packages match the search query then they will be installed and, if possible, loaded prior to opening the definition[^3].

Matching

Naming

Ideally, the name of the Grasshopper plug-in and the package will match. In case this isn't possible – due to either the constraints of the package naming scheme[^1] or the fact that there are multiple plug-ins in a package each with a different name – the correct package can also be identified by the plug-in ID.

For each .gha file, the plug-in ID is extracted and added to the manifest.yml when you run yak build.

Version numbers

Package version numbers can either follow the Semantic Versioning 2.0.0 (SemVer) spec or they can be four-digits[^2], as per System.Version. See the package server guide for more details on the allowed version number formats.

The server allows both SemVer and four-digit because some Grasshopper plug-ins will specify their version number as a string in a class derived from GH_AssemblyInfo whereas others will rely on the AssemblyVersionAttribute.

While restoring packages, if a package exists on the server that matches either the name or ID of the missing plug-in, but the exact version doesn't exist, the latest stable version will be installed.

[^1]: Package ... [truncated]

GUIDES / YAK / PACKAGE-SOURCES
------------------------------------------------------------

Index
Source: guides\yak\package-sources\index.md
}}
This feature requires modifying advanced settings in Rhino!
{{}} -->

By default Rhino uses the official McNeel package server - https://yak.rhino3d.com. In addition (or instead!), it's possible to configure Rhino to use your own package repositories.

A custom package repository is simply a folder that contains .yak package files. The folder can be on the local machine or on a shared file server. You can configure Rhino to include packages from this repository in the Package Manager by following the steps below.
Go to Options > Advanced and look for the Rhino.Options.PackageManager.Sources setting.
Add the full path to your package repository folder, separating it from the default package server with a semi-colon, e.g. https://yak.rhino3d.com;C:\rhinopackages.
Run the PackageManager command and search for one of the packages that you added to the new package repository.

for now it just supports whatever Directory.EnumerateFiles() supports, which as far as I can tell is regular paths, mapped drives (Windows), UNC paths (Windows) and mounted shares (macOS)

Tips for shared folders

On Windows use the UNC path, i.e. \\server\share\packages. If the share requires credentials then first navigate to \\server in Explorer, log in and check the "remember my credentials" box.

On macOS the file share needs to be mounted first in Finder via Go > Connect to Server... (⌘ + K). Enter the address (smb://server/share) and provide credentials if required. Now the mounted path can be used as a package source, i.e. /Volumes/share/packages. The mount isn't persistent, so it'll need to be remounted in future.

Administrator-Enforced Settings

See Administrator-Enforced Settings for tips on how to deploy and enforce this setting for Windows users in your organisation.

Performance

Rhino 8.15 included some performance improvements for private package repositories.

The yak.exe tool has a new “cache” command that, when run inside the private package folder, will generate an index of ... [truncated]

Essential Code:
$ cd X:\private\repo\directory
$ "C:\Program Files\Rhino 8\System\yak.exe" cache

Building cache for local package repository in X:\private\repo\directory

[...]


GUIDES / YAK / PUSHING-A-PACKAGE-TO-THE-SERVER
------------------------------------------------------------

Index
Source: guides\yak\pushing-a-package-to-the-server\index.md
See the package server guide 

{{}}
Yak is cross-platform. The examples below are for Windows. For Mac, replace the path to the Yak CLI tool with "/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".
{{}}

Authentication

Before you can push a package to the server, you need to authorize the Yak CLI tool using your Rhino Account.


"C:\Program Files\Rhino {{}}\System\Yak.exe" login


A browser tab should open asking you to log in to Rhino Accounts (assuming you are not already logged in). The next window will ask you to give "Yak" access to your account.
View basic info about you: This scope is used to retrieve your name, locale and profile picture. This information will be used in the future, when the package database has a graphical interface.
Verify your identity: Used for authentication when querying package ownership.
View your email address: Your primary email address is stored so that you can be added as an owner of packages that others have published.

Once you've accepted, the browser window will close itself. Yak has retrieved an OAuth token from Rhino Accounts and has stored this on your computer.
Mac - ~/.mcneel/yak.yml
Windows - %APPDATA%\McNeel\yak.yml

{{}}
For security, the OAuth token is valid for a limited time only. Don't be sur... [compressed]URL
Keywords
Icon

Example

Here's an example for a Grasshopper plug-in.


name: plankton
version: 0.3.4
authors:
Daniel Piker
Will Pearson
description: >
 Plankton is a flexible and efficient library for handling n-gonal meshes.
 Plankton is written in C# and implements the halfedge data structure. The
 structure of the library is loosely based on Rhinocommon's mesh classes and
 was originally created for use within C#/VB scripting components in
 Grasshopper.
url: "https://github.com/meshmash/Plankton"


Required Attributes

Name

The short name describing the package. Preferably one world although multiple words can be separated by underscores or hyphens.

 Future uploads ignore the case of the package name and all queries are case-insensitive.


name: plankton


Version

Since 0.8: four-digit version numbers allowed
Since 0.9: $version placeholder

The version number given to the package.

Package version numbers must either follow Semantic Versioning 2.0.0 (e.g. 1.1.0-beta) or System.Version a.k.a. Microsoft's four-digit standard (e.g. 1.2.3.4). It's recommended to use Semantic Versioning because it allows package authors to specify prere... [truncated]

Essential Code:
name: plankton
version: 0.3.4
authors:
  - Daniel Piker
  - Will Pearson
description: >
  Plankton is a flexible and efficient library for handling n-gonal meshes.
  Plankton is written in C# and implements the halfedge data structure. The
  structure of the library is loosely based on Rhinocommon's mesh classes and
  was originally created for use within C#/VB scripting components in
  Grasshopper.
url: "https://github.com/meshmash/Plankton"

{
  "name": "plankton",
  "version": "0.3.4",
  "author": [
    "Daniel Piker",
    "Will Pearson"
  ],
  "dependencies": [

  ],
  "description": "Plankton is a flexible and efficient library for handling n-gonal meshes. Plankton is written in C# and implements the halfedge data structure. The structure of the library is loosely based on Rhinocommon's mesh classes and was originally created for use within C#/VB scripting components in Grasshopper.",
  "license": "LGPL-3",
  "url": "https://github.com/meshmash/Plankton",
  "type": "gh-plugin"
}


GUIDES / YAK / THE-PACKAGE-SERVER
------------------------------------------------------------

Index
Source: guides\yak\the-package-server\index.md
We host a public package server for everyone to use. You don't need to configure anything. Both the Yak CLI tool and Rhino already know where to look.

Packages shared on the public package server are free to download and install. They may be free to use or require a license – see the Cloud Zoo and Zoo guides for ways to implement licensing in your plug-in using our tools.

Below are a few useful facts about our package server.

Authentication and authorization

Authentication, provided by Rhino Accounts, is only required for publishing packages, not for downloading/installing.

Once a package author has published a package, only they can publish future versions using the same package name.

{{}}
Functionality to add "collaborators" will be added in the future.
{{}}

Conventions

The package server has a few conventions that must be followed.

Naming

Package names are pretty strict. They only allow letters, numbers, hyphens and underscores, e.g. HelloWorld or hello-world1.

Package names adopt the case used in the very first version that was uploaded. Future uploads ignore the case of the package name and all queries are case-insensitive.

Versioning

Package version numbers must either follow Semantic Versioning 2.0.0 (e.g. 1.1.0-beta) or System.Version a.k.a. Microsoft's four-digit standard (e.g. 1.2.3.4).

It's recommended to use Semantic Versioning because it allows package authors to specify prerelease versions. These are handy for limited testing, since by default the latest stable version is installed.

Four-digit version numbers were added in v0.8 (August 2019) to support existing plug-ins that use System.Version-style version numbers. They do not support pre-release or build metadata.

Partial version numbers and normalisation

When a package is created you may notice that the version number in the filename is different to the one in manifest.yml. This is due to version number normalisation. This same process happens behind the scenes on the package server... [truncated]

GUIDES / YAK / WHAT-IS-YAK
------------------------------------------------------------

Index
Source: guides\yak\what-is-yak\index.md
Overview

The Rhino Package Manager assists in the discovery, installation, and management resources in the Rhino ecosystem (Grasshopper included!). Currently it supports Rhino and Grasshopper plug-ins, but the goal is to include things like scripts, materials, viewports, etc. in the future!

{{}}
The Rhino Package Manager was initially referred to by the codename "Yak". The name Yak is still used for the command line tool that creates and publishes packages.
{{}}

The package manager has several goals.
Make it easier for users to discover and manage plug-ins and more
Help developers and reusable content authors to share their work
Provide simple system administration tools

Not wanting to reinvent the wheel, we've taken inspiration from Linux and the
software development world. The package management system can be broken down
into three main areas.
Server
Integrations
Command line tool

Server

The package server is the heart of the system. Once created, packages are pushed
to the server to share them with others. It keeps the packages organised for its
clients – the command line tool and Rhino (via integrations).

{{}}
In addition to the public package server (https://yak.rhino3d.com), the package manager also supports file-/folder-based custom package repositories.
{{}}

Integrations

Integrations provide direct access to the package ecosystem from inside of Rhino. Currently this has been done in two ways; "package restore" for Grasshopper and the package manager UI.

Package restore for Grasshopper

The Rhino Package Manager has been integrated into Grasshopper's "Unrecognized Objects" dialog, providing package restore functionality. When opening a new file which contains components from a plug-in not installed on the machine, the user is given the option to check the package server for the missing plug-ins and install them directly.

!Package restore for Grasshopper

Package Manager UI

The package manager UI is avilable via the _PackageManager command. It prov... [truncated]

GUIDES / YAK / YAK-CLI-REFERENCE
------------------------------------------------------------

Index
Source: guides\yak\yak-cli-reference\index.md
The Yak command line tool is included with Rhino 7 WIP. On Windows the tool is located at "C:\Program Files\Rhino {{}}\System\yak.exe". On macOS there is a convenience script at "/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".

Commands

Build

 Since 0.2: Command added... [compressed]COMMON WORKFLOWS
------------------------------------------------------------
See individual category sections above for specific workflows.
Common patterns include: creating geometry, modifying objects, working with layers, viewport management, and file I/O.
TROUBLESHOOTING
------------------------------------------------------------
Common issues: API version compatibility, platform-specific behavior, memory management, and error handling. Refer to specific API documentation for detailed troubleshooting.
LIMITS AND GOTCHAS
------------------------------------------------------------
Platform differences between Windows and Mac. API availability varies by Rhino version. Memory management important for large geometry operations. Thread safety considerations for multi-threaded operations.
and normalisation

When a package is created you may notice that the version number in the filename is different to the one in manifest.yml. This is due to version number normalisation. This same process happens behind the scenes on the package server... [truncated]

GUIDES / YAK / WHAT-IS-YAK
------------------------------------------------------------

Index
Source: guides\yak\what-is-yak\index.md
Overview

The Rhino Package Manager assists in the discovery, installation, and management resources in the Rhino ecosystem (Grasshopper included!). Currently it supports Rhino and Grasshopper plug-ins, but the goal is to include things like scripts, materials, viewports, etc. in the future!

{{}}
The Rhino Package Manager was initially referred to by the codename "Yak". The name Yak is still used for the command line tool that creates and publishes packages.
{{}}

The package manager has several goals.
Make it easier for users to discover and manage plug-ins and more
Help developers and reusable content authors to share their work
Provide simple system administration tools

Not wanting to reinvent the wheel, we've taken inspiration from Linux and the
software development world. The package management system can be broken down
into three main areas.
Server
Integrations
Command line tool

Server

The package server is the heart of the system. Once created, packages are pushed
to the server to share them with others. It keeps the packages organised for its
clients – the command line tool and Rhino (via integrations).

{{}}
In addition to the public package server (https://yak.rhino3d.com), the package manager also supports file-/folder-based custom package repositories.
{{}}

Integrations

Integrations provide direct access to the package ecosystem from inside of Rhino. Currently this has been done in two ways; "package restore" for Grasshopper and the package manager UI.

Package restore for Grasshopper

The Rhino Package Manager has been integrated into Grasshopper's "Unrecognized Objects" dialog, providing package restore functionality. When opening a new file which contains components from a plug-in not installed on the machine, the user is given the option to check the package server for the missing plug-ins and install them directly.

!Package restore for Grasshopper

Package Manager UI

The package manager UI is avilable via the _PackageManager command. It prov... [truncated]

GUIDES / YAK / YAK-CLI-REFERENCE
------------------------------------------------------------

Index
Source: guides\yak\yak-cli-reference\index.md
The Yak command line tool is included with Rhino 7 WIP. On Windows the tool is located at "C:\Program Files\Rhino {{}}\System\yak.exe". On macOS there is a convenience script at "/Applications/Rhino {{}}.app/Contents/Resources/bin/yak".

Commands

Build

 Since 0.2: Command added... [compressed]COMMON WORKFLOWS
------------------------------------------------------------
See individual category sections above for specific workflows.
Common patterns include: creating geometry, modifying objects, working with layers, viewport management, and file I/O.
TROUBLESHOOTING
------------------------------------------------------------
Common issues: API version compatibility, platform-specific behavior, memory management, and error handling. Refer to specific API documentation for detailed troubleshooting.
LIMITS AND GOTCHAS
------------------------------------------------------------
Platform differences between Windows and Mac. API availability varies by Rhino version. Memory management important for large geometry operations. Thread safety considerations for multi-threaded operations.
